<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>Hexo</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hexo</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/05/21/%E9%9D%A2%E7%BB%8F%E6%B1%87%E6%80%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/05/21/%E9%9D%A2%E7%BB%8F%E6%B1%87%E6%80%BB/" class="post-title-link" itemprop="url">面经汇总</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-05-21 21:16:24 / Modified: 21:19:24" itemprop="dateCreated datePublished" datetime="2023-05-21T21:16:24+08:00">2023-05-21</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="嵌入式"><a href="#嵌入式" class="headerlink" title="嵌入式"></a>嵌入式</h1><ol>
<li>介绍下总线设备驱动模型</li>
</ol>
<ol start="2">
<li>U-boot启动流程</li>
</ol>
<ol>
<li><p>介绍下总线设备驱动模型；</p>
</li>
<li><p>U-boot启动流程；</p>
</li>
<li><p>项目xxxAD/DA驱动程序的实现；</p>
</li>
<li><p>AD采样率，UDP通信数据量大不大；</p>
</li>
<li><p>使用到多线程了吗？多线程之间怎样通信？</p>
</li>
<li><p>中断与任务之间通信方式？</p>
</li>
<li><p> 中断中使用消息队列需要注意什么？</p>
</li>
<li><p> ARM的中断处理流程，以及每个阶段做什么事？</p>
</li>
<li><p> 中断上下文；</p>
</li>
<li><p>项目中使用到了DMA吗？DMA是什么？我们写程序DMA需要做一些什么？（回答的不好）<br>DMA方式则是以数据块为单位传输的,在所要求传送的数据块全部传送结束时要求CPU进行中断处理,这样大大减少CPU进行中断处理的次数。<br>面试官应该想问的是DMA控制器的中断配置与处理，软件中使用双缓冲区能加快数据读写速度。</p>
</li>
<li><p> 项目中用到i.MX6ULL，是否大材小用了？</p>
</li>
<li><p> 项目中用的芯片内存有多大，写的程序占用空间？</p>
</li>
<li><p> 项目中需要比较难的问题，你是怎么解决的？</p>
</li>
<li><p> 除了SPI，你还用到过哪些通信协议？</p>
</li>
<li><p> static关键字；</p>
</li>
<li><p> 问我还熟悉哪些关键字，答volatile，让我说说；</p>
</li>
<li><p> 堆和栈的区别，怎样减少堆和栈的使用？</p>
</li>
<li><p> 怎样衡量一个处理器的处理能力，如果项目换成STM32，你会选择哪一款，为什么？</p>
</li>
<li><p> 问我有什么问题？答：该部门主要做什么方向的工作。</p>
</li>
<li><p>2.2 感谢信（2021.08.26）一面感觉面得还不错吧，但是就是挂了，隔了接近两个月发了感谢信，晕，我加的嵌入式群里基本没有拿到乐鑫的offer，感觉没怎么招人。</p>
</li>
<li><p>3 中兴-成都提前批由于参加了中兴捧月算法大赛并获得区域优胜奖，直通终面</p>
</li>
<li><p>3.1 现场面试（2021.07.16）50min1. 自我介绍；</p>
</li>
<li><p>ARM的开发流程；</p>
</li>
<li><p>U-boot和内核的启动流程；</p>
</li>
<li><p>设备树是什么时候被识别（加载）的？</p>
</li>
<li><p>Linux内核的总线设备驱动模型；</p>
</li>
<li><p>举例一个项目，自己负责哪些内容；</p>
</li>
<li><p>说一说PID算法；</p>
</li>
<li><p>用过哪些系统调用；</p>
</li>
<li><p>堆和栈的区别；</p>
</li>
<li><p> malloc分配超过内存更大的空间，会发生什么？<br>能够正常分配，malloc能够申请的空间大小与物理内存没有直接关系，仅与程序的虚拟地址空间有关</p>
</li>
<li><p>C语言中函数调用的值存放在哪里？（我一开始以为问的是局部变量存放区域：栈区）<br>例如：<br>void funcA(int a, int b){<br>}<br>void funcB(void){</p>
<pre><code> funcA(1,2);
</code></pre>
<p>}<br>那么这个值1和2存放在寄存器中的，比如常用R0 R1寄存器</p>
</li>
<li><p> c语言代码规范，然后给我了一段代码，让我评价；</p>
</li>
<li><p> 栈空间分配超过最大值时，会发生什么？怎样检测内存溢出？</p>
</li>
<li><p> 其他的就问的手上目前有offer吗？家庭情况，目标薪资，意向工作地。</p>
</li>
<li><p>3.2 面试通过（2021.07.20）</p>
</li>
<li><p>3.3 offer(2021.9.8)月薪17K（其中包含了1200元的餐补）<br>第一年无年终，后边2-6个月年终，一般3个月<br>加班无加班费，1 2 4加班到8点多，周六可能加班<br>每天15元的餐补，加班报销车费和餐费<br>最终拒了。</p>
</li>
<li><p>4 浙江大华-西安提前批</p>
</li>
<li><p>4.1 一面电话面（2021.07.17）25min1. 自我介绍；</p>
</li>
<li><p>C++用的多吗？</p>
</li>
<li><p>做过的项目，代码量总共有多少？</p>
</li>
<li><p>多线程编程和网络编程有用过吗？</p>
</li>
<li><p>linux创建线程的函数；</p>
</li>
<li><p>说下字符串相关的函数？<br>strcat/strcmp/strcpy/strncpy/memcpy</p>
</li>
<li><p>strcpy与memcpy的不同，memcpy安全吗（memmove）？</p>
</li>
<li><p>static的用法；</p>
</li>
<li><p>堆和栈的区别？不释放堆空间会导致哪些问题？</p>
</li>
<li><p> 内存泄漏和内存溢出的不同？</p>
</li>
<li><p> 平时写程序有遇到过类似段错误吗？</p>
</li>
<li><p> 怎样检测内存溢出？</p>
</li>
<li><p> gdb调试工具熟悉吗？gdb打印堆栈大小的命令：backtrace（bt）；</p>
</li>
<li><p> TCP三次握手详细过程；</p>
</li>
<li><p> 如果让你写一个TCP Server，你需要用到那些函数？<br>socket/bind/listen/accept/send/recv/close</p>
</li>
<li><p> 服务端为什么要用listen监听呢?（感觉回答错了）<br>两个队列（网络编程P84）；</p>
</li>
<li><p> 服务端什么时候会建立连接呢？<br>答：当客户端调用connect函数时</p>
</li>
<li><p> 平时空闲时间会看书吗？看什么书籍？</p>
</li>
<li><p>4.2 二面电话面（2021.07.27）20min1. 主要是问项目，AD采样的精度；</p>
</li>
<li><p>项目性能指标达到预定目标吗？</p>
</li>
<li><p>驱动程序中用到了中断吗？</p>
</li>
<li><p>就是深挖项目；</p>
</li>
<li><p>4.3 HR面（2021.07.29）30min1. 本科和研究生期间，有没有遇到时间很紧张的时候？</p>
</li>
<li><p>项目中遇到的困难，如何解决；</p>
</li>
<li><p>各种问遇到问题该如何解决。。。；</p>
</li>
<li><p>工作意向地；</p>
</li>
<li><p>女朋友在哪里学习或工作？</p>
</li>
<li><p>家是哪里的？</p>
</li>
<li><p>意向薪资（杭州或西安）；</p>
</li>
<li><p>反问，公司培养体系以及娱乐设施。</p>
</li>
<li><p>4.4 意向书（2021.08.03）</p>
</li>
<li><p>4.5 offer（2021.09.15）基本月薪19K 西安</p>
</li>
<li><p>5 联发科-成都提前批</p>
</li>
<li><p>5.1 一面（2021.07.22）70min1. 你用过的ARM9和Cortex-A7芯片做个对比？</p>
</li>
<li><p>linux下写过哪些驱动程序？说一下IIC的驱动框架？</p>
</li>
<li><p>问项目，客户的需求，用到哪些技术？</p>
</li>
<li><p>项目中遇到比较难的问题，怎么解决的？</p>
</li>
<li><p>有没有遇到时间紧、任务重的时候，自己怎样安排时间？</p>
</li>
<li><p>C语言中#ifndef #define#endif的作用？</p>
</li>
<li><p>大端模式和小端模式；</p>
</li>
<li><p>给了一个题，让说思路以及写出核心代码；<br>按序找到数组中的最小的k个数，对于一个无序数组，数组中元素为互不相同的整数，请返回其中最小的k个数，顺序与原数组中元素顺序一致。比如：输入<br>4 2<br>2<br>1<br>3<br>4<br>输出2 1<br>说了思路后，面试官说空间复杂度高了，谈到尽量从代码角度降低功耗的问题。</p>
</li>
<li><p>跨平台写一个文件，另一平台进行读取文件，需要注意哪些问题？</p>
</li>
<li><p> w与wb的区别；</p>
</li>
<li><p> 有了解最新技术动态吗？关注新技术发展；</p>
</li>
<li><p> 剩下的基本上是聊公司情况，部门工作，新人培养等。</p>
</li>
</ol>
<p>2.5.2 二面（2021.07.29）55min1. 智能汽车比赛，整个系统分了几个模块，每个模块的功能；<br>2. 实用新型专利主要是什么内容；<br>3. 省级创新训练项目；<br>4. 总线设备驱动模型；<br>5. 你怎样看设备树；<br>6. 项目中设备树、设备驱动的详细流程；<br>7. U-boot以及内核的启动流程；<br>8. 被问到与公司领导意见不一致时该怎么办?<br>9. 谈一谈客户技术支持的看法；<br>10. 谈一谈对加班的看法；<br>11. 目前有投其他公司吗？<br>12. 反问：面试官这个部门主要是做手机芯片，做开发，音视频编解码；<br>13. 公司环境不错；<br>2.5.3 面试通过（2021.08.19）<br>2.5.4 联发科成都offer(2021.09.10)基本薪资：统一价，offershow上可以查看；<br>绩效：保证的是4-5个月；去年绩效3个月保底，根据公司营收情况适当调整<br>签字费：3个月，实习期3个月满一次性发放<br>每年3月份会根据评估调研，有一次涨薪机会，也会评级，目前的评级还不能告诉<br>五险按照成都市要求缴纳，7%的住房公积金<br>用餐补贴：早（5元）+中（15元）+晚（15元）基本吃饭自己不花钱<br>加班少，965，如果加班，申请后得加班费（平时1.5倍，周末2倍，节假日3倍）</p>
<p>PS:<br>整体感觉挺不错，联发科评价都还挺好，只是按照今年的行情来讲，底薪确实低了点。此时，手上其他offer没有纠结，纠结的就是联发科和芯原，联发科做手机芯片驱动此类工作，客户主要是面向vivo、oppo等手机，芯原薪资在后边会说明，方向是GPU编译器开发，芯原体量确实没联发科大，毕竟联发科发展很多年了，芯原有自己的IP定制业务，未来发展应该还是不错的。最终通过导师和韦东山老师的建议，还是选择GPU方向，自己也对这一方面蛮有兴趣的。<br>拒了offer之后成都这边部门负责人打电话，想了解下，问能不能再考虑下，但是我已经签了芯原了，负责人说联发科虽然底薪低，但是加上加班费一个月也能到20K左右。但是目前已经签了，不纠结了。（PS: 去年华为遭受制裁，联发科营收130多亿美元，因此保证了年终4-5个月，但底薪比较低。最终还是拒了，希望自己在芯原Verisilicon努力专研，提升个人竞争力）<br>2.6 海康威视-成都启明星<br>2.6.1 一面电话面（2021.08.17）30min突然打电话过来，电话面试<br>主要问的项目</p>
<ol>
<li>项目中用的哪款芯片，它的一些配置，Cortex-A7与ARM9区别有哪些？</li>
<li>linux内核启动流程；</li>
<li>C语言中inline关键字，所有时候都会进行内联展开吗？</li>
<li>公司业务：研究院，芯片固件、驱动、内核、外设；</li>
<li>6.2 二面视频面（2021.08.25）32min1. 自我介绍；</li>
<li>最熟悉的项目是哪一个？</li>
<li>你觉得做这个项目你的最大收获是什么？</li>
<li>项目过程中遇到哪些问题，怎么解决的？</li>
<li>用的linux内核版本是多少？为什么要用这个版本呢？</li>
<li>用到多线程了吗？为什么要用多进程而不用多线程；</li>
<li>popen</li>
</ol>
<p>124#66 9:03:31 PM<br>与system区别；<br>8. 看这个功能还比较简单，为什么用Cortex-A7的ARM芯片；<br>9. 程序做了哪些优化？<br>10. 中断和轮询的效率问题；<br>11. 上位机与下位机的通信？<br>12. 为什么用UDP而不用TCP；<br>13. 问了两个数学题，第一个是1+1/2+1/4+1/8+…+1/2^n=?;第二个是1+1/2+1/3+…+1/n = ?<br>2.6.3 HR面（2021.09.01）20min<br>2.6.4 综合面试（2021.09.09）40min不知道为啥HR面之后还有综合面试，综合面试主要问项目，问的也不深，主要在于解决问题的能力<br>2.6.5 海康成都研究院offer（2021.09.14）底薪80%+绩效20%=19K<br>年终奖3-6个月<br>住房公积金12%<br>餐补20（中午）早上8点半之前（5元）晚上8点半后（20元）<br>1 2 4加班到8点半，3 5 不要求，周末大小周5个小时加班<br>其他时间加班申请通过会给加班费<br>带薪年假 高温补贴等<br>线下签约答疑会时，部门主管加了微信，对于面试表现还是比较满意，希望能够去，方向主要是做芯片固件开发，包括AI芯片、视频编解码芯片等，今年海康和大华的offer还是比较体面了，但是还是考虑到其他因素，最终还是拒了。<br>2.7 大疆-西安正式批<br>2.7.1 笔试（2021.08.14）题型：单选、多选、判断、填空、简答、编程<br>主要考察C语言、实时操作系统、linux相关知识<br>多选题（3’）<br>关于arm的Cortex-M内核寄存器，以下说法正确的是：<br>A. R0~R12为通用寄存器，所有的ARM指令均可访问用于计算；<br>B. R13为栈指针寄存器，包含MSP和PSP，特权模式下使用MSP；<br>C. R14为LR寄存器，用于保存调用函数执行完后的返回值；；<br>D. R15为PC寄存器，执行指令后会由硬件修改，指向下一条指令；</p>
<p>对于嵌入式实时操作系统RTOS，以下说法正确的是：<br>A．对于抢占式内核，高优先级任务一旦就绪就可以立即被响应；<br>B．对于抢占式内核，同一优先级的任务一般采用时间片轮转调度；<br>C．空闲任务一般设置为最低优先级，当没有其他任务就绪时，会执行空闲任务；<br>D．RTOS执行的每个任务均有独立的任务栈，不需要划分主栈<br>填空题（4’）：</p>
<ol>
<li>关于结构体对齐</li>
<li>将数据从一个地址空间复制到另一个地址空间而不用占用CPU，最好使用DMA方式</li>
<li>数据直接从用户态地址空间写入到磁盘中，跳过内核缓冲区，这种IO方式叫：直接IO；</li>
<li>ARM Cortex-A7系列处理器中可以通过什么指令集对向量计算进行加速：NEON；<br>ARM的NEON是类似于X86的SSE2的一种优化的指令集，主要就是为了实现SIMD全称Single Instruction Multiple Data，单指令多数据流，能够复制多个操作数，并把它们打包在大型寄存器的一组指令集。简单来说就是处理一些算法的时候，可以并行处理，大大提高了效率。</li>
</ol>
<p>简答题(2*5’)：</p>
<ol>
<li><p>用户进程和内核进程抢占执行的时机<br>用户抢占发生于：<br>l 内核从系统调用返回用户空间时；<br>l 从中断处理程序返回用户空间时；<br>详细来说，内核即将返回用户空间的时候，如果need_resched标志被设置，会导致schedule()被调用，此时就会发生用户抢占。内核无论是在中断处理程序还是在系统调用后返回，都会检查need_resched标志是否被设置，如果设置了，内核会选择一个其他（更合适的）进程投入运行。<br>内核抢占发生于：<br>l 中断处理程序退出，且返回内核空间之前；<br>l 内核代码再一次具有可抢占性的时候（比如spinlock_unlock时会preempt_enable()）；<br>l 如果内核中的任务显式地调用schedule()；<br>l 如果内核中的任务阻塞（同样会导致调用schedule()-比如使用mutex/sem/waitqueue获取不到资源时）；</p>
</li>
<li><p>定义一个宏，通过结构体成员，找到结构体的首地址#define container_of(ptr, type, member) ({                        \</p>
<pre><code> const typeof( ((type *)0)-&gt;member ) *__mptr = (ptr);        \
 (type *)( (char *)__mptr - offsetof(type,member) );&#125;)
</code></pre>
<p>引申：通过结构体获取结构体成员的偏移地址#define offsetof(TYPE, MEMBER) ((size_t) &amp;((TYPE *)0)-&gt;MEMBER)</p>
</li>
</ol>
<p>编程题：两道编程题，难度中等<br>2.7.2 一面电话面（2021.09.03）面试官是做编译器的，面试官说希望找由编译器开发经验的同学，我晕，我一个应届生，有这开发经历吗？<br>问题全是系统性的问题，比如：<br>问：有没有从零去用FreeRTOS去适配一款新的芯片<br>答：没有，所涉及的STM32也是官方支持的，自己需要做的就是移植工作，修改硬件相关的代码。然后自己讲了下STM32中FreeRTOS的启动流程，自己觉得适配一款芯片需要做哪些事情，能回答的都回答了。<br>面试过程中全是有无这样那样的经历，最终问了面试官，说编译器部门这边比较偏向于社招。。。<br>面完就感觉不是面试官找的人<br>2.7.3 感谢信（2021.09.23）总结：大疆是每个做嵌入式的同学都很想去的，很不甘心，自己所准备的一个也没被问，项目也是没被问到。就感觉部门没有根据简历来应聘，可能面试也需要看一些缘分吧，心塞。。。最终我总结了下，我的问题应该是笔试做得很差，算法题没有好好刷，这一方面是我的弱项，导致后边被捞起来面试就很晚了，有些8月份都面完了。被捞的部门不是很对口，导致面试表现不好，自己准备的相关知识一个没问。所以想要去大疆、华为、oppo、vivo、哲库这种软开和嵌入式都一套题的公司，嵌入式还是得好好刷题。<br>2.8 CVTE-广州提前批<br>2.8.1 一面视频面（2021.08.21）40min1. 自我介绍<br>2. U-boot移植做了哪些事情？<br>3. Nand Flash具体细节，存储空间大小，怎样检查数据是否正确？<br>4. Nand Flash有哪些线？具体操作命令，发命令、发地址、写数据、读数据；<br>5. 内核的启动流程；<br>6. 用过哪些总线？<br>7. 说下IIC具体时序，说下UART、IIC、SPI之间的区别；<br>8. 还用过其他外设总线吗？像SDIO、PCIE等；<br>9. 有做过应用相关的开发吗？<br>10. 进程与线程的区别；<br>11. LCD驱动相关，LCD屏的配置主要有哪些参数，时钟多少，怎样配置；<br>12. LCD时钟与刷新率有关吗？<br>13. 写过shell脚本吗？写过Makefile吗？<br>14. Linux的任务调度；<br>15. 进程间通信有哪些方法？你用过哪些？<br>16. 说下信号量的实现原理；<br>17. 信号量与锁的区别；<br>18. 看了一个程序，问程序输出；<br>class A {<br>public:<br>    void PrintfFun1(void) {<br>        cout &lt;&lt; “PrintfFun1” &lt;&lt; endl;<br>    }</p>
<pre><code>void PrintfFun2(void) &#123;
    cout &lt;&lt; &quot;PrintfFun2&quot;  &lt;&lt; endl;
&#125;
</code></pre>
<p>};<br>int main()<br>{<br>    A* pA = NULL;<br>    pA-&gt;PrintfFun1();<br>    pA-&gt;PrintfFun2();<br>    return 0;<br>}<br>并不会出错，能够正常输出。<br>当调用成员函数时，A* pA = NULL只是将实参null传给this指针，PrintfFun1成员函数中并无任何需要通过this指针访问的数据成员，因此没有带来任何影响。<br>但是如果是如下所示：<br>class A {<br>public:<br>    void PrintfFun1(void) {<br>        cout &lt;&lt; “PrintfFun1” &lt;&lt; endl;<br>    }</p>
<pre><code>void PrintfFun2(void) &#123;
    cout &lt;&lt; &quot;PrintfFun2&quot; &lt;&lt; data &lt;&lt; endl;
&#125;
</code></pre>
<p>private:<br>    int data = 10;<br>};<br>详细解释：C++的静态绑定<br>pA-&gt; PrintfFun1 ();<br>这语句的意图是：调用对象 pA 的 PrintfFun1成员函数。如果这句话在Java或Python等动态绑定的语言之中，编译器生成的代码大概是：</p>
<p>找到 pA 的 PrintfFun1成员函数，调用它。（注意，这里的找到是程序运行的时候才找的，这也是所谓动态绑定的含义：运行时才绑定这个函数名与其对应的实际代码。有些地方也称这种机制为迟绑定，晚绑定。）</p>
<p>但是对于C++。为了保证程序的运行时效率，C++的设计者认为凡是编译时能确定的事情，就不要拖到运行时再查找了。所以C++的编译器看到这句话会这么干：</p>
<ol>
<li>查找 pA 的类型，发现它有一个非虚的成员函数叫 PrintfFun1。（编译器干的）</li>
<li>找到了，在这里生成一个函数调用，直接调A:: PrintfFun1 ( pA )。</li>
</ol>
<p>所以到了运行时，由于 PrintfFun1 ()函数里面并没有任何需要解引用 pA 指针的代码，所以真实情况下也不会引发segment fault。这里对成员函数的解析，和查找其对应的代码的工作都是在编译阶段完成而非运行时完成的，这就是所谓的静态绑定，也叫早绑定。<br>19. linux下的命令有用过吗？<br>20. linux下，查找当前目录下所有.c文件下的包含“hello world”字符串的文件的命令（find/grep命令的用法）<br>find ./ -name “*.c” -exec grep -in “hello world” {} ; -print<br>2.8.2 过了几天查看状态，被挂了面试官一脸不屑的样子，回答每一个问题，都会问你确定吗？你确定是这样的吗？搞得我都不自信了。反正面试体验不好，加之网上对CVTE风评也不太好，挂了也没有影响到后边的面试，无所谓了。但是问的问题有必要进行复盘，以免后面问道回答不上来。<br>2.9 商汤科技-成都领航员<br>2.9.1 一面视频面（2021.08.27）60min前30min聊基础技术知识，后30min聊项目，面试体验很好。。。</p>
<ol>
<li>自我介绍；</li>
<li>UART、IIC、SPI差别，速率，接口等；</li>
<li>UART、RS232、RS422区别；</li>
<li>自旋锁、互斥锁的区别；</li>
<li>线程间通信和同步方式有哪些？</li>
<li>中断上半部和下半部的处理；</li>
<li>OSI协议分层；</li>
<li>内存泄</li>
</ol>
<p>124#66 9:03:31 PM<br>漏与内存溢出；<br>9. 平时写程序过程中会进行检测吗？方法是什么？<br>10. static关键字；<br>11. 指针与数组的区别；<br>12. 进程与线程；<br>13. 全局变量可不可以定义在可被多个.C文件包含的头文件中？<br>14. 局部变量能否和全局变量重名？<br>15. 项目中的难点是什么，怎样解决的？<br>16. 项目中多线程的处理；<br>17. 上位机为何不用QT，而使用C#呢？<br>2.9.2 无消息某一晚上打电话过来由于在笔试没接，后面就没打过来了，打过去需要分机号，打不通的，离谱。<br>2.10 经纬恒润-成都正式批<br>2.10.1 面试（2021.09.02）总共两轮面试，合并为一轮，两个面试官<br>面试比较简单，项目+基础知识<br>面试感觉有点水水的，看了下网上评价不大好，给的薪资也比较低。<br>2.10.2 感谢信（2021.10.09）<br>2.11 华为-成都正式批<br>2.11.1 机试（2021.09.15）120min9月1号做的机试没过，太难了，自己太菜了。实验室软开的同学没做出来一道完整的，但是只要写一些有输出也会有分的，我题刷的少，做得很差。转投测开，又做了一次，过了。。。<br>2.11.2 一面（2021.09.23）此时已经签了芯原了，想着没有华为的秋招不算圆满，就继续面试。。。<br>项目+机试复盘问思路+手撕代码<br>给定一个小写字母组成的字符串s，最多只能进行一次变换，返回变换后能得到的最小字符串（按照字典序进行比较）。<br>变换规则：交换字符串中任意两个不同位置的字符<br>输入：bcdefa<br>输出：acdefb<br>说明：a和b交换得到最小字符串<br>2.11.3 二面（2021.9.23）项目+手撕<br>自动售货机仅能接收1元，5元，10元纸币，所售卖的货物单价不超过20元，单次售卖1件货物，<br>单次购买投币次数最大10次，如果购买成功售出货物的同时找零，否则退回纸币。<br>（1）        请实现此售卖程序（语言不限）；<br>（2）        请设计用例测试售卖程序；<br>输入：货物单价，第一次投币金额，第二次投币金额，…第N次投币金额<br>输出：售货成功/失败，找零X元/退回X元<br>示例：<br>输入：18,10,5,5<br>输出：售货成功，找零2元<br>2.11.4 主管面（2021.9.23）常规问题<br>当天就给面试通过短信通知，没错，一样的进池子了。。。<br>2.11.5 意向书（2021.11.01）来的很晚了，本来以为没有了，但是岗位是测开。本来也不抱任何希望，还是想做开发，不想做测试。过了几天，成都无线产品线这边hr打电话说14级，20K*（14-16）一般3个月年终，公积金5%，其他什么补贴也没有，工作日加班没加班费，具体分到那个小部门还不能确定，周末加班会有加班费，想着测开就拒了，测开不想去。Hr说不急着拒，让我考虑考虑，后边又打电话，说测开不考虑了，他说要是能转开发，给21K，来不来，我说先确定下能不能转为嵌入式开发吧，能转的话是怎么样的流程，结果就没有后文了。<br>想去华为首先机试一定要通过，自己就是题刷的不好，失去了自己想应聘岗位的面试机会。<br>2.12 汇顶科技-成都正式批<br>2.12.1 一面（2021.09.10）<br>2.12.2 二面（2021.09.10）流程还是很快，面试问的主要是项目，比较常规。<br>2.12.3 offer嵌入式软件；CSI部门</p>
<ol>
<li>基本工资18<em>16+1K</em>12</li>
<li>公积金6%</li>
<li>1.2w安家费<br>最终拒了，汇顶给的还是挺高的，通过师兄和老师的了解，还是拒了。</li>
<li>13 芯原-成都正式批</li>
<li>13.1 技术面（2021.09.17）项目+基础知识，问得很细，项目和比赛基本都问了</li>
<li>13.2 HR和英语面（2021.09.17）常规问题+英语口语</li>
<li>13.3 CEO面（2021.09.17）问的是同一个问题：芯原为什么只做服务不做产品<br>当天晚上出结果，第二天参观公司，选择意向岗位，效率挺高，参观了公司，公司文化氛围都不错，师兄也进行了推荐。</li>
<li>13.4 Offer（2021.09.18）GPU编译器研发，听了导师和韦东山老师的意见，比较推荐去</li>
<li>基本薪资：offershow上能够查看； </li>
<li>每年3月份会根据评估调研，有一次涨薪机会，据说20%~30% </li>
<li>五险按照成都市要求缴纳，12%的住房公积金</li>
<li>不加班，965 </li>
</ol>
<p>最终签约，希望能在芯原有好的发展，国内GPU和龙头企业差距还很大，国家目前投入的也还是挺多，芯原与其他公司也在深度合作，比如英特尔、景嘉微等，国产芯片不仅仅是制造问题还有知识产权IP的问题，国产GPU道阻且长，加油吧。<br>2.14 卓胜微-成都正式批<br>2.14.1 线下面试（2021.08.31）50min面试也是基本知识，包括C语言、操作系统，项目细节实现，详细的问了每个项目。<br>面完之后，hr小姐姐还带我去楼下吃了个饭，送了点礼物。人文关怀还是不错的，非常感谢。<br>2.14.2 offerHR打电话说面试通过了，问其他offer目前的情况，给的多少。。。<br>就感觉是按照别的公司来给，最终我手上已经有比较多的offer，他们给的好像是16*16，然后可以申请给股票，等等一些东西，然后说薪资还可以协商，能够与汇顶给到一样的价格，公司成都这边目前还是主要偏向于社招。<br>后边我签芯原之后，就明确给Hr说了下，就说不准备签约了，主要考虑到成都这边规模还是比较小，但是技术栈还是挺不错的，蓝牙协议栈、驱动开发。<br>2.15 中电10所-成都正式批芯原面试当天，早上学校中期答辩，答辩完马上打车去芯原参加面试，面完芯原就打车去一个酒店面试10所去了，面完之后挺累的一天。<br>2.15.1 技术面（2021.09.17）40min面试问的还是很细，包括了C、C#、C++语言基本特性，常规问题，还有项目的细节<br>2.15.2 综合面试（2021.09.17）20min比较常规，大概说了下薪资福利，加班情况，HR说目前业务还是比较繁忙，需要加班，让有个心理准备。<br>2.15.3 Offer年薪17个W，加班比较多，考虑后拒了。</p>
<ol start="3">
<li>嵌入式软件学习路线秋招结束，一直想写一个嵌入式学习路线，仅供参考。本科和研究生一直在学习嵌入式，总的来讲，学的也很平庸，没什么特别突出的点。本科双非，硕士985，本科有国奖、国家励志等，比赛有飞思卡尔和电赛等。研究生没怎么参加比赛，主要是跟着导师做项目，项目偏嵌入式软件，测控方面多一点，获得过学业奖学金等。以下嵌入式比较重要的两个点，可以参考，STM32加实时操作系统，目前应用的非常广泛，ARM加Linux是一种提高，可以深入学习，处理性能会有大幅提升，比如Cortex-A系列。</li>
<li>1 STM32+RTOS这一部分的学习，主要是购买正点原子的开发板，结合正点原子和野火的文档，深入理解，野火的文档非常不错，对于一些知识讲得很好。</li>
<li>C语言基本知识，比如：结构体、数组、指针等相关知识，以及用面向对象的思想写C代码，在linux内核源码中会有很多这样的例子，比如，函数指针的应用等；</li>
<li>STM32裸机相关知识，包括时钟、定时器、中断、GPIO、串口、IIC、SPI等，主要理解硬件原理以及通过代码编程练习对硬件的操作，main函数之前做了哪些事情等等；</li>
<li>RTOS的相关知识，可以选择uCOS、FreeRTOS、RT-Thread等，我主要偏向于FreeRTOS的学习，因为项目会用到，其中主要掌握FreeRTOS的启动流程，最好移植一个RTOS到STM32中并跑起来；任务调度的原理；任务间通信的几种方式，比如常用的信号量、消息队列，同时实时操作系统中对中断的相应，任务处理的过程，如何保证实时性，软件定时器的学习，包括优先级翻转的问题等；</li>
<li>2 ARM+Linux我基本上是跟着韦东山老师的视频学习的，讲得很好，比较难，有时需要看2-3遍，最关键的就是自己要动手写代码。</li>
<li>ARM体系与架构，ARM裸机相关知识，与STM32裸机知识会有很多相通之处，中断处理流程，时钟的配置，外设的基本通信等；</li>
<li>Linux驱动开发，包括字符设备、块设备和网络设备，我们应届生可以着重字符设备驱动的学习，块设备需要了解Nand Flash/Nor Flash/EMMC的驱动框架，网络设备也作为了解即可。字符设备包括GPIO、IIC、SPI、LCD等，学习驱动，非常重要的就是理解驱动的框架，驱动主要就是框架+硬件操作，比如：理解字符设备驱动框架、总线设备驱动模型；</li>
<li>同时需要学习Linux文件系统与设备驱动的关系，用户态与内核态的交互，比如：file、inode结构体的理解等；</li>
<li>掌握Uboot启动流程、Linux内核的启动流程，最好能有移植U-boot、内核，构建根文件系统的经历，从而更好的理解嵌入式系统的组成；</li>
<li>掌握常用Linux命令，网络编程，自己能写简单的TCP、UDP服务端和客户端代码；</li>
</ol>
<p>3.3 项目加持前边的学习可以和项目同时结合，项目中学习也是非常好的，单片机项目有很多，常见的运用就是，将各种传感器结合起来，进行数据处理，可以加上目前比较火的物联网协议，比如MQTT/NB-IoT等；ARM-Linux项目，我一边是导师项目有需求，需要写驱动，另外需要写上位机分析数据、处理数据等，一方面跟着韦东山老师的视频，视频中也会有很多项目，包括：电子量产工具、数码相框、摄像头视频监控、电源管理等项目，其中用到的编程思想和基本的操作方法不会过时，而且还会是学习的提升（特此说明，仅仅是个人的学习路线，仅供参考，更没有打广告的意思哈）。朱友鹏老师的海思项目据说也不错，但是对于我来说太贵了，就没学，如果想学习音视频方向的，可以试试。但是我发现面试过程中，面试官非常看重基础，以及对知识的灵活运用能力，项目的多与少影响不大，或者说是加分项吧。</p>
<p>3.4 推荐书籍比较基础的入门的书籍网上有很多资源，自己可以在网上找，以下推荐书籍中，仅仅是我个人觉得比较好的，曾经看过一些的，很多书都是需要看的时候翻看一下，更多的是看网上资料和官方文档。<br>学习推荐书籍：</p>
<ol>
<li>《C和指针》，指针是C语言的灵魂，这本书指针部分讲的还可以，更深层的知识可以网上找技术博客看；</li>
<li>《王道程序员求职宝典》，这里边会有很多笔试或者面试中语言本身的基础但又很容易出错的知识点，非常推荐，平时项目中有些就会碰到，看这本书的时候就会更加理解；</li>
<li>《剑指Offer》，笔试刷题用到，与LeetCode结合刷题；</li>
<li>《大话数据结构》，数据结构入门推荐，C语言版本，更好理解但不利于编程，需要造轮子；</li>
<li>《程序是怎样跑起来的》、《计算机是怎样跑起来的》、《网络是怎样连接的》，全面而整体理解程序、计算机、网络的基本组成，运行机理；</li>
<li>《Unix网络编程》、《Unix环境高级编程》，适合当参考书，需要学习的时候翻看一下；</li>
<li>《ARM体系结构与编程》-杜春雷，其中的ARM中断和异常部分我是看的最多的，还有寄存器部分；</li>
<li>《Linux内核完全注释》-赵炯，麻雀虽小五脏俱全；</li>
<li>《Linux设备驱动开发详解：基于Linux4.0内核》，驱动参考书籍；</li>
<li>《C/C++代码调试的艺术》，常见代码调试方法，面试中目前很多都问了，内存泄漏、内存溢出相关问题；</li>
<li>《程序员的自我修养》，特别是内存管理和预处理、编译、链接的过程，面试经常问；</li>
<li>【正点原子】I.MX6U嵌入式Linux驱动开发指南V1.6.pdf；</li>
<li>野火PDF《STM32 HAL库开发实战指南》、《FreeRTOS内核实现与应用开发实战指南》；</li>
<li>韦东山老师官方文档《嵌入式Linux应用开发完全手册V4.0_韦东山全系列视频文档-IMX6ULL开发板》<br>其他书籍可能也会有一些，欢迎补充。。。</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/05/15/STM32F1%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/05/15/STM32F1%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">Untitled</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-05-15 11:02:32 / Modified: 11:05:56" itemprop="dateCreated datePublished" datetime="2023-05-15T11:02:32+08:00">2023-05-15</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="STM32学习笔记"><a href="#STM32学习笔记" class="headerlink" title="STM32学习笔记"></a>STM32学习笔记</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>stm32是一个很有用的微控制器，在各种本科竞赛或者项目中可以说是最主流的一种设备了，但是现在网上32相关的课程很多，同学们可能都不知道如何学习，所幸江科大的某位大佬自制了51和32的教程，算得上是B站最浅显易懂的教程了，本人笔记是根据另一位同学的开源笔记改编（这个同学也是看的江科大视频自制，其视频<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1GY41127w9/?spm_id_from=333.337.search-card.all.click&vd_source=eea47a16439992e41b232bc5d5684e27">链接</a>），同时融合了一些其他的，作为开源分享给大家</p>
<p>本人笔记的GitHub仓库如下</p>
<p><a target="_blank" rel="noopener" href="https://github.com/Michael-Jetson/STM32_Note">https://github.com/Michael-Jetson/STM32_Note</a></p>
<h2 id="STM32是什么"><a href="#STM32是什么" class="headerlink" title="STM32是什么"></a>STM32是什么</h2><p>STM32是ST公司基于ARM Cortex-M内核开发的32位微控制器，如果大家不太理解微控制器是什么，可以联想一下电脑芯片——电脑芯片就是一个超高配版的微控制器，具备强大的逻辑处理功能，芯片搭配主板和显卡等设备，组成一个电脑，可以完成一系列复杂任务；实际上stm32就是一款超低配版的电脑，其CPU就是32芯片，各种外设就相当于电脑的显卡、内存等。</p>
<p>ARM既指ARM公司，也指ARM处理器内核ARM公司是全球领先的半导体知识产权（IP）提供商，全世界超过95%的智能手机和平板电脑都采用ARM架构ARM公司设计ARM内核，半导体厂商完善内核周边电路并生产芯片，类比一下就是ARM是建筑图纸设计方，半导体厂商是建筑承包施工方，共同完成产品开发</p>
<p><img src="https://github.com/Michael-Jetson/STM32_Note/blob/main/img/image-20230410105904654.png?raw=true" alt="image-20230410105904654"></p>
<p>一块32开发板，类比成大家熟知的台式电脑，那么实际上内核就是CPU，存储器就是内存和硬盘，外设就是显示器、键盘等</p>
<h3 id="32的系统架构"><a href="#32的系统架构" class="headerlink" title="32的系统架构"></a>32的系统架构</h3><h2 id="新建工程方式总结"><a href="#新建工程方式总结" class="headerlink" title="新建工程方式总结"></a>新建工程方式总结</h2><p>我们在使用32单片机的时候需要对其进行编程，过程比大家学过的C/C++编程方法复杂一些</p>
<h2 id="GPIO"><a href="#GPIO" class="headerlink" title="GPIO"></a>GPIO</h2><ul>
<li>GPIO（General Purpose Input Output）是通用输入输出口，也就是我们俗称的IO口，类似于电脑上的USB口，可以双向传输数据</li>
<li>可配置为8种输入输出模式</li>
<li>引脚电平：0V~3.3V，部分引脚可容忍5V，具体看引脚型号</li>
<li>输出模式下可控制端口输出高低电平，用以驱动LED、控制蜂鸣器、模拟通信协议输出时序等，也就是32输出信号，控制其他元件</li>
<li>输入模式下可读取端口的高低电平或电压，用于读取按键输入、外接模块电平信号输入、ADC电压采集、模拟通信协议接收数据等，也就是32读取其他元件的数据</li>
</ul>
<h3 id="GPIO的基本结构"><a href="#GPIO的基本结构" class="headerlink" title="GPIO的基本结构"></a>GPIO的基本结构</h3><p> <img src="https://gitee.com/pu-heliang/photos/raw/master/img/202301240113129.png" alt="image-20230124011346061"></p>
<p>其中左边紫色的箭头是APB2总线，上面挂载了很多GPIO外设模块</p>
<p>GPIO外设的命名是GPIO+A/B/C这种，然后一个GPIO外设有16个引脚，从0至15编号</p>
<p>在每个GPIO模块内，包含了一个寄存器和一个驱动器，内核通过APB2总线对寄存器进行读写操作，然后寄存器可以刷新和保存这个数据（读取模式时，寄存器可以不断读取引脚信号并且保存；输出模式时，寄存器可以保存上一次内核输入的数据进行输出，直至下一次内核的数据输入），这样就可以完成输出/读取电平的功能了</p>
<p><strong>PS</strong>：如果不熟悉寄存器原理的同学，可以在数字电子技术课程上进行学习相关知识</p>
<p>这里寄存器的每一位对应一个引脚，实际上因为32单片机是32位的，所以内部寄存器也是32位的，但是一个GPIO模块只有16个引脚，所以寄存器只有低16位有对应端口，高16位并没有用到</p>
<p>此外GPIO里面还有一个驱动器，顾名思义，驱动器就是用来增加电信号的驱动能力了，实际上寄存器就是用来存储数据的，如果想完成具体的输出，需要驱动器增大驱动能力</p>
<h4 id="GPIO框图"><a href="#GPIO框图" class="headerlink" title="GPIO框图"></a>GPIO框图</h4><p><img src="https://gitee.com/pu-heliang/photos/raw/master/img/202301240114039.png" alt="image-20230124011458002"></p>
<p>这是GPIO的结构图</p>
<p>可以分为两个部分，一个是输入驱动器部分（包含相关电路），可以实现读取功能；一个是输出驱动器部分，可以实现信号的输出</p>
<h4 id="GPIO原理"><a href="#GPIO原理" class="headerlink" title="GPIO原理"></a>GPIO原理</h4><p>我们接下来进行解析工作原理</p>
<p>一、IO引脚</p>
<ul>
<li><p>首先是最右边的IO引脚，接了两个保护二极管，可以对输入信号的电压进行限幅，让输入电压不至于太高也不至于太低</p>
</li>
<li><p>如果出现电压过高，那么上方的二极管就会导通，电流就会流过VDD，而不会通过内部电路，电压过低也会出现类似情况，不会从内部电路汲取电流</p>
</li>
</ul>
<p>二、输入驱动器</p>
<ul>
<li><p>首先，输入驱动器右边是上下拉电阻，这个是可以通过程序进行设置的；如果上面导通、下面断开，就是上拉输入模型，如果下面断开、下面导通就是下拉输入模式，如果都断开就是浮空输入模式，注意不可以同时导通</p>
</li>
<li><p>上拉/下拉模式，其实就是配置一个默认输入电平，因为对于数字端口，输入必须是高电平或者低电平，如果引脚什么也不接，则无法判断是什么电平，如果这样，输入就会出现一种浮空状态，引脚的输入电平容易受外界干扰而改变，类似于一个太空中的物体，一点外力就可以很轻松改变其运动状态，所以为了避免引脚悬空导致的输入数据不确定，就要加上上拉下拉电阻<img src="https://gitee.com/pu-heliang/photos/raw/master/img/202301240119393.png" alt="image-20230124011954329"></p>
</li>
<li><p>如果是上拉模式，上图中连接VSS的开关断开，连接VDD的闭合，接入上拉电阻，二极管反向连接，电阻相当于无穷大，当外部没有输入时。引脚默认为高电平</p>
</li>
<li><p>施密特触发器（图中的TTL肖特基触发器，视频中说这是一个翻译错误）的作用是对输入电压进行整形，其执行逻辑如下</p>
<ul>
<li><p>如果输入电压大于某一个阈值，输出就会瞬间改为高电平</p>
</li>
<li><p>如果输入电压小于某一个阈值，输出就会瞬间改为低电平</p>
</li>
<li><p>实际上，外界引脚输入虽然是数字信号，但是实际上也是会出现一些干扰的，加上这个施密特触发器，会保障读取信号的过程中不会受干扰，如可以避免输入信号抖动导致的数字信号改变</p>
<p><strong>PS</strong>：这个部分的原理也在数字电子技术课程中</p>
</li>
</ul>
</li>
</ul>
<p>三、输入部分（指的是外界输入）</p>
<ul>
<li>输入驱动器里面引出三路信号，分别用作：模拟输入，复用功能输入、输入数据寄存器</li>
<li>模拟输入：这路信号引出点是施密特触发器前面，因为施密特触发器会对模拟输入进行整形，从而输出数字信号，如果我们想获取原始的模拟输入信号就必须使用这个功能</li>
<li>复用功能输入：这个是链接到其他需要读取端口的外设上的，比如说串口的输入引脚等，这根线是接受数字量的，所以在施密特触发器后面</li>
</ul>
<p>四、输出部分（指的是内部输出）</p>
<ul>
<li>输出驱动器有两路信号来源，一路其中复用功能输出是来自于其他外设的，一路是来自于输出数据寄存器的，两种控制方式由数据选择器进行控制，选择一路到输出控制部分</li>
<li>如果选择输出数据寄存器进行控制，就是普通的IO口输出，对输出数据寄存器进行写入就可以对对应端口进行操作，但是注意，输出数据寄存器只能整体写入，如果想对单独操作输出数据寄存器某一位而不影响其他位，就需要借助位设置/清除寄存器，可以实现单独操作输出数据寄存器的某一位</li>
<li>如果直接使用读/写操作对输出数据寄存器进行操作，那么会相当麻烦，如果想单独控制其中某一个端口而不影响其他端口，必须这样操作<ol>
<li>首先，读取寄存器，使用按位与或者按位或的方式单独改变其中某一位</li>
<li>然后将修改后的数据发送给寄存器</li>
</ol>
</li>
<li>或者使用位设置/清楚寄存器，使用方法如下<ol>
<li>如果要对某一位进行置1（输出高电平），则在位设置寄存器对应位写1，其他位置0即可（保持不变），这样内部电路就会自动将输出数据寄存器对应位置1而不改变其他位，一步到位</li>
<li>如果想对某一位清除（输出低电平），则对位清楚寄存器操作即可</li>
</ol>
</li>
</ul>
<p>五、输出驱动器</p>
<ul>
<li><p>我们使用信号来控制开关的导通和关闭，开关负责将IO口接到VDD或者VSS，这样IO口就可以输出高低电平</p>
</li>
<li><p>有三种输出方式：推挽输出，开漏输出，关闭</p>
<ol>
<li><p>推挽输出<img src="https://github.com/Michael-Jetson/STM32_Note/blob/main/img/image-20230410143846371.png?raw=true" alt="image-20230410143846371"></p>
<p>这种模式下，P-MOS和N-MOS均有效</p>
<p>输出1时，上管导通，下管断开，输出直接接到VDD，输出高电平</p>
<p>输出0时，上管断开，下管断开，输出直接接到VSS，输出低电平</p>
<p>这种模式下，高低电平均匀有较强的驱动能力（输出时，IO口直接链接内部电路的电源），所以推挽模式也叫强推输出模式，这种模式下，STM32对IO口有绝对控制权，决定IO口的输出</p>
</li>
<li><p>开漏输出模式</p>
<p>这种模式下，P-MOS无效，仅有N-MOS工作</p>
<p>数据寄存器为1时，下管断开，输出相当于断开，也就是高阻模式</p>
<p>数据寄存器为0时，下管导通，输出接到VSS，输出低电平</p>
<p>这种模式下，只有低电平有驱动能力，高电平没有驱动能力</p>
<p>这种模式可以作为通信协议的驱动方式，比如说I2C的通信引脚</p>
<p>在多机通信的情况下，这种模式可以避免各个设备之间的相互干扰</p>
<p>另外，开漏模式还可以用来输出5V的电平信号，比如在IO口外接一个上拉电阻到5V电源，当寄存器输出低电平的时候，内部的N-MOS直接接VSS，当输出高电平时，由外部上拉电阻拉高至5V，这样可以输出5V电平信号，兼容5V设备</p>
</li>
<li><p>关闭</p>
<p>当引脚配置为输入模式的时候，两个MOS管都无效，输出关闭，端口电平由外部信号来控制</p>
</li>
</ol>
</li>
</ul>
<h4 id="GPIO工作模式列表"><a href="#GPIO工作模式列表" class="headerlink" title="GPIO工作模式列表"></a>GPIO工作模式列表</h4><table>
<thead>
<tr>
<th align="center">模式名称</th>
<th align="center">性质</th>
<th align="center">特征</th>
</tr>
</thead>
<tbody><tr>
<td align="center">浮空输入</td>
<td align="center">数字输入</td>
<td align="center">可读取引脚电平，若引脚悬空，则电平不确定</td>
</tr>
<tr>
<td align="center">上拉输入</td>
<td align="center">数字输入</td>
<td align="center">可读取引脚电平，内部连接上拉电阻，悬空时默认高电平</td>
</tr>
<tr>
<td align="center">下拉输入</td>
<td align="center">数字输入</td>
<td align="center">可读取引脚电平，内部连接下拉电阻，悬空时默认低电平</td>
</tr>
<tr>
<td align="center">模拟输入</td>
<td align="center">模拟输入</td>
<td align="center">GPIO无效，引脚直接接入内部ADC</td>
</tr>
<tr>
<td align="center">开漏输出</td>
<td align="center">数字输出</td>
<td align="center">可输出引脚电平，高电平为高阻态，低电平接VSS</td>
</tr>
<tr>
<td align="center">推挽输出</td>
<td align="center">数字输出</td>
<td align="center">可输出引脚电平，高电平接VDD，低电平接VSS</td>
</tr>
<tr>
<td align="center">复用开漏输出</td>
<td align="center">数字输出</td>
<td align="center">由片上外设控制，高电平为高阻态，低电平接VSS</td>
</tr>
<tr>
<td align="center">复用推挽输出</td>
<td align="center">数字输出</td>
<td align="center">由片上外设控制，高电平接VDD，低电平接VSS</td>
</tr>
</tbody></table>
<p>注意一下模拟输入，这个可以说是ADC模数转换器的专属配置了，这里输出断开，施密特触发器无效，相当于只剩下一根线，也就是从引脚直接接入片上外设也就是ADC</p>
<h4 id="GPIO使用注意事项"><a href="#GPIO使用注意事项" class="headerlink" title="GPIO使用注意事项"></a>GPIO使用注意事项</h4><p>下面两张图是使用GPIO点亮发光二极管的不同方式，第一张是低电平驱动，第二张是高电平驱动</p>
<p>限流电阻的左右：可以限制电路防止二极管烧毁，同时可以调节亮度</p>
<p><img src="https://github.com/Michael-Jetson/STM32_Note/blob/main/img/image-20230410163815402.png?raw=true" alt="image-20230410163815402"></p>
<p><img src="https://github.com/Michael-Jetson/STM32_Note/blob/main/img/image-20230410163831363.png?raw=true" alt="image-20230410163831363"></p>
<p>两种驱动方式取决于GPIO的驱动能力，但是在单片机里面趋向于第一张接法，因为很多单片机采用了高电平弱驱动，低电平强驱动的规则</p>
<p>但是注意一下，GPIO的驱动能力并不是很强，哪怕是推挽输出模式下，所以对于某些功率较大的元件，必须使用单独的驱动模块（如三极管），下图就是一个使用三极管驱动蜂鸣器的电路</p>
<p><img src="https://github.com/Michael-Jetson/STM32_Note/blob/main/img/image-20230410164414499.png?raw=true" alt="image-20230410164414499"></p>
<h3 id="GPIO配置"><a href="#GPIO配置" class="headerlink" title="GPIO配置"></a>GPIO配置</h3><p>我们清晰了解了GPIO的原理与结构，那么我们应该怎么对其进行配置来让其工作呢？我们首先来完成点亮LED</p>
<h4 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h4><ol>
<li><p>第一步，使用RCC开启GPIO的时钟</p>
<p>我们都知道，在数电里面逻辑电路很多都需要时钟信号的驱动才可以工作，所以我们想让GPIO开始工作就需要给GPIO模块输入时钟信号，也称为时钟使能</p>
</li>
<li><p>第二步，使用GPIO_Init()函数初始化GPIO</p>
</li>
<li><p>第三步，使用输出或者输入的函数控制GPIO口</p>
</li>
</ol>
<h4 id="时钟使能函数"><a href="#时钟使能函数" class="headerlink" title="时钟使能函数"></a>时钟使能函数</h4><p>在原视频中，在项目下的Library文件夹中，有一个stm32f10x_rcc.h文件，顾名思义，这个文件就是stm32f10x系列的rcc头文件，其中我们可以看到有三个函数，其作用就是时钟使能</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RCC_AHBPeriphClockCmd</span><span class="params">(<span class="keyword">uint32_t</span> RCC_AHBPeriph,FunctionalState NewState)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RCC_APB2PeriphClockCmd</span><span class="params">(<span class="keyword">uint32_t</span> RCC_APB2Periph,FunctionalState NewState)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RCC_APB1PeriphClockCmd</span><span class="params">(<span class="keyword">uint32_t</span> RCC_APB1Periph,FunctionalState NewState)</span></span>;</span><br></pre></td></tr></table></figure>

<p>三个函数分别是RCC中AHB、APB1和APB2的外设时钟控制，两个参数的作用是</p>
<p>参数1：选择外设，参数2：使能或者失能</p>
<p>当我们编译项目之后，可以右键查看函数定义和介绍，我们发现，我们想使用一个GPIO外设（假定这里对GPIOA进行使能），那么第一个参数就使用RCC_APB2Periph_GPIOA，第二个参数选择ENABLE或者DISABLE，这些都是预定义好的变量</p>
<h4 id="常用的GPIO函数"><a href="#常用的GPIO函数" class="headerlink" title="常用的GPIO函数"></a>常用的GPIO函数</h4><h5 id="复位GPIO外设函数"><a href="#复位GPIO外设函数" class="headerlink" title="复位GPIO外设函数"></a>复位GPIO外设函数</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GPIO_DeInit</span><span class="params">(GPIO_TypeDef* GPIOx)</span></span>;</span><br></pre></td></tr></table></figure>

<p>调用这个函数之后，所指定的GPIO外设会被复位（也就是初始化或者恢复出厂设置）</p>
<h5 id="复位AFIO外设函数"><a href="#复位AFIO外设函数" class="headerlink" title="复位AFIO外设函数"></a>复位AFIO外设函数</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GPIO_AFIODeInit</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<h5 id="初始化GPIO口函数"><a href="#初始化GPIO口函数" class="headerlink" title="初始化GPIO口函数"></a>初始化GPIO口函数</h5><p>用结构体的参数来初始化GPIO口，先定义一个结构体变量，然后把再给结构体赋值（结构体的值代表配置GPIO端口的方式），最后调用此函数并且传入结构体，函数内部会自动读取结构体的值，然后自动把外设的各个参数配置好</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GPIO_Init</span><span class="params">(GPIO_TypeDef* GPIOx,GPIO_InitTypedef* GPIO_InitStruct)</span></span>;</span><br></pre></td></tr></table></figure>

<h5 id="GPIO初始化结构体"><a href="#GPIO初始化结构体" class="headerlink" title="GPIO初始化结构体"></a>GPIO初始化结构体</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GPIO_InitTypeDef GPIO_InitStructure;</span><br></pre></td></tr></table></figure>

<p>声明一个GPIO初始化结构体对象</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;</span><br></pre></td></tr></table></figure>

<p>设置GPIO的工作模式（这是一些枚举定义，在stm32f10x_gpio.h中定义）</p>
<table>
<thead>
<tr>
<th align="center">变量名</th>
<th align="center">含义</th>
<th align="center">英文解释</th>
</tr>
</thead>
<tbody><tr>
<td align="center">GPIO_Mode_AIN</td>
<td align="center">模拟输入</td>
<td align="center">Analog IN</td>
</tr>
<tr>
<td align="center">GPIO_Mode_IN_FLOATING</td>
<td align="center">浮空输入</td>
<td align="center">In Floating</td>
</tr>
<tr>
<td align="center">GPIO_Mode_IPD</td>
<td align="center">下拉输入</td>
<td align="center">In Pull Down</td>
</tr>
<tr>
<td align="center">GPIO_Mode_IPU</td>
<td align="center">上拉输入</td>
<td align="center">In Pull Up</td>
</tr>
<tr>
<td align="center">GPIO_Mode_Out_OD</td>
<td align="center">开漏输出</td>
<td align="center">Out Open Drain</td>
</tr>
<tr>
<td align="center">GPIO_Mode_Out_PP</td>
<td align="center">推挽输出</td>
<td align="center">Out Push Pull</td>
</tr>
<tr>
<td align="center">GPIO_Mode_AF_OD</td>
<td align="center">复用开漏</td>
<td align="center">Atl Open Drain</td>
</tr>
<tr>
<td align="center">GPIO_Mode_AF_PP</td>
<td align="center">复用推挽</td>
<td align="center">Atl Push Pull</td>
</tr>
</tbody></table>
<p>点灯使用推挽输出</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GPIO_InitStructure.GPIO_Pin = GPIO_Pin_All;</span><br></pre></td></tr></table></figure>

<p>同样我们可以在stm32f10x_gpio.h文件中找到引脚定义</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIO_Pin_0                 ((uint16_t)0x0001)  <span class="comment">/*!&lt; Pin 0 selected */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIO_Pin_1                 ((uint16_t)0x0002)  <span class="comment">/*!&lt; Pin 1 selected */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIO_Pin_2                 ((uint16_t)0x0004)  <span class="comment">/*!&lt; Pin 2 selected */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIO_Pin_3                 ((uint16_t)0x0008)  <span class="comment">/*!&lt; Pin 3 selected */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIO_Pin_4                 ((uint16_t)0x0010)  <span class="comment">/*!&lt; Pin 4 selected */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIO_Pin_5                 ((uint16_t)0x0020)  <span class="comment">/*!&lt; Pin 5 selected */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIO_Pin_6                 ((uint16_t)0x0040)  <span class="comment">/*!&lt; Pin 6 selected */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIO_Pin_7                 ((uint16_t)0x0080)  <span class="comment">/*!&lt; Pin 7 selected */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIO_Pin_8                 ((uint16_t)0x0100)  <span class="comment">/*!&lt; Pin 8 selected */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIO_Pin_9                 ((uint16_t)0x0200)  <span class="comment">/*!&lt; Pin 9 selected */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIO_Pin_10                ((uint16_t)0x0400)  <span class="comment">/*!&lt; Pin 10 selected */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIO_Pin_11                ((uint16_t)0x0800)  <span class="comment">/*!&lt; Pin 11 selected */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIO_Pin_12                ((uint16_t)0x1000)  <span class="comment">/*!&lt; Pin 12 selected */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIO_Pin_13                ((uint16_t)0x2000)  <span class="comment">/*!&lt; Pin 13 selected */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIO_Pin_14                ((uint16_t)0x4000)  <span class="comment">/*!&lt; Pin 14 selected */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIO_Pin_15                ((uint16_t)0x8000)  <span class="comment">/*!&lt; Pin 15 selected */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIO_Pin_All               ((uint16_t)0xFFFF)  <span class="comment">/*!&lt; All pins selected */</span></span></span><br></pre></td></tr></table></figure>

<p>实际上，这些引脚定义就是设置了高电平的位置来进行引脚的初始化，学过数电的都知道，数字电路中表示数值的方式就是二进制的多位电平，但是在这里，变量使用的是16进制的数值，所以0x0001（也就是GPIO_Pin_0）等于二进制的0000 0000 0000 0001，0x0002（也就是GPIO_Pin_1）等于二进制的0000 0000 0000 0010</p>
<p>在原码表示下，二进制的十六位数就可以表示16个属性的状态，在这里正好对应一个GPIO外设的16个引脚，所以实际上的就是设置对应位置的电平，第$i$位电平是高电平，那么等于设置$i-1$号引脚完成初始化，比如说我们可以使用二进制数字0000 0000 0000 0001来完成0号引脚的初始化</p>
<p>如果想设置多个引脚，那么就可以一次将多个电平置为高电平，这里可以采用C语言中的与或非操作，即使用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GPIO_pin=GPIO_Pin_0 | GPIO_Pin_1</span><br></pre></td></tr></table></figure>

<p>这样，就在底层进行按位或操作，得到的变量的值是0000 0000 0000 0011（二进制）和0x0003（十六进制），这样可以完成多个引脚的初始化</p>
<p>不过注意一下，一个结构体对象想一次性设置一个GPIO外设的多个引脚，那么这些引脚的工作模式和执行速度是一样的，如果想差异化设置则需要使用不同结构体对象</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line"><span class="built_in">GPIO_Init</span>(GPIOA, &amp;GPIO_InitStructure);</span><br></pre></td></tr></table></figure>

<p>GPIO_Init函数的作用是读取结构体参数，进行一系列逻辑判断运算，最后写入GPIO配置寄存器</p>
<p>至此，GPIO的配置就完成了，接下来就可以对其进行操作了</p>
<h5 id="给GPIO结构体变量赋一个默认值函数"><a href="#给GPIO结构体变量赋一个默认值函数" class="headerlink" title="给GPIO结构体变量赋一个默认值函数"></a>给GPIO结构体变量赋一个默认值函数</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GPIO_StructInit</span><span class="params">(GPIO_InitTypedef* GPIO_InitTypedef)</span></span>;</span><br></pre></td></tr></table></figure>

<h5 id="GPIO的输出函数"><a href="#GPIO的输出函数" class="headerlink" title="GPIO的输出函数"></a>GPIO的输出函数</h5><h5 id="把指定的端口设置为高电平"><a href="#把指定的端口设置为高电平" class="headerlink" title="把指定的端口设置为高电平"></a>把指定的端口设置为高电平</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GPIO_SetBits</span><span class="params">(GPIO_InitTypedef* GPIOx,<span class="keyword">uint16_t</span> GPIO_Pin)</span></span>;</span><br><span class="line">GPIO_SetBits(GPIOA,GPIO_Pin_0);</span><br></pre></td></tr></table></figure>

<p>这里将GPIOA的0号引脚设为高电平</p>
<h5 id="把指定的端口设置为低电平"><a href="#把指定的端口设置为低电平" class="headerlink" title="把指定的端口设置为低电平"></a>把指定的端口设置为低电平</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GPIO_ResetBits</span><span class="params">(GPIO_InitTypedef* GPIOx,<span class="keyword">uint16_t</span> GPIO_Pin)</span></span>;</span><br></pre></td></tr></table></figure>

<p>与GPIO_SetBits函数相同的用法</p>
<h5 id="对根据第三个参数的值来设置电平"><a href="#对根据第三个参数的值来设置电平" class="headerlink" title="对根据第三个参数的值来设置电平"></a>对根据第三个参数的值来设置电平</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GPIO_WriteBit</span><span class="params">(GPIO_InitTypedef* GPIOx,<span class="keyword">uint16_t</span> GPIO_Pin,BitAction BitVal)</span></span>;</span><br><span class="line"><span class="comment">//用法示例</span></span><br><span class="line">GPIO_WriteBit(GPIOA,GPIO_Pin_0,Bit_SET);</span><br><span class="line">GPIO_WriteBit(GPIOA,GPIO_Pin_0,Bit_RESET);</span><br></pre></td></tr></table></figure>

<p>对GPIO的0号引脚分别置高电平和低电平</p>
<p>这里注意一下，使用这种直接输入数字0/1的方式会导致编译警告</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">GPIO_WriteBit</span>(GPIOA,GPIO_Pin_0,<span class="number">1</span>);</span><br><span class="line"><span class="built_in">GPIO_WriteBit</span>(GPIOA,GPIO_Pin_0,<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>警告原因是枚举类型中混入其他类型变量，所以我们需要使用一个强制类型转换</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">GPIO_WriteBit</span>(GPIOA,GPIO_Pin_0,(BitAction)<span class="number">1</span>);</span><br><span class="line"><span class="built_in">GPIO_WriteBit</span>(GPIOA,GPIO_Pin_0,(BitAction)<span class="number">0</span>);</span><br></pre></td></tr></table></figure>


<h5 id="对GPIOx-16个端口同时进行写入操作："><a href="#对GPIOx-16个端口同时进行写入操作：" class="headerlink" title="对GPIOx 16个端口同时进行写入操作："></a>对GPIOx 16个端口同时进行写入操作：</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GPIO_Write</span><span class="params">(GPIO_InitTypedef* GPIOx,<span class="keyword">uint16_t</span> PortVal)</span></span>;</span><br></pre></td></tr></table></figure>

<p>在推挽输出模式下，高低电平都具有驱动能力，开漏输出模式的高电平是没有驱动能力的，开漏输出模式的低电平具有驱动能力</p>
<p>#define的新名字在左边，并且可以给任何变量换名字，而typedef只能给变量换名字，新名字在右边</p>
<h5 id="GPIO的输入函数"><a href="#GPIO的输入函数" class="headerlink" title="GPIO的输入函数"></a>GPIO的输入函数</h5><h5 id="读取输入数据寄存器某个端口的输入值，返回值是高低电平函数"><a href="#读取输入数据寄存器某个端口的输入值，返回值是高低电平函数" class="headerlink" title="读取输入数据寄存器某个端口的输入值，返回值是高低电平函数"></a>读取输入数据寄存器某个端口的输入值，返回值是高低电平函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">uint8_t</span> <span class="title">GPIO_ReadInputDataBit</span><span class="params">(GPIO_InitTypedef* GPIOx,<span class="keyword">uint16_t</span> GPIO_Pin)</span></span>;</span><br></pre></td></tr></table></figure>

<h5 id="读取GPIO的每一位的值，返回值是16位的数据-每一位代表一个端口值"><a href="#读取GPIO的每一位的值，返回值是16位的数据-每一位代表一个端口值" class="headerlink" title="读取GPIO的每一位的值，返回值是16位的数据,每一位代表一个端口值"></a>读取GPIO的每一位的值，返回值是16位的数据,每一位代表一个端口值</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">uint16_t</span> <span class="title">GPIO_ReadInputData</span><span class="params">(GPIO_InitTypedef* GPIOx)</span></span>;</span><br></pre></td></tr></table></figure>

<h5 id="读取输出数据寄存器的某一位"><a href="#读取输出数据寄存器的某一位" class="headerlink" title="读取输出数据寄存器的某一位"></a>读取输出数据寄存器的某一位</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">uint8_t</span> <span class="title">GPIO_ReadOutputDataBit</span><span class="params">(GPIO_InitTypedef* GPIOx,<span class="keyword">uint16_t</span> GPIO_Pin)</span></span>;</span><br></pre></td></tr></table></figure>

<h5 id="读取整个输出寄存器"><a href="#读取整个输出寄存器" class="headerlink" title="读取整个输出寄存器"></a>读取整个输出寄存器</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">uint16_t</span> <span class="title">GPIO_ReadOutputData</span><span class="params">(GPIO_InitTypedef* GPIOx)</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="程序示例"><a href="#程序示例" class="headerlink" title="程序示例"></a>程序示例</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LED_Init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);<span class="comment">//开启GPIO时钟，这里是开启一个GPIO外设的时钟</span></span><br><span class="line">	</span><br><span class="line">	GPIO_InitTypeDef GPIO_InitStructure;<span class="comment">//定义GPIO结构体</span></span><br><span class="line">	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;<span class="comment">//推挽输出</span></span><br><span class="line">	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_1 | GPIO_Pin_2;<span class="comment">//打开的引脚</span></span><br><span class="line">	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;<span class="comment">//配置响应速度</span></span><br><span class="line">	GPIO_Init(GPIOA, &amp;GPIO_InitStructure);<span class="comment">//写入参数</span></span><br><span class="line">	</span><br><span class="line">	GPIO_SetBits(GPIOA, GPIO_Pin_1 | GPIO_Pin_2);<span class="comment">//置高电平</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LED1_ON</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	GPIO_ResetBits(GPIOA, GPIO_Pin_1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LED1_OFF</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	GPIO_SetBits(GPIOA, GPIO_Pin_1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LED1_Turn</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (GPIO_ReadOutputDataBit(GPIOA, GPIO_Pin_1) == <span class="number">0</span>)<span class="comment">//读取输出引脚的电平</span></span><br><span class="line">	&#123;</span><br><span class="line">		GPIO_SetBits(GPIOA, GPIO_Pin_1);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		GPIO_ResetBits(GPIOA, GPIO_Pin_1);<span class="comment">//设置低电平</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LED2_ON</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	GPIO_ResetBits(GPIOA, GPIO_Pin_2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LED2_OFF</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	GPIO_SetBits(GPIOA, GPIO_Pin_2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LED2_Turn</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (GPIO_ReadOutputDataBit(GPIOA, GPIO_Pin_2) == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		GPIO_SetBits(GPIOA, GPIO_Pin_2);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		GPIO_ResetBits(GPIOA, GPIO_Pin_2);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="外部中断"><a href="#外部中断" class="headerlink" title="外部中断"></a>外部中断</h2><ul>
<li><p>中断：在主程序运行过程中，出现了特定的中断触发条件（中断源），使得CPU暂停当前正在运行的程序，转而去处理中断程序，处理完成后又返回原来被暂停的位置继续运行</p>
</li>
<li><p>中断优先级：当有多个中断源同时申请中断时，CPU会根据中断源的轻重缓急进行裁决，优先响应更加紧急的中断源</p>
</li>
<li><p>中断嵌套：当一个中断程序正在运行时，又有新的更高优先级的中断源申请中断，CPU再次暂停当前的中断程序，转而去处理新的中断程序，处理完后依次进行返回</p>
</li>
<li><p>NVIC：NVIC的中断优先级由优先级寄存器的4位（0~15）决定，这4位可以进行切分，分为高n位的抢占优先级和低4-n位的响应优先级</p>
</li>
<li><p>抢占优先级高的可以进行中断嵌套，响应优先级高的可以进行优先排队，抢占优先级和响应优先级均相同的按中断号排队</p>
</li>
<li><p>EXTI：（Extern Interrupt）外部中断</p>
</li>
<li><p>EXTI可以检测指定GPIO口的电平信号，当其指定的GPIO口产生电平变化时，EXTI将立即向NVIC发出中断申请，经过NVIC裁决后即可中断CPU主程序，使CPU执行EXTI对应的中断程序</p>
</li>
<li><p>支持的触发方式：上升沿/下降沿/双边沿/软件触发</p>
</li>
<li><p>支持的GPIO口：所有GPIO口，但相同的Pin不能同时触发中断</p>
</li>
<li><p>通道数：16个GPIO_Pin，外加PVD输出、RTC闹钟、USB唤醒、以太网唤醒</p>
</li>
<li><p>触发响应方式：中断响应/事件响应</p>
</li>
</ul>
<p><img src="https://gitee.com/pu-heliang/photos/raw/master/img/202301032043708.png" alt="image-20221224115729670"></p>
<p>AFIO选择中断引脚，外部中断的9-5,15-10会触发同一个中断函数，再根据标志位来区分到底是哪个中断进来的</p>
<p>配置数据选择器，只有一个Pin接到EXTI</p>
<p><img src="https://gitee.com/pu-heliang/photos/raw/master/img/202301032039837.png" alt="image-20230103203938222"></p>
<p>在STM32中AFIO主要完成两个任务：复用功能引脚重映射、中断引脚选择</p>
<p>或、与、非门</p>
<p><img src="https://gitee.com/pu-heliang/photos/raw/master/img/202301032044678.png" alt="image-20221224120857813"></p>
<h4 id="EXTI配置步骤"><a href="#EXTI配置步骤" class="headerlink" title="EXTI配置步骤"></a>EXTI配置步骤</h4><ol>
<li>第一步，配置RCC，把设计到的外设时钟都打开</li>
<li>第二步，配置GPIO，选择端口为输入模式</li>
<li>第三步，配置AFIO，选择使用的一路GPIO，连接到后面的EXTI</li>
<li>第四步，配置EXTI，选择边沿触发方式，选择触发响应方式</li>
<li>第五步，配置NVIC，给中断选择一个合适的优先级</li>
</ol>
<p>EXTI和NVIC时钟默认是打开的，NVIC是内核的外设，内核的外设都不需要开启时钟，RCC管的都是内核外的外设</p>
<h5 id="复位AFIO外设"><a href="#复位AFIO外设" class="headerlink" title="复位AFIO外设"></a>复位AFIO外设</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GPIO_AFIODeInit</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<h5 id="锁定GPIO配置函数"><a href="#锁定GPIO配置函数" class="headerlink" title="锁定GPIO配置函数"></a>锁定GPIO配置函数</h5><h5 id="锁定引脚的配置，防止意外更改"><a href="#锁定引脚的配置，防止意外更改" class="headerlink" title="锁定引脚的配置，防止意外更改"></a>锁定引脚的配置，防止意外更改</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GPIO_PinLockConfig</span><span class="params">(GPIO_TypeDef* GPIOx,<span class="keyword">uint16_t</span> GPIO_Pin)</span></span>;</span><br></pre></td></tr></table></figure>

<h5 id="配置AFIO的事件输出功能函数"><a href="#配置AFIO的事件输出功能函数" class="headerlink" title="配置AFIO的事件输出功能函数"></a>配置AFIO的事件输出功能函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GPIO_EventOutputConfig</span><span class="params">(<span class="keyword">uint8_t</span> GPIO_PortSource,<span class="keyword">uint8_t</span> GPIO_PinSource)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GPIO_EventOutputCmd</span><span class="params">(FunctionalState NewState)</span></span>;</span><br></pre></td></tr></table></figure>

<h5 id="配置引脚重映射函数"><a href="#配置引脚重映射函数" class="headerlink" title="配置引脚重映射函数"></a>配置引脚重映射函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GPIO_PinRemapConfig</span><span class="params">(<span class="keyword">uint32_t</span> GPIO_Remap,FunctionalState NewState)</span></span>;</span><br></pre></td></tr></table></figure>

<h5 id="配置AFIO的数据选择器"><a href="#配置AFIO的数据选择器" class="headerlink" title="配置AFIO的数据选择器"></a>配置AFIO的数据选择器</h5><p>选择想使用的中断引脚函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GPIO_EXTILineConfig</span><span class="params">(<span class="keyword">uint8_t</span> GPIO_PortSource,<span class="keyword">uint8_t</span> GPIO_PinSource)</span></span>;</span><br></pre></td></tr></table></figure>

<h5 id="恢复上电默认的状态函数"><a href="#恢复上电默认的状态函数" class="headerlink" title="恢复上电默认的状态函数"></a>恢复上电默认的状态函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EXTI_DeInit</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<h5 id="根据结构体配置EXTI外设函数"><a href="#根据结构体配置EXTI外设函数" class="headerlink" title="根据结构体配置EXTI外设函数"></a>根据结构体配置EXTI外设函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EXTI_Init</span><span class="params">(EXTI_InitTypedef* EXTI_InitStruct)</span></span>;</span><br></pre></td></tr></table></figure>

<h5 id="给传入的结构体参数赋一个默认值函数"><a href="#给传入的结构体参数赋一个默认值函数" class="headerlink" title="给传入的结构体参数赋一个默认值函数"></a>给传入的结构体参数赋一个默认值函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EXTI_StructInit</span><span class="params">(EXTI_InitTypedef* EXTI_InitStruct)</span></span>;</span><br></pre></td></tr></table></figure>

<h5 id="软件触发外部中断函数"><a href="#软件触发外部中断函数" class="headerlink" title="软件触发外部中断函数"></a>软件触发外部中断函数</h5><p>参数给一个中断线，就能软件触发一次这个外部中断函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EXTI_GenerateSWInterrupt</span><span class="params">(<span class="keyword">uint32_t</span> EXTI_Line)</span></span>;</span><br></pre></td></tr></table></figure>

<p>在外设运行的时候会产生一些状态标志位，例如：外部中断来了，挂起寄存器会置一个标志位，标志位放在状态寄存器，</p>
<p>当程序想看这些标志位</p>
<h5 id="获取指定的标志位函数"><a href="#获取指定的标志位函数" class="headerlink" title="获取指定的标志位函数"></a>获取指定的标志位函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">FlagStatus <span class="title">EXTI_GetFlagStatus</span><span class="params">(<span class="keyword">uint32_t</span> EXTI_Line)</span></span>;</span><br></pre></td></tr></table></figure>

<h5 id="对置1的标志位进行清除函数"><a href="#对置1的标志位进行清除函数" class="headerlink" title="对置1的标志位进行清除函数"></a>对置1的标志位进行清除函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EXTI_ClearFlag</span><span class="params">(<span class="keyword">uint32_t</span> EXTI_Line)</span></span>;</span><br></pre></td></tr></table></figure>

<h5 id="在中断函数中获取标志位函数"><a href="#在中断函数中获取标志位函数" class="headerlink" title="在中断函数中获取标志位函数"></a>在中断函数中获取标志位函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ITStatus <span class="title">EXTI_GetITStatus</span><span class="params">(<span class="keyword">uint32_t</span> EXTI_Line)</span></span>;</span><br></pre></td></tr></table></figure>

<h5 id="清除中断挂起标志位函数"><a href="#清除中断挂起标志位函数" class="headerlink" title="清除中断挂起标志位函数"></a>清除中断挂起标志位函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EXTI_ClearITPendingBit</span><span class="params">(<span class="keyword">uint32_t</span> EXTI_Line)</span></span>;</span><br></pre></td></tr></table></figure>

<h5 id="中断分组函数"><a href="#中断分组函数" class="headerlink" title="中断分组函数"></a>中断分组函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NVIC_PriorityGroupConfig</span><span class="params">(<span class="keyword">uint32_t</span> NVIC_PriorityGroup)</span></span>;</span><br></pre></td></tr></table></figure>

<h5 id="根据结构体里面的参数初始化NVIC函数"><a href="#根据结构体里面的参数初始化NVIC函数" class="headerlink" title="根据结构体里面的参数初始化NVIC函数"></a>根据结构体里面的参数初始化NVIC函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NVIC_Init</span><span class="params">(NVIC_InitTypedef* NVIC_InitStruct)</span></span>;</span><br></pre></td></tr></table></figure>

<h5 id="设置中断向量表函数"><a href="#设置中断向量表函数" class="headerlink" title="设置中断向量表函数"></a>设置中断向量表函数</h5><p>NVIC_SetVectorTable函数的功能是设置向量表的位置和偏移。其中输入参数中，对于32位的OFFSET向量表基地址的偏移量对于FLASH，参数值必须高于0x08000100，对于RAM必须高于0X100.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NVIC_SetVectorTable</span><span class="params">(<span class="keyword">uint8_t</span> NVIC_VectTab,<span class="keyword">uint32_t</span> Offset)</span></span>;</span><br></pre></td></tr></table></figure>

<h5 id="系统低功耗配置函数"><a href="#系统低功耗配置函数" class="headerlink" title="系统低功耗配置函数"></a>系统低功耗配置函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NVIC_SystemLPConfig</span><span class="params">(<span class="keyword">uint8_t</span> LowPowerMode,FunctionalState NewState)</span></span></span><br></pre></td></tr></table></figure>

<p>中断函数要简短快速，不要在中断中执行Delay</p>
<h4 id="程序示例-1"><a href="#程序示例-1" class="headerlink" title="程序示例"></a>程序示例</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int16_t</span> Encoder_Count;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Encoder_Init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);<span class="comment">//开启GPIO时钟</span></span><br><span class="line">	RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE);<span class="comment">//开启AFIO时钟</span></span><br><span class="line">	</span><br><span class="line">	GPIO_InitTypeDef GPIO_InitStructure;<span class="comment">//定义初始化结构体</span></span><br><span class="line">	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;<span class="comment">//上拉输入</span></span><br><span class="line">	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0 | GPIO_Pin_1;<span class="comment">//开启引脚</span></span><br><span class="line">	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;<span class="comment">//设置响应速度</span></span><br><span class="line">	GPIO_Init(GPIOB, &amp;GPIO_InitStructure);<span class="comment">//配置参数</span></span><br><span class="line">	</span><br><span class="line">	GPIO_EXTILineConfig(GPIO_PortSourceGPIOB, GPIO_PinSource0);<span class="comment">//选择中断线路</span></span><br><span class="line">	GPIO_EXTILineConfig(GPIO_PortSourceGPIOB, GPIO_PinSource1);</span><br><span class="line">	</span><br><span class="line">	EXTI_InitTypeDef EXTI_InitStructure;<span class="comment">//定义外部中断结构体</span></span><br><span class="line">	EXTI_InitStructure.EXTI_Line = EXTI_Line0 | EXTI_Line1;<span class="comment">//设置中断线</span></span><br><span class="line">	EXTI_InitStructure.EXTI_LineCmd = ENABLE;<span class="comment">//开启中断线路</span></span><br><span class="line">	EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;<span class="comment">//中断模式</span></span><br><span class="line">	EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Falling;<span class="comment">//下降沿触发</span></span><br><span class="line">	EXTI_Init(&amp;EXTI_InitStructure);<span class="comment">//写入参数</span></span><br><span class="line">	</span><br><span class="line">	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);<span class="comment">//中断优先级分组</span></span><br><span class="line">	</span><br><span class="line">	NVIC_InitTypeDef NVIC_InitStructure;<span class="comment">//定义NVIC结构体</span></span><br><span class="line">	NVIC_InitStructure.NVIC_IRQChannel = EXTI0_IRQn;<span class="comment">//设置中断通道</span></span><br><span class="line">	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;<span class="comment">//通道使能</span></span><br><span class="line">	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = <span class="number">1</span>;<span class="comment">//抢占优先级</span></span><br><span class="line">	NVIC_InitStructure.NVIC_IRQChannelSubPriority = <span class="number">1</span>;<span class="comment">//响应优先级</span></span><br><span class="line">	NVIC_Init(&amp;NVIC_InitStructure);<span class="comment">//写入参数</span></span><br><span class="line"></span><br><span class="line">	NVIC_InitStructure.NVIC_IRQChannel = EXTI1_IRQn;<span class="comment">//设置中断通道</span></span><br><span class="line">	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;<span class="comment">//通道使能</span></span><br><span class="line">	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = <span class="number">1</span>;<span class="comment">//抢占优先级</span></span><br><span class="line">	NVIC_InitStructure.NVIC_IRQChannelSubPriority = <span class="number">2</span>;<span class="comment">//响应优先级</span></span><br><span class="line">	NVIC_Init(&amp;NVIC_InitStructure);<span class="comment">//写入参数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int16_t</span> <span class="title">Encoder_Get</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int16_t</span> Temp;</span><br><span class="line">	Temp = Encoder_Count;</span><br><span class="line">	Encoder_Count = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> Temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EXTI0_IRQHandler</span><span class="params">(<span class="keyword">void</span>)</span><span class="comment">//线路0中断函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (EXTI_GetITStatus(EXTI_Line0) == SET)<span class="comment">//判断中断挂起位</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">/*如果出现数据乱跳的现象，可再次判断引脚电平，以避免抖动*/</span></span><br><span class="line">		<span class="keyword">if</span> (GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_0) == <span class="number">0</span>)<span class="comment">//读取输入高低电平</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_1) == <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				Encoder_Count --;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		EXTI_ClearITPendingBit(EXTI_Line0);<span class="comment">//清除中断挂起标志位</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EXTI1_IRQHandler</span><span class="params">(<span class="keyword">void</span>)</span><span class="comment">//线路1中断函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (EXTI_GetITStatus(EXTI_Line1) == SET)<span class="comment">//判断标志位</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">/*如果出现数据乱跳的现象，可再次判断引脚电平，以避免抖动*/</span></span><br><span class="line">		<span class="keyword">if</span> (GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_1) == <span class="number">0</span>)<span class="comment">//读取输入高低电平</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_0) == <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				Encoder_Count ++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		EXTI_ClearITPendingBit(EXTI_Line1);<span class="comment">//清除中断挂起标志位</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h3><ul>
<li><p>TIM（Timer）定时器</p>
</li>
<li><p>定时器可以对输入的时钟进行计数，并在计数值达到设定值时触发中断</p>
</li>
<li><p>16位计数器、预分频、自动重装寄存器的时基单元，在72M计数时钟下可以实现最大59.65s的定时</p>
</li>
<li><p>不仅具备基本的定时器中断功能，而且还包含内外时钟源选择、输入捕获、输出比较、编码器接口、主从触发模式等多种功能</p>
</li>
<li><p>根据复杂度和应用场景分为了高级定时器、通用定时器、基本定时器三种类型</p>
</li>
<li><p>对72MHz计72个数就是1MHz，也就是1us的时间，计72000个数，那就是1KHz也就是1ms的时间</p>
</li>
<li><p>59.65s =65536 X 65536X 1/72M/(中断频率倒数)，</p>
</li>
<li><p>STM32的定时器支持级联的模式：一个定时器的输出当做另一个定时器的输入最大定时时间就是59.65s X 65536 X 65536</p>
</li>
</ul>
<p><img src="https://gitee.com/pu-heliang/photos/raw/master/img/202301032044148.png" alt="image-20221224173356252"></p>
<ul>
<li>预分频器（PSC）：对输入的基准频率提前进行一个分频的操作</li>
<li>实际分频系数 = 预分频器的值 + 1，最大可以写65535即65536分频 </li>
<li>计数器（CNT）：也是16位，值可以从0~65535，当计数器的值自增（自减）到目标值时，产生中断，完成定时</li>
<li>自动重装寄存器（）：也是16位当计数值等于自动重装值时，就是计时的时间到了，就会产生一个中断信号，并且清零计数器，计数器自动开始下一次的计数计时，计数值等于自动重装值的中断一般叫做“更新中断”，此更新中断就会通往NVIC，再配置好NVIC的定时器通道，定时器上的更新中断就会得到CPU的响应了，对应的事件叫做“更新事件”，更新事件不会触发中断，但可以触发内部其他电路的工作</li>
</ul>
<p><img src="https://gitee.com/pu-heliang/photos/raw/master/img/202301032044571.png" alt="image-20221224174708831"></p>
<ul>
<li>从基准时钟，到预分频器，再到计数器，计数器自增，同时不断地与自动重装寄存器进行比较，计数器和自动重装寄存器的值相等时，即计时时间到，这时会产生一个更新中断和更新事件，CPU响应更新中断，就完成了定时中断的任务了。</li>
</ul>
<h4 id="主从触发模式"><a href="#主从触发模式" class="headerlink" title="主从触发模式"></a>主从触发模式</h4><p>使用定时器的主模式，可以把定时器的更新事件映射到触发输出TRGO（Trigger Out）的位置，TRGO直接接到DAC的触发转换引脚上，这样定时器的更新就不需要再通过中断来触发DAC转换了</p>
<p><img src="https://gitee.com/pu-heliang/photos/raw/master/img/202301032044975.png" alt="image-20221224181213236"></p>
<p>缓冲寄存器：某个时刻把预分频器由0改成了1，当计数计到一半的时候改变了分频值，这个变化不会立即生效，而是会等到本次计数周期结束时，产生了了更新事件，预分频器的值才会被传递到缓冲寄存器里面去，才会生效。</p>
<p>举个例子来说，如果我们想改变ARR寄存器中的值，但是当前的定时还没有结束，在这时如果未设置影子寄存器，那么设定的值会立即生效。而如果设置了影子寄存器，那么新的值会在当前计数周期结束之后生效。</p>
<p>计数器计数频率：CK_CNT = CK_PSC / (PSC + 1)</p>
<p>计数器溢出频率：CK_CNT_OV = CK_CNT / (ARR + 1)  = CK_PSC / (PSC + 1) / (ARR + 1)  </p>
<h4 id="开启定时器步骤"><a href="#开启定时器步骤" class="headerlink" title="开启定时器步骤"></a>开启定时器步骤</h4><ol>
<li> 第一步，RCC开启时钟</li>
<li>第二步，选择时基单元的时钟源</li>
<li>第三步，配置时基单元</li>
<li>第四步，配置输出中断控制，允许更新中断输出到NVIC</li>
<li>第五步，配置NVIC，在NVIC中打开定时器中断的通道，并分配一个优先级</li>
<li>第六步，运行控制</li>
<li>第七步，使能计数器</li>
</ol>
<h4 id="定时器常用的库函数"><a href="#定时器常用的库函数" class="headerlink" title="定时器常用的库函数"></a>定时器常用的库函数</h4><h5 id="恢复缺省配置函数"><a href="#恢复缺省配置函数" class="headerlink" title="恢复缺省配置函数"></a>恢复缺省配置函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM_DeInit</span><span class="params">(TIM_TypeDef* TIMx)</span></span>;</span><br></pre></td></tr></table></figure>

<h5 id="时基单元初始化函数"><a href="#时基单元初始化函数" class="headerlink" title="时基单元初始化函数"></a>时基单元初始化函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM_TimeBaseInit</span><span class="params">(TIM_TypeDef* TIMx, TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct)</span></span>;</span><br></pre></td></tr></table></figure>

<h5 id="把结构体变量赋一个默认值函数"><a href="#把结构体变量赋一个默认值函数" class="headerlink" title="把结构体变量赋一个默认值函数"></a>把结构体变量赋一个默认值函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM_TimeBaseStructInit</span><span class="params">(TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct)</span></span>;</span><br></pre></td></tr></table></figure>

<h5 id="使能计数器函数"><a href="#使能计数器函数" class="headerlink" title="使能计数器函数"></a>使能计数器函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM_Cmd</span><span class="params">(TIM_TypeDef* TIMx, FunctionalState NewState)</span></span>;</span><br></pre></td></tr></table></figure>

<h5 id="使能中断输出信号函数"><a href="#使能中断输出信号函数" class="headerlink" title="使能中断输出信号函数"></a>使能中断输出信号函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM_ITConfig</span><span class="params">(TIM_TypeDef* TIMx, <span class="keyword">uint16_t</span> TIM_IT, FunctionalState NewState)</span></span>;</span><br></pre></td></tr></table></figure>

<h5 id="选择内部时钟函数"><a href="#选择内部时钟函数" class="headerlink" title="选择内部时钟函数"></a>选择内部时钟函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM_InternalClockConfig</span><span class="params">(TIM_TypeDef* TIMx)</span></span>;</span><br></pre></td></tr></table></figure>

<h5 id="选择ITRx其他定时器的时钟函数"><a href="#选择ITRx其他定时器的时钟函数" class="headerlink" title="选择ITRx其他定时器的时钟函数"></a>选择ITRx其他定时器的时钟函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM_ITRxExternalClockConfig</span><span class="params">(TIM_TypeDef* TIMx, <span class="keyword">uint16_t</span> TIM_InputTriggerSource)</span></span>;</span><br></pre></td></tr></table></figure>

<h5 id="选择TIx捕获通道的时钟函数"><a href="#选择TIx捕获通道的时钟函数" class="headerlink" title="选择TIx捕获通道的时钟函数"></a>选择TIx捕获通道的时钟函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM_TIxExternalClockConfig</span><span class="params">(TIM_TypeDef* TIMx, <span class="keyword">uint16_t</span> TIM_TIxExternalCLKSource,<span class="keyword">uint16_t</span> TIM_ICPolarity, <span class="keyword">uint16_t</span> ICFilter)</span></span>;</span><br></pre></td></tr></table></figure>

<p>参数3：输入的极性 参数4：滤波器</p>
<h5 id="选择ETR通过外部时钟模式1输入的时钟函数"><a href="#选择ETR通过外部时钟模式1输入的时钟函数" class="headerlink" title="选择ETR通过外部时钟模式1输入的时钟函数"></a>选择ETR通过外部时钟模式1输入的时钟函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM_ETRClockMode1Config</span><span class="params">(TIM_TypeDef* TIMx, <span class="keyword">uint16_t</span> TIM_ExtTRGPrescaler, <span class="keyword">uint16_t</span> TIM_ExtTRGPolarity, <span class="keyword">uint16_t</span> ExtTRGFilter)</span></span>;</span><br></pre></td></tr></table></figure>

<p>参数2：预分频器 参数3：输入的极性 参数4：滤波器</p>
<h5 id="选择ETR通过外部时钟模式2输入的时钟函数"><a href="#选择ETR通过外部时钟模式2输入的时钟函数" class="headerlink" title="选择ETR通过外部时钟模式2输入的时钟函数"></a>选择ETR通过外部时钟模式2输入的时钟函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM_ETRClockMode2Config</span><span class="params">(TIM_TypeDef* TIMx, <span class="keyword">uint16_t</span> TIM_ExtTRGPrescaler, <span class="keyword">uint16_t</span> TIM_ExtTRGPolarity, <span class="keyword">uint16_t</span> ExtTRGFilter)</span></span>;</span><br></pre></td></tr></table></figure>

<h5 id="单独配置ETR引脚的预分频器、极性、滤波器这些参数的函数"><a href="#单独配置ETR引脚的预分频器、极性、滤波器这些参数的函数" class="headerlink" title="单独配置ETR引脚的预分频器、极性、滤波器这些参数的函数"></a>单独配置ETR引脚的预分频器、极性、滤波器这些参数的函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM_ETRConfig</span><span class="params">(TIM_TypeDef* TIMx, <span class="keyword">uint16_t</span> TIM_ExtTRGPrescaler, <span class="keyword">uint16_t</span> TIM_ExtTRGPolarity, <span class="keyword">uint16_t</span> ExtTRGFilter)</span></span>;</span><br></pre></td></tr></table></figure>

<h5 id="单独写预分频值函数"><a href="#单独写预分频值函数" class="headerlink" title="单独写预分频值函数"></a>单独写预分频值函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM_PrescalerConfig</span><span class="params">(TIM_TypeDef* TIMx, <span class="keyword">uint16_t</span> Prescaler, <span class="keyword">uint16_t</span> TIM_PSCReloadMode)</span></span>;</span><br></pre></td></tr></table></figure>

<p>参数3：写入的模式，在更新事件生效，或者在写入后，手动产生一个更新事件，让这个值立刻生效</p>
<h5 id="改变计数器的计数模式函数"><a href="#改变计数器的计数模式函数" class="headerlink" title="改变计数器的计数模式函数"></a>改变计数器的计数模式函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM_CounterModeConfig</span><span class="params">(TIM_TypeDef* TIMx, <span class="keyword">uint16_t</span> TIM_CounterMode)</span></span>;</span><br></pre></td></tr></table></figure>

<h5 id="自动重装器预装功能配置函数"><a href="#自动重装器预装功能配置函数" class="headerlink" title="自动重装器预装功能配置函数"></a>自动重装器预装功能配置函数</h5><p>TIM_ARRPreloadConfig设置为DISABLE 和ENABLE的问题，他的作用只是允许或禁止在定时器工作时向ARR的缓冲器中写入新值，以便在更新事件发生时载入覆盖以前的值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM_ARRPreloadConfig</span><span class="params">(TIM_TypeDef* TIMx, FunctionalState NewState)</span></span>;</span><br></pre></td></tr></table></figure>

<h5 id="给计数器写入一个值函数"><a href="#给计数器写入一个值函数" class="headerlink" title="给计数器写入一个值函数"></a>给计数器写入一个值函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM_SetCounter</span><span class="params">(TIM_TypeDef* TIMx, <span class="keyword">uint16_t</span> Counter)</span></span>;</span><br></pre></td></tr></table></figure>

<h5 id="给自动重装器写入一个值函数"><a href="#给自动重装器写入一个值函数" class="headerlink" title="给自动重装器写入一个值函数"></a>给自动重装器写入一个值函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM_SetAutoreload</span><span class="params">(TIM_TypeDef* TIMx, <span class="keyword">uint16_t</span> Autoreload)</span></span>;</span><br></pre></td></tr></table></figure>

<h5 id="获取当前计数器的值函数"><a href="#获取当前计数器的值函数" class="headerlink" title="获取当前计数器的值函数"></a>获取当前计数器的值函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">uint16_t</span> <span class="title">TIM_GetCounter</span><span class="params">(TIM_TypeDef* TIMx)</span></span>;</span><br></pre></td></tr></table></figure>

<h5 id="获取当前预分频器的值函数"><a href="#获取当前预分频器的值函数" class="headerlink" title="获取当前预分频器的值函数"></a>获取当前预分频器的值函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">uint16_t</span> <span class="title">TIM_GetPrescaler</span><span class="params">(TIM_TypeDef* TIMx)</span></span>;</span><br></pre></td></tr></table></figure>

<p>使用跨文件的变量： extern声明变量，告诉编译器，有Num这个变量在别的文件中定义了，在此文件中也可以使用 </p>
<h4 id="程序示例："><a href="#程序示例：" class="headerlink" title="程序示例："></a>程序示例：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Timer_Init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2, ENABLE);<span class="comment">//开启TIM2时钟</span></span><br><span class="line">	</span><br><span class="line">	TIM_InternalClockConfig(TIM2);<span class="comment">//使用内部时钟</span></span><br><span class="line">	</span><br><span class="line">	TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;<span class="comment">//定义时基单元结构体</span></span><br><span class="line">	TIM_TimeBaseInitStructure.TIM_ClockDivision = TIM_CKD_DIV1;<span class="comment">//设置不分频</span></span><br><span class="line">	TIM_TimeBaseInitStructure.TIM_CounterMode = TIM_CounterMode_Up;<span class="comment">//设置向上计数</span></span><br><span class="line">	TIM_TimeBaseInitStructure.TIM_Period = <span class="number">10000</span> - <span class="number">1</span>;<span class="comment">//ARR自动重装值</span></span><br><span class="line">	TIM_TimeBaseInitStructure.TIM_Prescaler = <span class="number">7200</span> - <span class="number">1</span>;<span class="comment">//PSC不分频</span></span><br><span class="line">	TIM_TimeBaseInitStructure.TIM_RepetitionCounter = <span class="number">0</span>;<span class="comment">//重复计数器的值，高级定时器特有</span></span><br><span class="line">	TIM_TimeBaseInit(TIM2, &amp;TIM_TimeBaseInitStructure);<span class="comment">//写入参数</span></span><br><span class="line">	</span><br><span class="line">	TIM_ClearFlag(TIM2, TIM_FLAG_Update);<span class="comment">//清除更新标志位</span></span><br><span class="line">	TIM_ITConfig(TIM2, TIM_IT_Update, ENABLE);<span class="comment">//中断输出</span></span><br><span class="line">	</span><br><span class="line">	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);<span class="comment">//中断优先级分组</span></span><br><span class="line">	</span><br><span class="line">	NVIC_InitTypeDef NVIC_InitStructure;<span class="comment">//NVIC结构体</span></span><br><span class="line">	NVIC_InitStructure.NVIC_IRQChannel = TIM2_IRQn;<span class="comment">//定时器通道</span></span><br><span class="line">	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;<span class="comment">//使能</span></span><br><span class="line">	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = <span class="number">2</span>;<span class="comment">//抢占优先级</span></span><br><span class="line">	NVIC_InitStructure.NVIC_IRQChannelSubPriority = <span class="number">1</span>;<span class="comment">//响应优先级</span></span><br><span class="line">	NVIC_Init(&amp;NVIC_InitStructure);<span class="comment">//写入参数</span></span><br><span class="line">	</span><br><span class="line">	TIM_Cmd(TIM2, ENABLE);<span class="comment">//开启定时器</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">void TIM2_IRQHandler(void)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">	if (TIM_GetITStatus(TIM2, TIM_IT_Update) == SET)//判断是否中断溢出</span></span><br><span class="line"><span class="comment">	&#123;</span></span><br><span class="line"><span class="comment">		</span></span><br><span class="line"><span class="comment">		TIM_ClearITPendingBit(TIM2, TIM_IT_Update);//清除中断标志位</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="输出比较"><a href="#输出比较" class="headerlink" title="输出比较"></a>输出比较</h3><ul>
<li>OC（Output Compare）输出比较</li>
<li>输出比较可以通过比较CNT和CCR寄存器值的关系，来对输出电平进行置1、置0或翻转的操作，用于输出一定频率和占空比的PWM波形</li>
<li>每个高级定时器和通用定时器都拥有4个输出比较通道</li>
<li>高级定时器的前3个通道额外拥有死去生成和互补输出的功能</li>
</ul>
<h5 id="输出比较常用的函数"><a href="#输出比较常用的函数" class="headerlink" title="输出比较常用的函数"></a>输出比较常用的函数</h5><h5 id="配置输出比较函数"><a href="#配置输出比较函数" class="headerlink" title="配置输出比较函数"></a>配置输出比较函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM_OC1Init</span><span class="params">(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM_OC2Init</span><span class="params">(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM_OC3Init</span><span class="params">(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM_OC4Init</span><span class="params">(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)</span></span>;</span><br></pre></td></tr></table></figure>

<h5 id="给输出比较结构体赋一个默认值函数"><a href="#给输出比较结构体赋一个默认值函数" class="headerlink" title="给输出比较结构体赋一个默认值函数"></a>给输出比较结构体赋一个默认值函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM_OCStructInit</span><span class="params">(TIM_OCInitTypeDef* TIM_OCInitStruct)</span></span>;</span><br></pre></td></tr></table></figure>

<h5 id="配置强制输出模式函数"><a href="#配置强制输出模式函数" class="headerlink" title="配置强制输出模式函数"></a>配置强制输出模式函数</h5><p>在运行中想要暂停输出波形并且强制输出高或者低电平，强制输出高电平和设置百分百占空比一样，强制输出低电平和设置百分百低电平是一样的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM_ForcedOC1Config</span><span class="params">(TIM_TypeDef* TIMx, <span class="keyword">uint16_t</span> TIM_ForcedAction)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM_ForcedOC2Config</span><span class="params">(TIM_TypeDef* TIMx, <span class="keyword">uint16_t</span> TIM_ForcedAction)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM_ForcedOC3Config</span><span class="params">(TIM_TypeDef* TIMx, <span class="keyword">uint16_t</span> TIM_ForcedAction)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM_ForcedOC4Config</span><span class="params">(TIM_TypeDef* TIMx, <span class="keyword">uint16_t</span> TIM_ForcedAction)</span></span>;</span><br></pre></td></tr></table></figure>

<h5 id="配置CCR寄存器的预装功能函数"><a href="#配置CCR寄存器的预装功能函数" class="headerlink" title="配置CCR寄存器的预装功能函数"></a>配置CCR寄存器的预装功能函数</h5><p>预装功能就是影子寄存器：写入的值不会立即生效，而是在更新事件才会生效</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM_OC1PreloadConfig</span><span class="params">(TIM_TypeDef* TIMx, <span class="keyword">uint16_t</span> TIM_OCPreload)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM_OC2PreloadConfig</span><span class="params">(TIM_TypeDef* TIMx, <span class="keyword">uint16_t</span> TIM_OCPreload)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM_OC3PreloadConfig</span><span class="params">(TIM_TypeDef* TIMx, <span class="keyword">uint16_t</span> TIM_OCPreload)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM_OC4PreloadConfig</span><span class="params">(TIM_TypeDef* TIMx, <span class="keyword">uint16_t</span> TIM_OCPreload)</span></span>;</span><br></pre></td></tr></table></figure>

<h5 id="配置快速使能函数"><a href="#配置快速使能函数" class="headerlink" title="配置快速使能函数"></a>配置快速使能函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM_OC1FastConfig</span><span class="params">(TIM_TypeDef* TIMx, <span class="keyword">uint16_t</span> TIM_OCFast)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM_OC2FastConfig</span><span class="params">(TIM_TypeDef* TIMx, <span class="keyword">uint16_t</span> TIM_OCFast)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM_OC3FastConfig</span><span class="params">(TIM_TypeDef* TIMx, <span class="keyword">uint16_t</span> TIM_OCFast)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM_OC4FastConfig</span><span class="params">(TIM_TypeDef* TIMx, <span class="keyword">uint16_t</span> TIM_OCFast)</span></span>;</span><br></pre></td></tr></table></figure>

<h5 id="外部事件时清除REF信号函数"><a href="#外部事件时清除REF信号函数" class="headerlink" title="外部事件时清除REF信号函数"></a>外部事件时清除REF信号函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM_ClearOC1Ref</span><span class="params">(TIM_TypeDef* TIMx, <span class="keyword">uint16_t</span> TIM_OCClear)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM_ClearOC2Ref</span><span class="params">(TIM_TypeDef* TIMx, <span class="keyword">uint16_t</span> TIM_OCClear)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM_ClearOC3Ref</span><span class="params">(TIM_TypeDef* TIMx, <span class="keyword">uint16_t</span> TIM_OCClear)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM_ClearOC4Ref</span><span class="params">(TIM_TypeDef* TIMx, <span class="keyword">uint16_t</span> TIM_OCClear)</span></span>;</span><br></pre></td></tr></table></figure>

<h5 id="单独设置输出比较的极性函数"><a href="#单独设置输出比较的极性函数" class="headerlink" title="单独设置输出比较的极性函数"></a>单独设置输出比较的极性函数</h5><p>带N的是高级定时器里互补通道的配置函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM_OC1PolarityConfig</span><span class="params">(TIM_TypeDef* TIMx, <span class="keyword">uint16_t</span> TIM_OCPolarity)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM_OC1NPolarityConfig</span><span class="params">(TIM_TypeDef* TIMx, <span class="keyword">uint16_t</span> TIM_OCNPolarity)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM_OC2PolarityConfig</span><span class="params">(TIM_TypeDef* TIMx, <span class="keyword">uint16_t</span> TIM_OCPolarity)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM_OC2NPolarityConfig</span><span class="params">(TIM_TypeDef* TIMx, <span class="keyword">uint16_t</span> TIM_OCNPolarity)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM_OC3PolarityConfig</span><span class="params">(TIM_TypeDef* TIMx, <span class="keyword">uint16_t</span> TIM_OCPolarity)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM_OC3NPolarityConfig</span><span class="params">(TIM_TypeDef* TIMx, <span class="keyword">uint16_t</span> TIM_OCNPolarity)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM_OC4PolarityConfig</span><span class="params">(TIM_TypeDef* TIMx, <span class="keyword">uint16_t</span> TIM_OCPolarity)</span></span>;</span><br></pre></td></tr></table></figure>

<h5 id="单独修改输出使能参数函数"><a href="#单独修改输出使能参数函数" class="headerlink" title="单独修改输出使能参数函数"></a>单独修改输出使能参数函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM_CCxCmd</span><span class="params">(TIM_TypeDef* TIMx, <span class="keyword">uint16_t</span> TIM_Channel, <span class="keyword">uint16_t</span> TIM_CCx)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM_CCxNCmd</span><span class="params">(TIM_TypeDef* TIMx, <span class="keyword">uint16_t</span> TIM_Channel, <span class="keyword">uint16_t</span> TIM_CCxN)</span></span>;</span><br></pre></td></tr></table></figure>

<h5 id="选择输出比较模式函数"><a href="#选择输出比较模式函数" class="headerlink" title="选择输出比较模式函数"></a>选择输出比较模式函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM_SelectOCxM</span><span class="params">(TIM_TypeDef* TIMx, <span class="keyword">uint16_t</span> TIM_Channel, <span class="keyword">uint16_t</span> TIM_OCMode)</span></span>;</span><br></pre></td></tr></table></figure>

<h5 id="单独更改CCR寄存器的值的函数"><a href="#单独更改CCR寄存器的值的函数" class="headerlink" title="单独更改CCR寄存器的值的函数"></a>单独更改CCR寄存器的值的函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM_SetCompare1</span><span class="params">(TIM_TypeDef* TIMx, <span class="keyword">uint16_t</span> Compare1)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM_SetCompare2</span><span class="params">(TIM_TypeDef* TIMx, <span class="keyword">uint16_t</span> Compare2)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM_SetCompare3</span><span class="params">(TIM_TypeDef* TIMx, <span class="keyword">uint16_t</span> Compare3)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM_SetCompare4</span><span class="params">(TIM_TypeDef* TIMx, <span class="keyword">uint16_t</span> Compare4)</span></span>;</span><br></pre></td></tr></table></figure>

<h5 id="使用高级定时器输出PWM时调用使能主输出函数"><a href="#使用高级定时器输出PWM时调用使能主输出函数" class="headerlink" title="使用高级定时器输出PWM时调用使能主输出函数"></a>使用高级定时器输出PWM时调用使能主输出函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM_CtrlPWMOutputs</span><span class="params">(TIM_TypeDef* TIMx, FunctionalState NewState)</span></span>;</span><br></pre></td></tr></table></figure>

<p>定时器输出需要使用复用推挽输出，开启复用推挽输出引脚的控制权才能交给片上外设，PWM波形才能通过引脚输出</p>
<h5 id="引脚重映射"><a href="#引脚重映射" class="headerlink" title="引脚重映射"></a>引脚重映射</h5><p>开启AFIO时钟函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GPIO_PinRemapConfig</span><span class="params">(<span class="keyword">uint32_t</span> GPIO_Remap, FunctionalState NewState)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>完全重映射：四个引脚全换</li>
<li>部分重映射：前面两个引脚变了或者后面两个引脚变了</li>
<li>调试端口不能做普通的GPIO口使用，需要解除复用</li>
</ul>
<h4 id="程序示例-2"><a href="#程序示例-2" class="headerlink" title="程序示例"></a>程序示例</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PWM_Init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2, ENABLE);<span class="comment">//开启TIM2时钟</span></span><br><span class="line">	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);<span class="comment">//开启GPIO时钟</span></span><br><span class="line">	</span><br><span class="line">	GPIO_InitTypeDef GPIO_InitStructure;<span class="comment">//定义GPIO结构体</span></span><br><span class="line">	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;<span class="comment">//复用推挽输出</span></span><br><span class="line">	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2;<span class="comment">//开启引脚</span></span><br><span class="line">	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;<span class="comment">//配置响应速度</span></span><br><span class="line">	GPIO_Init(GPIOA, &amp;GPIO_InitStructure);<span class="comment">//写入参数</span></span><br><span class="line">	</span><br><span class="line">	TIM_InternalClockConfig(TIM2);<span class="comment">//使用内部时钟</span></span><br><span class="line">	</span><br><span class="line">	TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;<span class="comment">//配置时基单元</span></span><br><span class="line">	TIM_TimeBaseInitStructure.TIM_ClockDivision = TIM_CKD_DIV1;<span class="comment">//不分频</span></span><br><span class="line">	TIM_TimeBaseInitStructure.TIM_CounterMode = TIM_CounterMode_Up;<span class="comment">//向上计数</span></span><br><span class="line">	TIM_TimeBaseInitStructure.TIM_Period = <span class="number">100</span> - <span class="number">1</span>;		<span class="comment">//ARR</span></span><br><span class="line">	TIM_TimeBaseInitStructure.TIM_Prescaler = <span class="number">36</span> - <span class="number">1</span>;		<span class="comment">//PSC</span></span><br><span class="line">	TIM_TimeBaseInitStructure.TIM_RepetitionCounter = <span class="number">0</span>;<span class="comment">//重复计数器</span></span><br><span class="line">	TIM_TimeBaseInit(TIM2, &amp;TIM_TimeBaseInitStructure);<span class="comment">//写入参数</span></span><br><span class="line">	</span><br><span class="line">	TIM_OCInitTypeDef TIM_OCInitStructure;<span class="comment">//定义输出比较结构体</span></span><br><span class="line">	TIM_OCStructInit(&amp;TIM_OCInitStructure);<span class="comment">//给结构体赋默认值</span></span><br><span class="line">	TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM1;<span class="comment">//PWM1模式</span></span><br><span class="line">	TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High;<span class="comment">//有效电平为高电平</span></span><br><span class="line">	TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable;<span class="comment">//使能</span></span><br><span class="line">	TIM_OCInitStructure.TIM_Pulse = <span class="number">0</span>;		<span class="comment">//CCR</span></span><br><span class="line">	TIM_OC3Init(TIM2, &amp;TIM_OCInitStructure);<span class="comment">//写入参数</span></span><br><span class="line">	</span><br><span class="line">	TIM_Cmd(TIM2, ENABLE);<span class="comment">//开启时钟</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PWM_SetCompare3</span><span class="params">(<span class="keyword">uint16_t</span> Compare)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	TIM_SetCompare3(TIM2, Compare);<span class="comment">//设置CCR3的值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="输入捕获"><a href="#输入捕获" class="headerlink" title="输入捕获"></a>输入捕获</h3><ul>
<li>IC（Input Capture）输入捕获</li>
<li>输入捕获模式下，当通道输入引脚出现指定电平跳变时，当前CNT的值将被锁存到CCR中，可用于测量PWM波形的频率、占空比、脉冲间隔、电平持续时间等参数</li>
<li>每个高级定时器和通用定时器都拥有4个输入捕获通道</li>
<li>可配置PWMI模式，同时测量频率和占空比</li>
<li>可配合主从触发模式，实现硬件全自动测量</li>
</ul>
<h5 id="频率测量："><a href="#频率测量：" class="headerlink" title="频率测量："></a>频率测量：</h5><h5 id="测频法：在闸门时间T内，对上升沿计次，得到N，则频率"><a href="#测频法：在闸门时间T内，对上升沿计次，得到N，则频率" class="headerlink" title="测频法：在闸门时间T内，对上升沿计次，得到N，则频率"></a>测频法：在闸门时间T内，对上升沿计次，得到N，则频率</h5><p><img src="https://gitee.com/pu-heliang/photos/raw/master/img/202301032052812.png" alt="image-20221226183437986"></p>
<p><img src="https://gitee.com/pu-heliang/photos/raw/master/img/202301032044214.png" alt="image-20221226183513365"></p>
<p>测频法：自定一个闸门时间T，通常设置为1s，在1s时间内，对信号上升沿计次，从0开始计，每来一个上升沿，计次+1，每来一个上升沿，其实就是来了一个周期的信号，在1s时间内，来个几个周期，频率就是多少Hz，（频率的定义：1s内出现了多少个重复的周期），这是一种直接按频率定义来测量的方法，闸门时间也可以是2s，计次值除2，就是频率</p>
<p>测频法测量的是一个闸门时间的多个周期自带一个均值滤波，如果在闸门时间内波形频率有变化，得到的其实是这一段时间的平均频率，测频法测量时间慢，测量结果是一段时间的平均值，值比较平滑</p>
<h5 id="测周法：两个上升沿内，以标准频率计次，得到N，则频率"><a href="#测周法：两个上升沿内，以标准频率计次，得到N，则频率" class="headerlink" title="测周法：两个上升沿内，以标准频率计次，得到N，则频率"></a>测周法：两个上升沿内，以标准频率计次，得到N，则频率</h5><p><img src="https://gitee.com/pu-heliang/photos/raw/master/img/202301032052813.png" alt="image-20221226184746596"></p>
<p><img src="https://gitee.com/pu-heliang/photos/raw/master/img/202301032045325.png" alt="image-20221226184823583"></p>
<p>测周法：捕获信号的两个上升沿，测量之间持续的时间，使用一个已知的标准频率的计次时钟，来驱动计数器，从一个上升沿开始计，计数器从0开始，一直计到下一个上升沿，停止，计一个数的时间是1/fc，计N个数时间就是N/fc，N/fc就是周期，再取个倒数，就得到频率的公式，fx = fc/N</p>
<p>测周法只测量一个周期，就能出一次结果，出结果的速度取决于待测信号的频率，一般来说测周法结果更新更快，但是由于他只测量一个周期，所以结果值会受噪声的影响，波动比较大。</p>
<p>测频法适合测高频信号，测周法适合测量低频信号</p>
<p>例如：定了1s为闸门周期，结果1s内一个上升沿都没有，但不能认为频率是0，计次N很少时，误差会非常大，所以测频法适合测量高频率的信号，测周法适合低频信号，低频信号，周期比较长，计次就会比较多，有助于减少误差。如果待测频率太高，那么一个周期内只能计一两个数，如果待测信号再高一些，甚至一个数也计不到，不能认为频率无穷大</p>
<p>中界频率：测频法与测周法误差相等时的频率点（测频法和测周法的N相同）</p>
<p><img src="https://gitee.com/pu-heliang/photos/raw/master/img/202301032045027.png" alt="image-20221226193408126"></p>
<p>计数次数越多，+-1误差对结果的影响越小</p>
<p>待测频率&lt;中界频率，测周法合适</p>
<p>待测频率&gt;中界频率，测频法合适</p>
<p>异或门：当输入引脚的任何一个引脚有电平翻转时，输出引脚就产生一次电平翻转</p>
<p><img src="https://gitee.com/pu-heliang/photos/raw/master/img/202301032045812.png" alt="image-20221226194451569"></p>
<p>输入信号来到输入滤波器（对信号进行滤波，避免高频的毛刺信号误触发）和边沿检测器（可以选择高电平触发，或者低电平触发）</p>
<p>有两套滤波和边沿检测电路，第一套电路：经过滤波和极性选择得到TI1FP1，输入给通道1的后续电路，第二套电路：经过另一个滤波和极性选择得到TI1FP2，输入给下面通道2的后续电路，同理下面TI2的信号进来，也经过两套滤波和极性选择，得到TI2FP1和TI2FP2，其中TI2FP1输入给上面，TI2FP2输入给下面，两个输入信号进来可以选择各走各的，也可以选择进行交叉，让CH2引脚输入给通道1，或者CH1引脚输入给通道2，这样做的目的可以灵活切换后续捕获电路的输入，通过数据选择器进行灵活选择，可以把一个引脚的输入，同时映射到两个捕获单元，这是PWMI的经典结构，</p>
<p>例如，第一个捕获通道，使用上升沿触发，用来捕获周期，第二个通道，使用下降沿触发，用来捕获占空比，两个通道同时对一个引脚进行捕获，就可以同时测量频率和占空比，这就是PWMI模式。</p>
<p>TRC是为了无刷电机的驱动</p>
<p>输入信号进行滤波和极性选择后，来到预分频器，预分频器，每个通道各有一个，可以选择对前面的信号进行分频，分频之后的触发信号就可以触发捕获电路进行工作了，每来一个触发信号，CNT的值就会向CCR转运一次，转运的同时，会发送一个捕获事件，这个事件会在状态寄存器置标志位，同时也可以产生中断，如果需要再捕获期间处理事情就可以开启这个捕获中断</p>
<p>例如：配置上升沿触发捕获，每来一个上升沿，CNT转运到CCR一次，因为CNT计数器是由内部的标准时钟驱动的，所以CNT的数值，可以用来记录两个上升沿之间的时间间隔，这个时间间隔就是周期，再取个倒数就是测周法测量的频率了，</p>
<p>每次捕获后要把CNT清0，下次再上升沿再捕获的时候取出的CNT才是两个上升沿的时间间隔，可以用主从触发模式，自动来完成。</p>
<p>数字滤波器：由一个事件计数器组成，记录到N个事件后会产生一个输出的跳变，简单来说滤波器的工作原理就是，以采样频率对输入信号进行采样，当连续N个值都为高电平，输出才为高电平，连续N个值都为低电平输出才为低电平，如果信号出现高频抖动，导致连续采样N个值不全都一样，那输出就不会变化，这样就可以达到滤波的效果，采样频率越低，采样个数N越大，滤波效果就越好。</p>
<h5 id="主从触发模式：（主模式、从模式和触发源选择三个功能的简称）"><a href="#主从触发模式：（主模式、从模式和触发源选择三个功能的简称）" class="headerlink" title="主从触发模式：（主模式、从模式和触发源选择三个功能的简称）"></a>主从触发模式：（主模式、从模式和触发源选择三个功能的简称）</h5><p><img src="https://gitee.com/pu-heliang/photos/raw/master/img/202301032045959.png" alt="image-20221226201447496"></p>
<p>主模式：将定时器内部的信号映射到TRGO引脚，用于触发别的外设。</p>
<p>从模式：接收其他外设或者自身外设的一些信号，用于控制自身定时器的运行，也就是被别的信号控制。</p>
<p>触发源选择：选择从模式的触发信号源，也可以认为是从模式的一部分，触发源选择，选择一个指定的信号得到TRGI，TRGI去触发从模式，从模式可以在上述列表里，选择一项操作来自动执行。</p>
<p>例如：让TI1FP11信号自动触发CNT清零，触发源选择可以选择TI1FP1，从模式执行的操作，就可以选择执行Reset的操作，这样TI1FP1的信号就可以自动触发从模式，从模式自动清零CNT，实现硬件全自动测量</p>
<h5 id="输入捕获基本结构："><a href="#输入捕获基本结构：" class="headerlink" title="输入捕获基本结构："></a>输入捕获基本结构：</h5><p><img src="https://gitee.com/pu-heliang/photos/raw/master/img/202301032045602.png" alt="image-20221226202515990"></p>
<p>只使用了一个通道，目前只能测量频率，配置好时基单元，启动定时器，CNT就会在预分频之后的时钟驱动下，不断自增，这个CNT就是测周法用来计数计时的，经过预分频之后的时钟频率就是，驱动CNT的标准频率fc，(标准频率 = 72M/预分频系数)，下面输入捕获通道1的GPIO口，输入一个上面的方波信号，经过滤波器和边沿检测，选择TI1FP1为上升沿触发，之后输入选择直连的通道分频器选择不分频，当TI1FP1出现上升沿之后，CNT的当前计数值转运到CCR1里，同时触发源选择，选择TI1FP1选择为触发信号，选中TI1FP1为触发信号，从模式选择复位操作，TI1FP1的上升沿也同样会通过上面的触发源选择那一路，取触发CNT清零，注意是先转运CNT的值到CCR里去，再出发从模式给CNT清零或者是非阻塞的同时转移，CNT的值转移到CCR，同时0转移到CNT里面去，不能是先清零CNT，再捕获，否则捕获值都是0了。</p>
<p>例如：左上角图，信号产生一个上升沿，CCR1 = CNT，就是把CNT的值转运到CCR1里面去，这是输入捕获自动执行的让CNT = 0，清零计数器（从模式自动执行的），在一个周期之内，CNT在标准时钟的驱动下，不断自增，并且由于之前清零过了，所以CNT就是从上升沿开始，从0开始计数一直++，指导，下一次上升沿来临，然后执行相同的操作，CCR1 = CNT，CNT = 0，第二次捕获时CNT，继续执行操作</p>
<p>如果信号频率太低，CNT的计数值可能会溢出</p>
<p>想使用从模式自动清除CNT，只能用通道1和通道2，对于通道3和通道4，就只能开启捕获中断，在中断里手动清零了。（这样做程序会处于频繁中断的状态，比较消耗软件资源）</p>
<h4 id="输入捕获程序示例"><a href="#输入捕获程序示例" class="headerlink" title="输入捕获程序示例"></a>输入捕获程序示例</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3, ENABLE);</span><br><span class="line">	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);</span><br><span class="line">	</span><br><span class="line">	GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;</span><br><span class="line">	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6;</span><br><span class="line">	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">	GPIO_Init(GPIOA, &amp;GPIO_InitStructure);</span><br><span class="line">	</span><br><span class="line">	TIM_InternalClockConfig(TIM3);</span><br><span class="line">	</span><br><span class="line">	TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;</span><br><span class="line">	TIM_TimeBaseInitStructure.TIM_ClockDivision = TIM_CKD_DIV1;</span><br><span class="line">	TIM_TimeBaseInitStructure.TIM_CounterMode = TIM_CounterMode_Up;</span><br><span class="line">	TIM_TimeBaseInitStructure.TIM_Period = <span class="number">65536</span> - <span class="number">1</span>;		<span class="comment">//ARR</span></span><br><span class="line">	TIM_TimeBaseInitStructure.TIM_Prescaler = <span class="number">72</span> - <span class="number">1</span>;		<span class="comment">//PSC</span></span><br><span class="line">	TIM_TimeBaseInitStructure.TIM_RepetitionCounter = <span class="number">0</span>;</span><br><span class="line">	TIM_TimeBaseInit(TIM3, &amp;TIM_TimeBaseInitStructure);</span><br><span class="line">	</span><br><span class="line">	TIM_ICInitTypeDef TIM_ICInitStructure;<span class="comment">//定义输入捕获结构体</span></span><br><span class="line">	TIM_ICInitStructure.TIM_Channel = TIM_Channel_1;<span class="comment">//通道1</span></span><br><span class="line">	TIM_ICInitStructure.TIM_ICFilter = <span class="number">0xF</span>;<span class="comment">//滤波器开最大</span></span><br><span class="line">	TIM_ICInitStructure.TIM_ICPolarity = TIM_ICPolarity_Rising;<span class="comment">//上升沿触发</span></span><br><span class="line">	TIM_ICInitStructure.TIM_ICPrescaler = TIM_ICPSC_DIV1;<span class="comment">//不分频</span></span><br><span class="line">	TIM_ICInitStructure.TIM_ICSelection = TIM_ICSelection_DirectTI;<span class="comment">//直接模式</span></span><br><span class="line">	TIM_ICInit(TIM3, &amp;TIM_ICInitStructure);</span><br><span class="line">	</span><br><span class="line">	TIM_SelectInputTrigger(TIM3, TIM_TS_TI1FP1);<span class="comment">//选择触发源</span></span><br><span class="line">	TIM_SelectSlaveMode(TIM3, TIM_SlaveMode_Reset);<span class="comment">//从模式</span></span><br><span class="line">	</span><br><span class="line">	TIM_Cmd(TIM3, ENABLE);<span class="comment">//开启定时器</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">IC_GetFreq</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1000000</span> / (TIM_GetCapture1(TIM3) + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<h3 id="PWMI基本结构："><a href="#PWMI基本结构：" class="headerlink" title="PWMI基本结构："></a>PWMI基本结构：</h3><p><img src="https://gitee.com/pu-heliang/photos/raw/master/img/202301032045950.png" alt="image-20221226204252689"></p>
<p>PWMI模式，使用了两个通道捕获一个引脚可以同时测量周期和占空比，TI1FP1配置上升沿触发，触发捕获和清零CNT，TI1FP2，配置为下降沿触发，通过交叉通道，去触发通道2的捕获单元，去触发通道2的捕获单元</p>
<p>例如：左上角图，最开始上升沿，CCR1捕获，同时清零CNT，之后CNT一直++，在下降沿这个时刻，触发CCR2捕获，这时CCR的值就是高电平期间的计数值，CCR2捕获不会触发CNT清零，CNT++，直到下一次上升沿，CCR1捕获周期，CNT清零，这样执行，CCR1就一整个周期的计数值，CCR2就是高电平期间的计数值，用CCR2/CCR1，就是占空比。</p>
<h5 id="单独写入PSC的函数"><a href="#单独写入PSC的函数" class="headerlink" title="单独写入PSC的函数"></a>单独写入PSC的函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM_PrescalerConfig</span><span class="params">(TIM_TypeDef* TIMx, <span class="keyword">uint16_t</span> Prescaler, <span class="keyword">uint16_t</span> TIM_PSCReloadMode)</span></span>;</span><br></pre></td></tr></table></figure>

<h5 id="输入捕获步骤"><a href="#输入捕获步骤" class="headerlink" title="输入捕获步骤"></a>输入捕获步骤</h5><p>第一步，RCC开启时钟，把GPIO的TIM的时钟打开</p>
<p>第二步，GPIO初始化，把GPIO配置成输入模式，一般选择上拉输入或者浮空输入模式</p>
<p>第三步，配置时基单元，让CNT计数器在内部时钟的驱动下自增运行</p>
<p>第四步，配置输入捕获单元，包括滤波器、极性、直连通道还是交叉通道、分频器这些参数</p>
<p>第五步，选择从模式的触发源，触发源选择TI1FP1，调用一个库函数即可</p>
<p>第六步，选择触发之后执行的操作，执行Reset操作，调用一个库函数即可</p>
<p>第七步，调用TIM_Cmd函数，开启定时器</p>
<h5 id="输入捕获常用函数"><a href="#输入捕获常用函数" class="headerlink" title="输入捕获常用函数"></a>输入捕获常用函数</h5><h5 id="结构体配置输入捕获单元的函数"><a href="#结构体配置输入捕获单元的函数" class="headerlink" title="结构体配置输入捕获单元的函数"></a>结构体配置输入捕获单元的函数</h5><p>输出比较每个通道占用一个函数，输入捕获4个通道是共用一个函数的,在结构体中有额外的参数来选择通道</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM_ICInit</span><span class="params">(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct)</span></span>;</span><br></pre></td></tr></table></figure>

<h5 id="另一个输入捕获的初始化函数"><a href="#另一个输入捕获的初始化函数" class="headerlink" title="另一个输入捕获的初始化函数"></a>另一个输入捕获的初始化函数</h5><p>与上一个函数类似都是用于初始化输入捕获单元的，上一个函数只是单一的配置一个通道，而这个函数可以快速配置两个通道，把外设电路配置成PWMI的电路</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM_PWMIConfig</span><span class="params">(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct)</span></span>;</span><br></pre></td></tr></table></figure>

<h5 id="给输入捕获结构体赋一个初始值函数"><a href="#给输入捕获结构体赋一个初始值函数" class="headerlink" title="给输入捕获结构体赋一个初始值函数"></a>给输入捕获结构体赋一个初始值函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM_ICStructInit</span><span class="params">(TIM_ICInitTypeDef* TIM_ICInitStruct)</span></span>;</span><br></pre></td></tr></table></figure>

<h5 id="选择输入触发源TRGI函数"><a href="#选择输入触发源TRGI函数" class="headerlink" title="选择输入触发源TRGI函数"></a>选择输入触发源TRGI函数</h5><p>调用此函数可以选择从模式的触发源</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM_SelectInputTrigger</span><span class="params">(TIM_TypeDef* TIMx, <span class="keyword">uint16_t</span> TIM_InputTriggerSource)</span></span>;</span><br></pre></td></tr></table></figure>

<h5 id="选择输出触发源TRGO函数"><a href="#选择输出触发源TRGO函数" class="headerlink" title="选择输出触发源TRGO函数"></a>选择输出触发源TRGO函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM_SelectOutputTrigger</span><span class="params">(TIM_TypeDef* TIMx, <span class="keyword">uint16_t</span> TIM_TRGOSource)</span></span>;</span><br></pre></td></tr></table></figure>

<h5 id="选择从模式函数"><a href="#选择从模式函数" class="headerlink" title="选择从模式函数"></a>选择从模式函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM_SelectSlaveMode</span><span class="params">(TIM_TypeDef* TIMx, <span class="keyword">uint16_t</span> TIM_SlaveMode)</span></span>;</span><br></pre></td></tr></table></figure>

<h5 id="单独配置通道1、2、3、4的分频器函数"><a href="#单独配置通道1、2、3、4的分频器函数" class="headerlink" title="单独配置通道1、2、3、4的分频器函数"></a>单独配置通道1、2、3、4的分频器函数</h5><p>在参数结构体里也可以配置</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM_SetIC1Prescaler</span><span class="params">(TIM_TypeDef* TIMx, <span class="keyword">uint16_t</span> TIM_ICPSC)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM_SetIC2Prescaler</span><span class="params">(TIM_TypeDef* TIMx, <span class="keyword">uint16_t</span> TIM_ICPSC)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM_SetIC3Prescaler</span><span class="params">(TIM_TypeDef* TIMx, <span class="keyword">uint16_t</span> TIM_ICPSC)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM_SetIC4Prescaler</span><span class="params">(TIM_TypeDef* TIMx, <span class="keyword">uint16_t</span> TIM_ICPSC)</span></span>;</span><br></pre></td></tr></table></figure>

<h5 id="读取四个通道的CCR函数"><a href="#读取四个通道的CCR函数" class="headerlink" title="读取四个通道的CCR函数"></a>读取四个通道的CCR函数</h5><p>输出比较模式下，CCR是只写的，要用SetCompare写入，输入捕获模式下，CCR是只读的，要用GetCapture读出</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">uint16_t</span> <span class="title">TIM_GetCapture1</span><span class="params">(TIM_TypeDef* TIMx)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">uint16_t</span> <span class="title">TIM_GetCapture2</span><span class="params">(TIM_TypeDef* TIMx)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">uint16_t</span> <span class="title">TIM_GetCapture3</span><span class="params">(TIM_TypeDef* TIMx)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">uint16_t</span> <span class="title">TIM_GetCapture4</span><span class="params">(TIM_TypeDef* TIMx)</span></span>;</span><br></pre></td></tr></table></figure>

<p>PWMI模式程序示例</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">IC_Init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3, ENABLE);</span><br><span class="line">	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);</span><br><span class="line">	</span><br><span class="line">	GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;</span><br><span class="line">	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6;</span><br><span class="line">	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">	GPIO_Init(GPIOA, &amp;GPIO_InitStructure);</span><br><span class="line">	</span><br><span class="line">	TIM_InternalClockConfig(TIM3);</span><br><span class="line">	</span><br><span class="line">	TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;</span><br><span class="line">	TIM_TimeBaseInitStructure.TIM_ClockDivision = TIM_CKD_DIV1;</span><br><span class="line">	TIM_TimeBaseInitStructure.TIM_CounterMode = TIM_CounterMode_Up;</span><br><span class="line">	TIM_TimeBaseInitStructure.TIM_Period = <span class="number">65536</span> - <span class="number">1</span>;		<span class="comment">//ARR</span></span><br><span class="line">	TIM_TimeBaseInitStructure.TIM_Prescaler = <span class="number">72</span> - <span class="number">1</span>;		<span class="comment">//PSC</span></span><br><span class="line">	TIM_TimeBaseInitStructure.TIM_RepetitionCounter = <span class="number">0</span>;</span><br><span class="line">	TIM_TimeBaseInit(TIM3, &amp;TIM_TimeBaseInitStructure);</span><br><span class="line">	</span><br><span class="line">	TIM_ICInitTypeDef TIM_ICInitStructure;</span><br><span class="line">	TIM_ICInitStructure.TIM_Channel = TIM_Channel_1;</span><br><span class="line">	TIM_ICInitStructure.TIM_ICFilter = <span class="number">0xF</span>;</span><br><span class="line">	TIM_ICInitStructure.TIM_ICPolarity = TIM_ICPolarity_Rising;</span><br><span class="line">	TIM_ICInitStructure.TIM_ICPrescaler = TIM_ICPSC_DIV1;</span><br><span class="line">	TIM_ICInitStructure.TIM_ICSelection = TIM_ICSelection_DirectTI;<span class="comment">//直接模式</span></span><br><span class="line">	TIM_PWMIConfig(TIM3, &amp;TIM_ICInitStructure);<span class="comment">//另一个通道选择相反的配置</span></span><br><span class="line"></span><br><span class="line">	TIM_SelectInputTrigger(TIM3, TIM_TS_TI1FP1);<span class="comment">//选择触发源</span></span><br><span class="line">	TIM_SelectSlaveMode(TIM3, TIM_SlaveMode_Reset);<span class="comment">//选择从模式</span></span><br><span class="line">	</span><br><span class="line">	TIM_Cmd(TIM3, ENABLE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">IC_GetFreq</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1000000</span> / (TIM_GetCapture1(TIM3) + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">IC_GetDuty</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (TIM_GetCapture2(TIM3) + <span class="number">1</span>) * <span class="number">100</span> / (TIM_GetCapture1(TIM3) + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="编码器接口"><a href="#编码器接口" class="headerlink" title="编码器接口"></a>编码器接口</h3><p>Encoder Interface编码器接口</p>
<p>编码器接口可接收增量（正交）编码器的信号，根据编码器旋转产生的正交信号脉冲，自动控制CNT自增或自减，从而指示编码器的位置、旋转方向和旋转速度</p>
<p>每个高级定时器和通用定时器都拥有1个编码器接口</p>
<p>两个输入引脚借用了输入捕获的通道1和通道2</p>
<p>对于需要频繁执行，操作简单的任务，一般会设计一个硬件模块来自动完成</p>
<p>把两个编码器的A相和B相，接入STM32，定时器的编码器接口，编码器接口自动控制时基单元中的CNT计数器，进行自增或者自减，例如CNT初始值为0，编码器右转CNT++，右转产生一个脉冲，CNT++,左转CNT–，编码器接口（相当于带有方向控制的外部时钟）同时控制CNT的计数时钟和计数方向，CNT的值就表示了编码器的位置，每隔一段时间取一次CNT的值再把CNT清零，每次取出来的值就带标 了编码器的速度，编码器的测速实际上就是测频法测正交脉冲的频率，CNT计次，每隔一段时间取一次计次，也可以用外部中断来接编码器（用软件资源来弥补硬件资源）</p>
<p><img src="https://gitee.com/pu-heliang/photos/raw/master/img/202301032045516.png" alt="image-20221226224551844"></p>
<p>当编码器的旋转轴转起来时，A相和B相就会输出方波信号，转的越快，方波的频率越高，方波的频率就代表了速度，取出任意一相的信号来测量频率，就能知道旋转速度，只有一相的信号无确定旋转方向。</p>
<p>正交信号：当正转时，A相超前B相90度，反转时，A相滞后B相90度。</p>
<p>正转时，第一个时刻，A相上升沿，对应B此时是低电平，第二个时刻，B相上升沿，对应A相高电平，第三个时刻，A相下降沿，对应B相高电平，B相下降沿，对应A相低电平。</p>
<p>反转时，第一个时刻，B相上升沿，对应A相低电平，第二个时刻A相上升沿，对应B相高电平，第三个时刻，B相下降沿，对应A相高电平，第四个时刻，A相下降沿，对应B相低电平。</p>
<p>当A、B相出现这些边沿时，对应另一相的状态，正转和反转正好是相反的</p>
<p>编码器接口的设计逻辑是：首先把A相和B相的所有边沿作为计数器的计数时钟，出现边沿信号时，就计数自增或者自减，</p>
<p><img src="https://gitee.com/pu-heliang/photos/raw/master/img/202301032045627.png" alt="image-20221226225908098"></p>
<p>编码器接口的两个引脚，借用了输入捕获单元的前两个通道，编码器的输入引脚就是定时器的CH1和CH2两个引脚，信号的通路就是，CH1通过这里，通向编码器接口，CH3和CH4和编码器接口无关，其中CH1和CH2的输入捕获滤波器和边沿检测，编码器接口也有使用，但是后面的是否交叉，预分频器和CCR寄存器，与编码器接口无关，这就是编码器接口的输入部分，编码器接口的输出部分，相当于从模式控制器，控制CNT的计数时钟和计数方向，输出过程就是如果产生边沿信号，并且对应另一相的状态为正转，则控制CNT自增否则控制CNT自减，此时计数时钟和计数方向都处于编码器接口托管的状态，计数器的自增和自减，受编码器的控制。</p>
<p>编码器接口的基本结构：</p>
<p><img src="https://gitee.com/pu-heliang/photos/raw/master/img/202301032046598.png" alt="image-20221226230733071"></p>
<p>输入捕获的前两个通道，通过GPIO口接入编码器的A、B相然后通过滤波器和边沿检测极性选择，产生TI1TP1和TI2FP2，通向编码器接口，编码器接口通过控制预分频器控制CNT计数器的时钟，同时，编码器接口还根据编码器的旋转方向，控制CNT的计数方向，编码器正转时，CNT自增，编码器反转时，CNT自减，一般设置ARR为65535，最大量程</p>
<p>工作模式：</p>
<p><img src="https://gitee.com/pu-heliang/photos/raw/master/img/202301032046208.png" alt="image-20221226231231784"></p>
<p>编码器接口的工作逻辑：TI1FP1和TI2FP2接的就是编码器的A、B相，在A相和B相的上升沿或者下降沿触发计数，向上计数还是向下计数取决于边沿信号发生时，另一相的电平状态（相对信号的电平）</p>
<p>配置流程：</p>
<p>第一步，RCC开启时钟，开启GPIO和定时器的时钟</p>
<p>第二步，配置GPIO，配置为输入模式</p>
<p>第三步，配置时基单元，预分频器选择不分频，自动重装，一般给最大65535</p>
<p>第四步，配置输入捕获单元，只需要配置滤波器和极性两个参数</p>
<p>第五步，配置编码器接口模式，调用一个库函数即可</p>
<p>第六步，调用TIM_cmd启动定时器</p>
<p>如果需要测量编码器的速度：每隔一段固定的闸门时间，取出一次CNT，然后把CNT清零</p>
<h5 id="定时器编码器接口配置函数"><a href="#定时器编码器接口配置函数" class="headerlink" title="定时器编码器接口配置函数"></a>定时器编码器接口配置函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM_EncoderInterfaceConfig</span><span class="params">(TIM_TypeDef* TIMx, <span class="keyword">uint16_t</span> TIM_EncoderMode,</span></span></span><br><span class="line"><span class="params"><span class="function">                                <span class="keyword">uint16_t</span> TIM_IC1Polarity, <span class="keyword">uint16_t</span> TIM_IC2Polarity)</span></span>;</span><br></pre></td></tr></table></figure>

<p>配置上拉输入还是下拉输入：看外部模块输出的默认电平，与外部模块输出的默认电平相同，防止默认电平打架，如果不确定外部模块输出的默认状态，或者外部信号输出功率非常小，尽量选择浮空输入</p>
<h4 id="编码器接口程序示例"><a href="#编码器接口程序示例" class="headerlink" title="编码器接口程序示例"></a>编码器接口程序示例</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Encoder_Init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3, ENABLE);</span><br><span class="line">	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);</span><br><span class="line">	</span><br><span class="line">	GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;</span><br><span class="line">	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6 | GPIO_Pin_7;</span><br><span class="line">	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">	GPIO_Init(GPIOA, &amp;GPIO_InitStructure);</span><br><span class="line">		</span><br><span class="line">	TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;</span><br><span class="line">	TIM_TimeBaseInitStructure.TIM_ClockDivision = TIM_CKD_DIV1;</span><br><span class="line">	TIM_TimeBaseInitStructure.TIM_CounterMode = TIM_CounterMode_Up;</span><br><span class="line">	TIM_TimeBaseInitStructure.TIM_Period = <span class="number">65536</span> - <span class="number">1</span>;		<span class="comment">//ARR</span></span><br><span class="line">	TIM_TimeBaseInitStructure.TIM_Prescaler = <span class="number">1</span> - <span class="number">1</span>;		<span class="comment">//PSC</span></span><br><span class="line">	TIM_TimeBaseInitStructure.TIM_RepetitionCounter = <span class="number">0</span>;</span><br><span class="line">	TIM_TimeBaseInit(TIM3, &amp;TIM_TimeBaseInitStructure);</span><br><span class="line">	</span><br><span class="line">	TIM_ICInitTypeDef TIM_ICInitStructure;</span><br><span class="line">	TIM_ICStructInit(&amp;TIM_ICInitStructure);</span><br><span class="line">	TIM_ICInitStructure.TIM_Channel = TIM_Channel_1;</span><br><span class="line">	TIM_ICInitStructure.TIM_ICFilter = <span class="number">0xF</span>;</span><br><span class="line">	TIM_ICInit(TIM3, &amp;TIM_ICInitStructure);</span><br><span class="line">	TIM_ICInitStructure.TIM_Channel = TIM_Channel_2;</span><br><span class="line">	TIM_ICInitStructure.TIM_ICFilter = <span class="number">0xF</span>;</span><br><span class="line">	TIM_ICInit(TIM3, &amp;TIM_ICInitStructure);</span><br><span class="line">	</span><br><span class="line">	TIM_EncoderInterfaceConfig(TIM3, TIM_EncoderMode_TI12, TIM_ICPolarity_Rising, TIM_ICPolarity_Rising);<span class="comment">//编码器电机模式</span></span><br><span class="line">	</span><br><span class="line">	TIM_Cmd(TIM3, ENABLE);<span class="comment">//开启定时器</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int16_t</span> <span class="title">Encoder_Get</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int16_t</span> Temp;</span><br><span class="line">	Temp = TIM_GetCounter(TIM3);<span class="comment">//获取CNT的值</span></span><br><span class="line">	TIM_SetCounter(TIM3, <span class="number">0</span>);<span class="comment">//设置CNT的值</span></span><br><span class="line">	<span class="keyword">return</span> Temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="ADC模拟数字转换器"><a href="#ADC模拟数字转换器" class="headerlink" title="ADC模拟数字转换器"></a>ADC模拟数字转换器</h3><p>ADC（Analog-Digital Converter）模拟-数字转换器</p>
<p>ADC可以将引脚上连续变换的模拟量转换成内存中储存的数字变量，建立模拟电路到数字电路的桥梁，ADC读取引脚上的模拟电压，转换为一个数据，存在寄存器里，再把这个数据读取到变量里来，就可以进行显示、判断、记录等操作</p>
<p>12位（分辨率，位数越高，量化结果就越精细，对应分辨率就越高）逐次逼近型ADC，1us转换时间（转换频率），</p>
<p>输入电压范围：0-3.3V，转换结果范围：0~4095，ADC的输入电压要求在芯片的负极和正极之间变化，最低电压是负极0V，最高电压是正极3.3V，经过ADC转换之后最小值是0，最大值是4095，0V对应0,3.3V对应4095，中间都是一一对应的线性关系。</p>
<p>18个输入通道，可测量16个外部和2个内部信号源，外部信号源就是16个GPIO口，在引脚上直接模拟信号就行了，不需要任何的额外电路引脚就能直接测电压，2个内部信号源是内部温度传感器和内部参考电压，温度传感器可以测量CPU的温度，内部参考电压是一个1.2V左右的基准电压，这个基准电压不随外部供电电压变化而变化，如果芯片的供电不是标准的3.3V测量外部引脚的电压就可能不对，这时可以读取基准电压进行校准，这样就可以得到正确的电压值了。</p>
<p>规则组和注入组两个转换单元，这个是STM32 ADC的增强功能，普通AD转换流程是，启动一次转换，读一次值，然后再启动，在读值，这样的流程，但是STM32的ADC可以列一个组，连续转换多个值，一次性启动一个组，连续转换多个值，并且有两个组，一个是用于常规使用的规则组，一个是用于突发事件的注入组。</p>
<p>模拟看门狗自动检测输入电压范围，此ADC一般可以用于测量光线强度、温度，经常会要求光线高于某个阈值、低于某个阈值，或者温度高于某个阈值，低于某个阈值时，执行一些操作，高于某个阈值，低于某个阈值的判断，就可以用模拟看门狗来自动执行，模拟看门狗可以检测指定的某些通道，当AD值高于它设定的上阈值或者下阈值时，就会申请中断，就可以在中断函数中执行相应的操作，这样就不用手动读值，再用if判断了</p>
<p>STM32F103C8T6 ADC资源：ADC1、ADC2,10个外部输入通道，最多只能测量10个外部引脚的模拟信号</p>
<h5 id="逐次逼近型ADC的内部结构"><a href="#逐次逼近型ADC的内部结构" class="headerlink" title="逐次逼近型ADC的内部结构"></a>逐次逼近型ADC的内部结构</h5><p><img src="https://gitee.com/pu-heliang/photos/raw/master/img/202301032046412.png" alt="image-20221228125552084"></p>
<p>这个图是ADC0809的内部结构图，它是一个独立的8位逐次 逼近型ADC芯片，左边IN0~到IN7，是8路输入通道，通过通道选择开关，选中一路，输入到比较器上方进行转换，下面部分是地址锁存和译码，就是想选中哪一路，就把通道号放在这三个引脚上，然后给一个锁存信号，上面对应的通路开关就自动拨好了，相当于可以通过模拟信号的数据选择器，因为ADC转换是一个非常快的过程，给个开始信号，过个几个us就转换完成了想转换多路信号，那不必设计多个AD转换器，只需要一个AD转换器，然后加一个多路选择开关，想转换哪一路，选中对应通道，然后再开始转换就行了，这就是输入通道选择的部分，这个ADC0809只有8个输入通道，STM32内部的ADC是有18个输入通道，对应的是18路输入的多路开关，输入信号选好后，到电压比较器，它可以判断两个输入信号电压的大小关系，输出一个高低电平指示谁大谁小，它的两个输入端，一个是待测的电压，另一个是DAC的电压输出端，DAC是数模转换器，给一个数据，就可以输出数据对应的电压，DAC内部是适应加权电阻网络来实现的转换，将外部输入的未知的电压和一个已知输出的电压，两个同时输入到电压比较器，进行大小判断，如果DAC输出的电压比较大，就调小DAC数据，如果DAC输出的电压比较小，就增大DAC数据，直到DAC输出的电压和外部通道输入的电压近似相等，这样DAC输入的数据就是外部电压的编码数据了，这就是DAC的实现原理，电压调节的过程是逐次逼近SAR来完成的，为了最快找到未知电压的编码，通常会使用二分法进行寻找，EOC（End Of Convert）是转换结束信号，START是开始转换，给一个输入脉冲，开始转换，CLOCK是ADC时钟，因为ADC内部是一步一步进行判断的，所以需要时钟来推动这个过程，下面VREF+和VREF-是DAC的参考电压，例如给一个数据255，是对应5V还是3.3V就由参考电压决定，这个DAC的参考电压也决定了，ADC的输入范围，所以他也是ADC参考电压，左边是整个芯片电路的供电，VCC和GND，通常参考电压的VCC是一样的，会接在一起，参考电压的负极和GND也是一样的，也接到一起，一般情况下ADC输入电压的范围就和ADC的供电是一样的。</p>
<h5 id="STM32的ADC："><a href="#STM32的ADC：" class="headerlink" title="STM32的ADC："></a>STM32的ADC：</h5><p><img src="https://gitee.com/pu-heliang/photos/raw/master/img/202301032046864.png" alt="image-20221228131906698"></p>
<p>左边是ADC的输入通道、包括16个GPIO口，IN0~IN15，和两个内部的通道，一个是内部温度传感器，另一个是VREFINT（V Reference Internal），内部参考电压，总共是18个输入通道，然后到达模拟多路开关，可以指定想要的通道，右边是多路开关的输出，进入到模数转换器，转化结果会放在数据寄存器中，读取寄存器就能知道ADC转换的结果了，对于普通的ADC，多路开关一般都是只选中一个的，就是选中某个通道、开始转换、等待转换完成、取出结果，这是普通的流程，但是STM32就可以同时选中多个，在转换的时候，还分成了两个组，规则通道组和注入通道组，规则组可以一次最多选中16个通道，注入组最多可以选中4个通道，就像是去餐厅点菜，普通的ADC是，你指定一个菜，老板给你做，然后做好了送给你，而这里是，你指定一个菜单，这个菜单最多可以填16个菜，然后直接递个菜单给老板，老板就按照菜单的顺序依次做好，一次性给你端上来，这样的话就可以大大提高效率，当然菜单也可以只写一个菜，这样这个菜单就简化成普通模式了，对于这个菜单也有两种，一种是规则组菜单，可以同时上16个菜，但是规则组只有一个数据寄存器，就是桌子比较小，最多只能放一个菜，如果上16个菜，前15个菜都会被挤掉，只能的到第16个菜，所以对于规则组转换来说，如果使用这个菜单的话，最好配合DMA来实现，DMA是一个数据转运小帮手，它可以在每上一个菜之后，把这个菜挪到其他地方去，防止被覆盖，规则组虽然可以同时转换16个通道，但是数据寄存器只能存一个结果，如果不想之前的结果被覆盖，那在转换完成之后，就要尽快把结果拿走，注入组，相当于是餐厅的VIP座位，在这个座位上一次最多可以点4个菜，并且数据寄存器有4个可以同时上4个菜，对于注入组而言，就不用担心数据覆盖的问题了，这就是规则组和注入组的介绍，一般情况下，使用规则组就足够了，如果要使用规则组的菜单，那就配合DMA转运数据，这样就不用担心数据覆盖的问题了。</p>
<p>对于规则组，左下角是触发的部分，对于STM32的ADC触发开始转换的信号有两种，一种是软件触发，就是在程序中手动调用一条代码，就可以启动转换了，另一种是硬件触发，就是触发源，触发源主要是来自定时器，有定时器的各个通道，还有TRGO定时器主模式的输出，（定时器可以通向ADC、DAC这些外设，用于触发转换），ADC经常需要过一个固定时间段转换一次，比如每隔1ms转换一次，正常的思路就是，用定时器，每隔1ms申请一次中断，在中断里手动开启一次中断，这样也是可以的，但是频繁进中断对程序是有一定影响的，如果有很多中断都需要频繁进入，那将会影响主程序的执行，并且不同中断之间，由于优先级的不同，也会导致某些中断不能及时的到响应，如果触发ADC的中断不能及时响应，那ADC的转换频率就会产生影响，所以对于需要频繁进中断，并且只在中断里只完成了简单的工作的情况，一般都会有硬件的支持，可以给TIM3定一个1ms的时间，把TIM3的更新事件选择为TRGO输出，然后再ADC这里，选择触发信号TIM3的的TRGO，这样TIM3的更新事件就能通过硬件自动触发ADC转换了，整个过程不需要进中断，节省了中断资源，这就是定时器触发的作用，也可以选择外部中断引脚来触发中断，都可以在程序中配置，左上角是VREF+、VREF-、VDDA和VSSA，VREF+、VREF-这两个是ADC的参考电压，决定了ADC输入电压的范围，VDDA和VSSA是ADC的供电引脚，一般情况下VREF+要接VDDA，VREF-要接VSSA，STM32没有VREF+、VREF-的引脚内内部已经和VDDA和VSSA接在一起了。VDDA和VSSA是内部模拟部分的电源，例如ADC、RC震荡器、锁相环等，在STM32中VDDA接3.3V，VSSA接GND，所以输入电压的范围就是0~3.3V，右边的ADCCLK是ADC的时钟，也就是ADC0809中的CLOCK，是用于驱动内部逐次比较的时钟来自ADC预分频器，ADC预分频器来源于RCC，APB2时钟72MHz，然后通过ADC进行分频，得到ADCCLK，ADCCLK最大是14MHz，对于ADC预分频器，只能选择6分频，结果是12MHz和8分频结果是9MHz，上面的是DMA请求，用于触发DMA进行数据转运，再上面是两个数据寄存器，用于存放转换结果，在上面是模拟看门狗，它们可以存一个阈值高限和阈值低限，如果启动了模拟开门狗，并且指定了看门的通道，那么看门狗就会关注它看门的通道，一但超过这个阈值范围，就会乱叫，就会在上面申请一个模拟看门狗的中断，最后通向NVIC，对于规则组和注入组，它们转换完成后，也会有一个EOC转换完成的信号，EOC是规则组完成的信号，JEOC是注入组完成的信号，这两个信号会在状态寄存器置一个标志位，读取这个标志位，就能知道是不是转换结束了，同时这两个标志位也可以去到NVIC，申请中断，如果开启了NVIC对应的通道，它们就会触发中断。</p>
<h5 id="ADC基本结构"><a href="#ADC基本结构" class="headerlink" title="ADC基本结构"></a>ADC基本结构</h5><p><img src="https://gitee.com/pu-heliang/photos/raw/master/img/202301032046518.png" alt="image-20221228141007759"></p>
<p>左边是输入通道，16个GPIO口，外加两个内部的通道，然后进入AD转换器，AD转换器里有两个组，一个是规则组，一个是注入组，规则组最多可以选择16个通道，注入组最多可以选择4个通道，转换的结果有放在AD数据寄存器中，其中规则组只有1个数据寄存器，注入组有4个数据寄存器，下面是触发控制，提供开始转换的的START信号，触发控制可以选择软件触发和硬件触发，硬件触发主要是来自于定时器，当然也可以选择外部中断的引脚，右边是来自RCC的ADC时钟CLOCK，ADC逐次比较的过程就是由此时钟推动，上面可以布置一个模拟看门狗用于检测转换的结果的范围，如果超出设定的阈值，就通过中断输出控制，向NVIC申请中断，规则组和注入组在转换完成后会有个EOC信号，会置一个标志位，也可以通向NVIC，右下角是开关控制，在库函数中，就是ADC_Cmd函数，用于ADC上电的。</p>
<h5 id="输入通道："><a href="#输入通道：" class="headerlink" title="输入通道："></a>输入通道：</h5><p><img src="https://gitee.com/pu-heliang/photos/raw/master/img/202301032046469.png" alt="image-20221228141929856"></p>
<p>双ADC模式：就是ADC1和ADC2一起工作，可以配合组成同步模式，交叉模式等等模式，交叉模式就是ADC1和ADC2交叉的对一个通道进行采样，这样可以提高采样率。</p>
<h5 id="规则组的四种转换模式"><a href="#规则组的四种转换模式" class="headerlink" title="规则组的四种转换模式"></a>规则组的四种转换模式</h5><h5 id="单次转换、非扫描模式"><a href="#单次转换、非扫描模式" class="headerlink" title="单次转换、非扫描模式"></a>单次转换、非扫描模式</h5><p><img src="https://gitee.com/pu-heliang/photos/raw/master/img/202301032046631.png"></p>
<p>在非扫描模式下，这个菜单只有第一个序列1的位置有效，这时菜单同时选择一组的方式就退化成简单的选中一个的方式了，我们可以在序列1的位置指定我们想转换的通道，比如通道2，然后就可以触发转换，ADC就会对这个通道2进行模数转换，过一小段时间后，转换完成，转换结果放在数据寄存器里，同时给EOC标志位置1，整个转换过程就结束了。判断这个标志位，如果转换完了，就可以在数据寄存器中读取结果了。如果想再启动一次转换，那就需要再触发一次。转换结束，置EOC标志位，读结果。如果想换一个通道转换，那在转换之前，把第一个位置通道2改成其他通道，然后再启动转换。</p>
<h5 id="连续转换、非扫描模式"><a href="#连续转换、非扫描模式" class="headerlink" title="连续转换、非扫描模式"></a>连续转换、非扫描模式</h5><p><img src="https://gitee.com/pu-heliang/photos/raw/master/img/202301032046752.png" alt="image-20221228143332282"></p>
<p>非扫描模式，所以菜单列表就只用第一个，与上次单次转换不同的是，它在一次转换结束后不会停止，而是立刻开始下一轮转换，然后一直持续下去，这样就只需要触发一次，之后就可以一直转换了。这个模式的好处就是，开始转换之后不需要等待一段时间，它一直都在转换，不需要手动开启转换了。也不用判断是否结束，想要读AD值的时候，就直接从数据寄存器取就行。</p>
<h5 id="单次转换、扫描模式"><a href="#单次转换、扫描模式" class="headerlink" title="单次转换、扫描模式"></a>单次转换、扫描模式</h5><p><img src="https://gitee.com/pu-heliang/photos/raw/master/img/202301032048367.png" alt="image-20221228172651369"></p>
<p>这个模式也是单次转换，所以每触发一次，转换结束后，就会停下来，下次转换就得再触发才能开始，他是扫描模式，这就会用到这个菜单列表了，可以在菜单里点菜，比如第一个菜是通道2，第二个菜是通道5，等等，这里每个位置是通道几可以任意指定，并且也是可以重复的，初始化结构体里还有个参数，就是通道数目，因为这16个位置可以不用完，只用前几个，那就需要再给个通道数目的参数，告诉他，我有几个通道，这里指定通道7，那它就只看前7个位置，然后每次触发之后，它就依次对前7个位置进行AD转换，转换结果都放在数据寄存器中，为了防止数据被覆盖，就需要用DMA及时将数据挪走，7个通道转换完成后，产生EOC信号，转换结束，然后再触发下一次，就又开始新一轮的转换，这就是单次转换，扫描模式的工作流程。</p>
<h5 id="连续转换、扫描模式"><a href="#连续转换、扫描模式" class="headerlink" title="连续转换、扫描模式"></a>连续转换、扫描模式</h5><p><img src="https://gitee.com/pu-heliang/photos/raw/master/img/202301032048094.png" alt="image-20221228173637254"></p>
<p>在上一次模式的基础上，可以在一次转换完成后，立刻开始下一次的转换。在扫描模式的情况下，还可以右边一种模式，叫间断模式，它的作用是，在扫描的过程中，每隔几个转换，就暂停一次，需要再次触发，才能继续</p>
<h5 id="触发控制："><a href="#触发控制：" class="headerlink" title="触发控制："></a>触发控制：</h5><p><img src="https://gitee.com/pu-heliang/photos/raw/master/img/202301032048244.png" alt="image-20221228173918884"></p>
<p>这个表就是规则组的触发源，在这个表里有来自定时器的信号，还有来自引脚或者定时器的信号，具体是引脚还是定时器，需要AFIO重映射来确定，最后是软件控制位，也就是软件触发，这些触发信号可以配置右边的寄存器来完成，库函数直接给一个参数就行。</p>
<h5 id="数据对齐"><a href="#数据对齐" class="headerlink" title="数据对齐"></a>数据对齐</h5><p><img src="https://gitee.com/pu-heliang/photos/raw/master/img/202301032048436.png" alt="image-20221228174146250"></p>
<p>这个ADC是12位的，它的转换结果就是一个12位的数据，但是这个数据寄存器是16位的，所以就存在一个数据对齐的问题，分为两种对齐方式，数据右对齐，和数据左对齐，数据右对齐就是12位的数据向右靠，高位多出来的几位就补0，第二种是数据左对齐，是12位的数据向左靠，低位多出来的几位就补0，我们一般使用的都是数据右对齐，这样读取这个16位寄存器，直接就是转换结果，如果选择左对齐，直接读的话，得到的数据会比实际的大，因为数据左对齐实际上就是把数据左移了4次，二进制的数据，数据左移一次，就等效于把这个数据乘2，左移4次，就相等于把结果乘16了，所以直接读会比实际值大16倍，左对齐的作用就是，不需要高分辨率时，就可以选择左对齐再把后面的低4位去掉，这个12位的ADC就退化成8位的ADC了。</p>
<h5 id="转换时间"><a href="#转换时间" class="headerlink" title="转换时间"></a>转换时间</h5><p>AD转换的步骤：采样，保持，量化，编码</p>
<p>STM32 ADC的总转换时间为：Tconv = 采样时间（采样保持花费的时间，采样时间越大，越能避免一些毛刺信号的干扰）+12.5个ADC周期（量化编码花费的时间）</p>
<p>例如：当ADCCLK = 14MHz，采样时间为1.5个ADC周期，Tconv = 1.5 + 12.5 = 14个ADC周期 = 1us</p>
<h5 id="校准"><a href="#校准" class="headerlink" title="校准"></a>校准</h5><p>ADC有一个内置自校准模式。校准可大幅减小因内部电容器组的变化而造成的准精度误差。校准期间，在每个电容器上都会计算出一个误差修正值（数字值），这个码用于消除在随后的转换中每个电容器上产生的误差</p>
<p>建议在每次上电后执行一次校准</p>
<p>启动校准前，ADC必须处于关电状态超过至少两个ADC时钟周期。</p>
<p>只需要在ADC初始化最后加几条代码即可</p>
<h5 id="硬件电路"><a href="#硬件电路" class="headerlink" title="硬件电路"></a>硬件电路</h5><p><img src="https://gitee.com/pu-heliang/photos/raw/master/img/202301032048081.png" alt="image-20221228175818636"></p>
<p>电位器的两个固定端，一端接3.3V，另一端接GND，这样中间的滑动端就可以输出一个0~3.3V可调的电压输出了，这里可以接ADC的输入通道例如PA0口，当滑动端往上滑时，电压增大，往下滑时，电压减小，电阻的阻值不能给太小，因为它是直接接在电源正负极上的，阻值太小，这个电阻就会很费电，再小可能就发热冒烟了，一般要接K欧级的电阻</p>
<p>中间是传感器输出电压的电路，一般来说，光敏电阻、热敏电阻、红外接收管、麦克风都可以等效为一个可变电阻，电阻阻值没法直接测量，可以通过和一个固定电阻串联分压，来得到一个反应电阻值电压的电路，传感器阻值变小，下拉作用变强，输出端电压就下降，传感器阻值变大时，下拉作用变弱，输出端受上拉电阻的作用，电压就会升高。固定电阻一般选择和传感器电阻相近的电容，这样可以得到一个位于中间电压区域比较好的输出</p>
<p>右边的电路是一个简单的电压转换电路，如果我想测量一个0<del>5V的VIN电压但是ADC只能接收0</del>3.3V的电压，那就可以搭建一个简易转换电路，使用电阻进行分压，上面阻值17K，下面组织33K，加一起是50K，中间的电压就是3.3V，就可以进入ADC转换了，这就是简单的电压转换电路</p>
<h5 id="ADC初始化步骤"><a href="#ADC初始化步骤" class="headerlink" title="ADC初始化步骤"></a>ADC初始化步骤</h5><p><img src="https://gitee.com/pu-heliang/photos/raw/master/img/202301032048997.png" alt="image-20221228184655915"></p>
<p>第一步，开启RCC时钟，包括ADC和GPIO的时钟，ADCCLK的分频器，也需要配置一下</p>
<p>第二步，配置GPIO，把需要用到的GPIO口配置成模拟输入的模式</p>
<p>第三步，配置多路开关，把左边的通道接入到右边的规则组列表中</p>
<p>第四步，配置ADC转换器，在库函数里，用结构体来配置，配置这一大块电路的参数</p>
<p>第五步，调用ADC_Cmd开启ADC，也可以进行一下校准，减小误差</p>
<p>想要软件触发转换，会有函数可以触发，如果想读取结果也会有函数可以读取结果</p>
<h5 id="ADCCLK的配置函数"><a href="#ADCCLK的配置函数" class="headerlink" title="ADCCLK的配置函数"></a>ADCCLK的配置函数</h5><p>可以对APB2的72MHz时钟选择2、4、6、8分频，输入到ADCCLK</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RCC_ADCCLKConfig</span><span class="params">(<span class="keyword">uint32_t</span> RCC_PCLK2)</span></span></span><br></pre></td></tr></table></figure>

<h5 id="恢复缺省配置函数-1"><a href="#恢复缺省配置函数-1" class="headerlink" title="恢复缺省配置函数"></a>恢复缺省配置函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ADC_DeInit</span><span class="params">(ADC_TypeDef* ADCx)</span></span>;</span><br></pre></td></tr></table></figure>

<h5 id="Init初始化函数"><a href="#Init初始化函数" class="headerlink" title="Init初始化函数"></a>Init初始化函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ADC_Init</span><span class="params">(ADC_TypeDef* ADCx, ADC_InitTypeDef* ADC_InitStruct)</span></span>;</span><br></pre></td></tr></table></figure>

<h5 id="StructInit结构体初始化函数"><a href="#StructInit结构体初始化函数" class="headerlink" title="StructInit结构体初始化函数"></a>StructInit结构体初始化函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ADC_StructInit</span><span class="params">(ADC_InitTypeDef* ADC_InitStruct)</span></span>;</span><br></pre></td></tr></table></figure>

<h5 id="给ADC上电的函数"><a href="#给ADC上电的函数" class="headerlink" title="给ADC上电的函数"></a>给ADC上电的函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ADC_Cmd</span><span class="params">(ADC_TypeDef* ADCx, FunctionalState NewState)</span></span>;</span><br></pre></td></tr></table></figure>

<h5 id="开启DMA输出信号函数"><a href="#开启DMA输出信号函数" class="headerlink" title="开启DMA输出信号函数"></a>开启DMA输出信号函数</h5><p>使用DMA转运数据，就得调用这个函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ADC_DMACmd</span><span class="params">(ADC_TypeDef* ADCx, FunctionalState NewState)</span></span>;</span><br></pre></td></tr></table></figure>

<h5 id="中断输出控制函数"><a href="#中断输出控制函数" class="headerlink" title="中断输出控制函数"></a>中断输出控制函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ADC_ITConfig</span><span class="params">(ADC_TypeDef* ADCx, <span class="keyword">uint16_t</span> ADC_IT, FunctionalState NewState)</span></span>;</span><br></pre></td></tr></table></figure>

<h5 id="复位校准函数"><a href="#复位校准函数" class="headerlink" title="复位校准函数"></a>复位校准函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ADC_ResetCalibration</span><span class="params">(ADC_TypeDef* ADCx)</span></span>;</span><br></pre></td></tr></table></figure>

<h5 id="获取复位校准状态函数"><a href="#获取复位校准状态函数" class="headerlink" title="获取复位校准状态函数"></a>获取复位校准状态函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">FlagStatus <span class="title">ADC_GetResetCalibrationStatus</span><span class="params">(ADC_TypeDef* ADCx)</span></span>;</span><br></pre></td></tr></table></figure>

<h5 id="开始校准函数"><a href="#开始校准函数" class="headerlink" title="开始校准函数"></a>开始校准函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ADC_StartCalibration</span><span class="params">(ADC_TypeDef* ADCx)</span></span>;</span><br></pre></td></tr></table></figure>

<h5 id="获取开始校准状态函数"><a href="#获取开始校准状态函数" class="headerlink" title="获取开始校准状态函数"></a>获取开始校准状态函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">FlagStatus <span class="title">ADC_GetCalibrationStatus</span><span class="params">(ADC_TypeDef* ADCx)</span></span>;</span><br></pre></td></tr></table></figure>

<h5 id="软件触发ADC的函数"><a href="#软件触发ADC的函数" class="headerlink" title="软件触发ADC的函数"></a>软件触发ADC的函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ADC_SoftwareStartConvCmd</span><span class="params">(ADC_TypeDef* ADCx, FunctionalState NewState)</span></span>;</span><br></pre></td></tr></table></figure>

<h5 id="ADC获取软件开始转换状态函数（没啥用）"><a href="#ADC获取软件开始转换状态函数（没啥用）" class="headerlink" title="ADC获取软件开始转换状态函数（没啥用）"></a>ADC获取软件开始转换状态函数（没啥用）</h5><p>获取CR2的SWSTART这一位，给SWTART置1，以开始转换，这个函数是返回SWSTART的状态，由于SWSTART位在转换开始后立刻就清0了，所以这个函数的返回值跟转换是否结束，毫无关系</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">FlagStatus <span class="title">ADC_GetSoftwareStartConvStatus</span><span class="params">(ADC_TypeDef* ADCx)</span></span>;</span><br></pre></td></tr></table></figure>

<h5 id="获取转换是否结束函数"><a href="#获取转换是否结束函数" class="headerlink" title="获取转换是否结束函数"></a>获取转换是否结束函数</h5><p>获取标志位状态，参数给EOC的标志位，判断EOC标志位是不是置1了，如果转换结束EOC标志位置1，然后调用此函数，判断标志位，来判断转换是否结束</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">FlagStatus <span class="title">ADC_GetFlagStatus</span><span class="params">(ADC_TypeDef* ADCx, <span class="keyword">uint8_t</span> ADC_FLAG)</span></span>;</span><br></pre></td></tr></table></figure>

<h5 id="配置间断模式函数"><a href="#配置间断模式函数" class="headerlink" title="配置间断模式函数"></a>配置间断模式函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ADC_DiscModeChannelCountConfig</span><span class="params">(ADC_TypeDef* ADCx, <span class="keyword">uint8_t</span> Number)</span></span>;<span class="comment">//每隔，几个通道间断一次</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ADC_DiscModeCmd</span><span class="params">(ADC_TypeDef* ADCx, FunctionalState NewState)</span></span>;<span class="comment">//启用间断模式</span></span><br></pre></td></tr></table></figure>

<h5 id="ADC规则组通道配置函数"><a href="#ADC规则组通道配置函数" class="headerlink" title="ADC规则组通道配置函数"></a>ADC规则组通道配置函数</h5><p>它的作用是给序列每个位置填写的指定的通道，就是填写点菜点菜的过程</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ADC_RegularChannelConfig</span><span class="params">(ADC_TypeDef* ADCx, <span class="keyword">uint8_t</span> ADC_Channel, <span class="keyword">uint8_t</span> Rank, <span class="keyword">uint8_t</span> ADC_SampleTime)</span></span>;</span><br></pre></td></tr></table></figure>

<h5 id="外部触发转换控制函数"><a href="#外部触发转换控制函数" class="headerlink" title="外部触发转换控制函数"></a>外部触发转换控制函数</h5><h5 id="是否允许外部触发转换"><a href="#是否允许外部触发转换" class="headerlink" title="是否允许外部触发转换"></a>是否允许外部触发转换</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ADC_ExternalTrigConvCmd</span><span class="params">(ADC_TypeDef* ADCx, FunctionalState NewState)</span></span>;</span><br></pre></td></tr></table></figure>

<h5 id="ADC获取转换值函数"><a href="#ADC获取转换值函数" class="headerlink" title="ADC获取转换值函数"></a>ADC获取转换值函数</h5><p>获取AD转换的数据寄存器，读取转换结构就需要使用这个函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">uint16_t</span> <span class="title">ADC_GetConversionValue</span><span class="params">(ADC_TypeDef* ADCx)</span></span>;</span><br></pre></td></tr></table></figure>

<h5 id="ADC获取双模式转换值"><a href="#ADC获取双模式转换值" class="headerlink" title="ADC获取双模式转换值"></a>ADC获取双模式转换值</h5><p>读取双ADC模式转换结果的函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">ADC_GetDualModeConversionValue</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<h5 id="注入组相关函数"><a href="#注入组相关函数" class="headerlink" title="注入组相关函数"></a>注入组相关函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ADC_AutoInjectedConvCmd</span><span class="params">(ADC_TypeDef* ADCx, FunctionalState NewState)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ADC_InjectedDiscModeCmd</span><span class="params">(ADC_TypeDef* ADCx, FunctionalState NewState)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ADC_ExternalTrigInjectedConvConfig</span><span class="params">(ADC_TypeDef* ADCx, <span class="keyword">uint32_t</span> ADC_ExternalTrigInjecConv)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ADC_ExternalTrigInjectedConvCmd</span><span class="params">(ADC_TypeDef* ADCx, FunctionalState NewState)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ADC_SoftwareStartInjectedConvCmd</span><span class="params">(ADC_TypeDef* ADCx, FunctionalState NewState)</span></span>;</span><br><span class="line"><span class="function">FlagStatus <span class="title">ADC_GetSoftwareStartInjectedConvCmdStatus</span><span class="params">(ADC_TypeDef* ADCx)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ADC_InjectedChannelConfig</span><span class="params">(ADC_TypeDef* ADCx, <span class="keyword">uint8_t</span> ADC_Channel, <span class="keyword">uint8_t</span> Rank, <span class="keyword">uint8_t</span> ADC_SampleTime)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ADC_InjectedSequencerLengthConfig</span><span class="params">(ADC_TypeDef* ADCx, <span class="keyword">uint8_t</span> Length)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ADC_SetInjectedOffset</span><span class="params">(ADC_TypeDef* ADCx, <span class="keyword">uint8_t</span> ADC_InjectedChannel, <span class="keyword">uint16_t</span> Offset)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">uint16_t</span> <span class="title">ADC_GetInjectedConversionValue</span><span class="params">(ADC_TypeDef* ADCx, <span class="keyword">uint8_t</span> ADC_InjectedChannel)</span></span>;</span><br></pre></td></tr></table></figure>

<h5 id="配置模拟看门狗相关函数"><a href="#配置模拟看门狗相关函数" class="headerlink" title="配置模拟看门狗相关函数"></a>配置模拟看门狗相关函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ADC_AnalogWatchdogCmd</span><span class="params">(ADC_TypeDef* ADCx, <span class="keyword">uint32_t</span> ADC_AnalogWatchdog)</span></span>;<span class="comment">//是否启动模拟看门狗</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ADC_AnalogWatchdogThresholdsConfig</span><span class="params">(ADC_TypeDef* ADCx, <span class="keyword">uint16_t</span> HighThreshold, <span class="keyword">uint16_t</span> LowThreshold)</span></span>;<span class="comment">//配置高低阈值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ADC_AnalogWatchdogSingleChannelConfig</span><span class="params">(ADC_TypeDef* ADCx, <span class="keyword">uint8_t</span> ADC_Channel)</span></span>;<span class="comment">//配置看门的通道</span></span><br></pre></td></tr></table></figure>

<h5 id="用来控制开启内部的两个通道函数"><a href="#用来控制开启内部的两个通道函数" class="headerlink" title="用来控制开启内部的两个通道函数"></a>用来控制开启内部的两个通道函数</h5><p>用来控制开启内部的两个通道（ADC温度传感器，内部参考电压控制）,如果要用到这两个通道需要调用这个函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ADC_TempSensorVrefintCmd</span><span class="params">(FunctionalState NewState)</span></span>;</span><br></pre></td></tr></table></figure>

<h5 id="获取标志位状态函数"><a href="#获取标志位状态函数" class="headerlink" title="获取标志位状态函数"></a>获取标志位状态函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">FlagStatus <span class="title">ADC_GetFlagStatus</span><span class="params">(ADC_TypeDef* ADCx, <span class="keyword">uint8_t</span> ADC_FLAG)</span></span>;</span><br></pre></td></tr></table></figure>

<h5 id="清除标志位函数"><a href="#清除标志位函数" class="headerlink" title="清除标志位函数"></a>清除标志位函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ADC_ClearFlag</span><span class="params">(ADC_TypeDef* ADCx, <span class="keyword">uint8_t</span> ADC_FLAG)</span></span>;</span><br></pre></td></tr></table></figure>

<h5 id="获取中断状态函数"><a href="#获取中断状态函数" class="headerlink" title="获取中断状态函数"></a>获取中断状态函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ITStatus <span class="title">ADC_GetITStatus</span><span class="params">(ADC_TypeDef* ADCx, <span class="keyword">uint16_t</span> ADC_IT)</span></span>;</span><br></pre></td></tr></table></figure>

<h5 id="清除中断挂起位"><a href="#清除中断挂起位" class="headerlink" title="清除中断挂起位"></a>清除中断挂起位</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ADC_ClearITPendingBit</span><span class="params">(ADC_TypeDef* ADCx, <span class="keyword">uint16_t</span> ADC_IT)</span></span>;</span><br></pre></td></tr></table></figure>

<p>ADC程序实例</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AD_Init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1, ENABLE);</span><br><span class="line">	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);</span><br><span class="line">	</span><br><span class="line">	RCC_ADCCLKConfig(RCC_PCLK2_Div6);</span><br><span class="line">	</span><br><span class="line">	GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;</span><br><span class="line">	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0 | GPIO_Pin_1 | GPIO_Pin_2 | GPIO_Pin_3;</span><br><span class="line">	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">	GPIO_Init(GPIOA, &amp;GPIO_InitStructure);</span><br><span class="line">		</span><br><span class="line">	ADC_InitTypeDef ADC_InitStructure;</span><br><span class="line">	ADC_InitStructure.ADC_Mode = ADC_Mode_Independent;<span class="comment">//独立模式</span></span><br><span class="line">	ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;<span class="comment">//右对齐</span></span><br><span class="line">	ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None;<span class="comment">//软件触发</span></span><br><span class="line">	ADC_InitStructure.ADC_ContinuousConvMode = DISABLE;<span class="comment">//连续模式</span></span><br><span class="line">	ADC_InitStructure.ADC_ScanConvMode = DISABLE;<span class="comment">//扫描模式</span></span><br><span class="line">	ADC_InitStructure.ADC_NbrOfChannel = <span class="number">1</span>;<span class="comment">//通道数</span></span><br><span class="line">	ADC_Init(ADC1, &amp;ADC_InitStructure);</span><br><span class="line">	</span><br><span class="line">	ADC_Cmd(ADC1, ENABLE);<span class="comment">//开启ADC</span></span><br><span class="line">	</span><br><span class="line">	ADC_ResetCalibration(ADC1);<span class="comment">//开始复位校准</span></span><br><span class="line">	<span class="keyword">while</span> (ADC_GetResetCalibrationStatus(ADC1) == SET);<span class="comment">//获取复位校准状态</span></span><br><span class="line">	ADC_StartCalibration(ADC1);<span class="comment">//开始校准</span></span><br><span class="line">	<span class="keyword">while</span> (ADC_GetCalibrationStatus(ADC1) == SET);<span class="comment">//获取校准状态</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint16_t</span> <span class="title">AD_GetValue</span><span class="params">(<span class="keyword">uint8_t</span> ADC_Channel)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ADC_RegularChannelConfig(ADC1, ADC_Channel, <span class="number">1</span>, ADC_SampleTime_55Cycles5);<span class="comment">//设置规则组的函数</span></span><br><span class="line">	ADC_SoftwareStartConvCmd(ADC1, ENABLE);<span class="comment">//软件触发</span></span><br><span class="line">	<span class="keyword">while</span> (ADC_GetFlagStatus(ADC1, ADC_FLAG_EOC) == RESET);<span class="comment">//获取校准完成标志位</span></span><br><span class="line">	<span class="keyword">return</span> ADC_GetConversionValue(ADC1);<span class="comment">//返回转换完的AD值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="DMA"><a href="#DMA" class="headerlink" title="DMA"></a>DMA</h3><ul>
<li><p> DMA（Direct Memory Access）直接存储器存取，主要是用来协助CPU，完成数据转运的工作</p>
</li>
<li><p>DMA可以提供外设（外设寄存器，一般是外设的数据寄存器DR，Data Register，比如ADC的数据寄存器，串口的数据寄存器）和存储器（运行内存（SRAM）和程序存储器（Flash）是存储变量数组和程序代码的地方）或者存储器与存储器之前的高速数据传输，无须CPU干预，节省了CPU的资源</p>
</li>
<li><p>12个独立可配置的通道（数据转运的路径）：DMA1（7个通道），DMA2（5个通道）</p>
</li>
<li><p>每个通道都支持软件触发和特定的硬件触发，存储器到存储器的数据转运，一般用软件触发，外设到存储器的转运一般用硬件触发</p>
</li>
<li><p>STM32F103C8T6 DMA资源：DMA1（7个通道）</p>
</li>
</ul>
<h5 id="存储器映像"><a href="#存储器映像" class="headerlink" title="存储器映像"></a>存储器映像</h5><p><img src="https://gitee.com/pu-heliang/photos/raw/master/img/202301032048812.png" alt="image-20221228215059578"></p>
<p>计算机系统的5大组成部分：运算器、控制器、存储器、输入设备和输出设备，运算器和控制器一般合在一起叫做CPU，计算机的核心关键部分就是CPU和存储器，存储器最重要的是存储器的内容和存储器的地址。</p>
<p>存储器分为两大类：ROM和RAM，ROM就是只读存储器，是一种非易失性、掉电不丢失的存储器，RAM就是随机存储器，是一种易失性、掉电丢失的存储器，ROM分为三块，第一块是程序存储器，Flash，也就是主闪存，用途就是存储C语言编译后的程序代码，也就是下载程序的位置，运行程序一般也是从主闪存中开始运行的，系统存储器和选项字节，这两块存储器也是ROM的一种，掉电不丢失，实际上它们的存储介质也是Flash，非主闪存Flash，系统存储器是用来存储BootLoader，BootLoader程序一般是芯片出厂自动写入的，一般不允许修改，选项字节存的主要是Flash的读保护、写保护，还有看门狗等等的配置，运行内存SRAM存储我们程序中定义变量、数组、结构体的地方，外设寄存器存储的是我们初始化各个外设，最终读写的东西，外设寄存器起始也是SRAM，存储内核外设NVIC和SysTick。</p>
<h5 id="DMA的框图"><a href="#DMA的框图" class="headerlink" title="DMA的框图"></a>DMA的框图</h5><p><img src="https://gitee.com/pu-heliang/photos/raw/master/img/202301032049778.png" alt="image-20221228220437956"></p>
<p>左上角是Cortex-M3内核，里面包含了CPU和内核外设，剩下的所有东西都可以看成是存储器，Flash是主闪存，SRAM是运行内存，各个外设都可以看成是寄存器，也是一种SRAM存储器，寄存器是一种特殊的存储器，一方面，CPU可以对寄存器进行读写，就像读写运行内存一样，另一方面，寄存器的每一位背后，都连接了一根导线，这些导线可以控制外设电路的状态，比如置引脚的高低电平，导通和断开、切换数据寄存器，或者多位结合起来，当做计数器、数据寄存器，寄存器是连接软件和硬件的桥梁，软件读写寄存器，就相当于在控制硬件的执行，使用DMA进行数据转运，就相当于从某个地址取内容，再放到另一个地址去。</p>
<p>为了高效有条理地访问存储器，设计了一个总线矩阵，总线矩阵的左端，是主动单元，也就是拥有存储器的访问权，右边这些，就是被动单元，它们的存储器只能被左边的主动单元读写，主动单元内核有DCode和系统总线，可以访问右边的存储器，其中DCode总线是专门访问Flash的，系统总线是访问其他东西的，由于DMA要转运数据，所以DMA也必须要有访问的主动权，主动单元除了内核、CPU剩下的就是DMA总线了，DMA1和DMA2都各自有一条总线，下面以太网外设自己也私有一个DMA总线，DMA1有7个通道，DMA2有5个通道，各个通道可以分别设置它们转运数据的源地址和目的地址，下面的仲裁器，由于DMA只有一条总线，仲裁器可以根据通道的优先级决定哪个通道谁先用，在总线矩阵里，也有一个仲裁器，如果DMA和CPU都要访问同一个目标，那么DMA就会暂停CPU的访问，以防止冲突，不过总线仲裁器，仍然会保证CPU得到一半的总线带宽，使CPU也能正常工作，下面的AHB从设备，也就是DMA自身的寄存器，DMA作为一个外设，也会有自己相应的配置寄存器，连接上了总线右边的AHB总线上，所以DMA既是总线矩阵的主动单元，可以读写各种存储器，也是AHB总线上的被动单元，DMA请求就是DMA的硬件触发源，比如说ADC转换完成、串口接收到数据需要触发DMA转运数据的时候，就会通过这条线路，向DMA发出硬件触发信号，之后DMA就可以执行数据转运的工作了，这就是DMA请求的作用。</p>
<p>Flash是ROM只读存储器的一种，如果通过总线直接访问的话，无论是CPU，还是DMA，都是只读的，只能读取数据，而不能写入，如果DMA的目的地址，填写了Flash的区域，那转运时就会出错。也可以配置Flash接口控制器，对Flash进行写入，先对Flash进行擦除，再写入数据。</p>
<h5 id="DMA的基本结构图"><a href="#DMA的基本结构图" class="headerlink" title="DMA的基本结构图"></a>DMA的基本结构图</h5><p><img src="https://gitee.com/pu-heliang/photos/raw/master/img/202301032049195.png" alt="image-20221228222645589"></p>
<p>DMA的数据转运可以从外设到存储器，也可以是从存储器到外设，也可以从存储器转运到存储器，外设和存储器两个站点，都有3个参数，第一个是起始地址，有外设端的起始地址，和存储器端的起始地址，这两个参数决定了数据时从哪里来，到哪里去的，第二个参数是数据宽度，这个参数的作用是，指定一次转运要按多大的数据宽度来进行，可以选择字节Byte、半字节HalfWord和字Word每，字节就是8位转运一个uint8_t，半字节是16位uint16_t，字是32位uint32_t,例如ADC的数据，ADC的数据是uint16_t，所以参数就要选择半字节，依次转运一个uint16_t，第三个参数是地址是否自增，这个参数的作用是，指定一次转运完成后，下一次转运，是不是要把地址移动到下一个位置去，相当于是指针p++，比如ADC扫描模式，用DMA转运数据，外设地址是ADC_DR寄存器，寄存器这边，显然地址是不用自增的，如果自增下一次转运就跑到别的寄存器那里了，存储器这边地址就需要自增，每转运一个数据后，就往后挪个坑，要不然下次再转就把上次的覆盖掉了，这就是地址是否自增的作用，就是指定是否转运一次就挪个坑。</p>
<p>传输存储器：用来指定，总共转运几次，这个传输计数器是个自减计数器，比如写个5，那DMA就只能进行5次数据转运，转运过程中，每转运一次计数器的值就会减1，当传输计数器减到0之后，DMA就不会再进行数据转运了，减到0之后之前自增的地址，也会恢复到起始地址的位置，以方便之后DMA新一轮的转运。传输计数器的右边的自动重装器的作用就是，传输计数器减到0之后，是否要自动恢复到最初的值。比如传输计数器给5，如果不使用自动红装器，那转运5次后，DMA就结束了，如果使用自动重装器，那转运5次，计数器减到0后，就会立即重装到初始值5，自动重装器决定了转运的模式，如果不重装，就是正常的单次模式，如果重装就是循环模式，如果你想转运一个数组，那一般是单次模式，转运一轮就结束了，如果是ADC扫描模式+连续转换那为了配合ADC，DMA也需要使用循环模式，这个循环模式和ADC的连续模式差不多。</p>
<p>DMA的触发控制，触发就是决定DMA在什么时机进行转运的，触发源，有硬件触发，和软件触发，具体选择由M2M（Memory to Memory ）这个参数决定，当给M2M位1时，DMA就会选择软件触发，这个软件触发不是调用某个函数一次就触发一次，而是，以最快的速度，连续不断地出发DMA，指一直到传输计数器清0，软件触发和循环模式不能同时用，因为软件触发是想把传输计数器清零，循环模式是清零后自动重装，如果同时用，那DMA就停不下了，软件触发一般适用于存储器到存储器的转运，因为存储器到存储器的转运是软件启动不需要时机，当M2M位给0，那就是使用硬件触发了，硬件触发源可以选择ADC、串口、定时器等等，使用硬件触发的转运一般是与外设有关的转运，这些转运需要一定的时机，比如ADC转换完成、串口收到数据、定时时间到等等，当硬件达到这些时机时，传一个信号过来，来触发DMA进行转运。</p>
<p>当给DMA使能后，DMA就准备就绪，可以进行转运了。</p>
<p>DMA进行转运的条件：第一，开关控制，DMA_Cmd必须使能，第二，传输计数器必须大于0，第三，触发源，必须有触发信号，触发一次，转运一次，传输计数器自减一次，当传输计数器等于0，且没有自动重装时，无论是否触发，DMA都不会再进行转运了，此时需要DMA_Cmd，给DISABLE，关闭DMA，再为传输计数器写入一个大于0的数，再DMA_Cmd，给ENABLE，开启DMA，DMA才能继续工作，写传输计数器时，必须要先关闭DMA，再进行，不能在DMA开启时，写传输计数器。</p>
<h5 id="DMA请求"><a href="#DMA请求" class="headerlink" title="DMA请求"></a>DMA请求</h5><p><img src="https://gitee.com/pu-heliang/photos/raw/master/img/202301032049883.png" alt="image-20221228230043966"></p>
<p>此图是DMA1的请求映像，下面是DMA的7个通道，每个通道都有一个数据选择器，可以选择硬件触发和软件触发，左边的硬件触发源，每个通道的硬件触发源都是不同的，如果想选择ADC1来触发必须选择通道1，如果想选择TIM2的更新事件来触发的话，那就必须选择通道2，每个通道的硬件触发源都不同，如果想使用某个硬件触发源的话，就必须使用它所在的通道。如果使用软件触发那通道就可以任意选择。如果要使用ADC1，那就有个库函数ADC_DMACmd，必须使用这个库函数开启ADC1的这一路输出，它才有效，如果想要选择定时器2的通道3那也会有个TIM_DMACmd函数，用来进行DMA输出控制，触发源具体选择哪个，取决于你把哪个外设的DMA输出开启了，如果都开启了，那是一个或门，理论上三个硬件都可以触发，一般情况下，都是开启其中一个，这7个触发源，进入到仲裁器，进行优先级判断，最终产生内部的DMA1请求，默认优先级是通道号越小，优先级越高，也可以在程序中配置优先级</p>
<h5 id="数据宽度与对齐"><a href="#数据宽度与对齐" class="headerlink" title="数据宽度与对齐"></a>数据宽度与对齐</h5><p><img src="https://gitee.com/pu-heliang/photos/raw/master/img/202301032049212.png" alt="image-20221228231138118"></p>
<p>第一列是源端宽度，第二列是目标宽度，第三列是传输数目，当源端宽度和目标宽度都是8位时，转运第一步在源端的0位置，读数据B0，在目标的0位置，写数据B0，之后就是把B1，从左边挪到右边，接着B2、B3，这是源端和目标都是8位的情况，操作也很正常，继续就是源端是8位，目标是16位，它的操作就是，在源端读B0，在目标写00B0，之后读B1写00B1，等等，意思就是如果目标宽度，比源端的数据宽度大那就在目标数据前面多出来的空位补0，之后8位转运到32位，也是一样的处理，前面空出来的都补0，当目标数据宽度，比源端数据宽度小时，比如由16位转到8位现象就是，读B1B0，只写入B0，读B3B2，只写入B2，把多出来的高位舍弃掉，意思就是如果你把小的数据转到大的里面，高位就会补0，如果把大的数据转到小的里面去，高位就会舍弃掉，如果数据宽度一样，那就没事。</p>
<h5 id="数据转运-DMA"><a href="#数据转运-DMA" class="headerlink" title="数据转运+DMA"></a>数据转运+DMA</h5><p><img src="https://gitee.com/pu-heliang/photos/raw/master/img/202301032049790.png" alt="image-20221228232030872"></p>
<p>将SRAM中的数组DataA，转运到另一个数组DataB中，参数配置：外设地址是DataA数组的首地址，存储器地址，给DataB数组的首地址，数据宽度，两个数组的类型都是uint8_t，所以数据宽度都是按8位的字节传输，两个站点的地址都自增，转运完成后DataB数组的所有数据。就会等于DataA数组。如果左边不自增，右边自增，转运完成后，DataB的所有数据都会等于DataA[0]，如果左边自增，右边不自增，DataB[0]等于DataA的最后一个数，DataB其他的数不变，如果左右都不自增，那就是DataA[0]转到DataB[0]，其他的数据不变。方向参数，是外设站点转运到存储器站点。传输计数器给7，不需要自动重装，触发选择部分选择软件触发，最后调用DMA_Cmd，给DMA使能，转运7次后，传输计数器自减到0，DMA停止，转运完成，这里的数据转运是一种复制转运，转运完成后的DataA的数据并不会消失。</p>
<h5 id="ADC扫描模式-DMA"><a href="#ADC扫描模式-DMA" class="headerlink" title="ADC扫描模式+DMA"></a>ADC扫描模式+DMA</h5><p><img src="https://gitee.com/pu-heliang/photos/raw/master/img/202301032049962.png" alt="image-20221228233025173"></p>
<p>左边是ADC扫描模式的转运流程，触发一次，7个通道依次进行AD转换，然后把转换结果都放在ADC_DR寄存器里面，在每个单独的通道转换完成后，进行一次DMA数据转运，并且目的地址进行自增，防止数据被覆盖，DMA的配置，外设地址，写入ADC_DR这个寄存器的地址，存储器的地址，可以在SRAM中定义一个数组ADValue然后把ADValue的地址当做存储器的地址，之后数据宽度，因为ADC_DR和SRAM数组需要uint16_t的数据，所以数据宽度都是16位的半字传输，外设地址不自增，存储器地址自增，传输方向，是外设站点到存储器站点，传输计数器和通道数一样，通道有7个，所以计数7次，计数器知否重装，看ADC的配置，ADC如果是单次扫描，那DMA的传输计数器可以不自动重装，转换一轮就停止，如果ADC是连续扫描，那DMA就可以选择使用自动重装，在ADC启动下一轮的转换的时候，DMA也启动下一轮的转运，ADC和DMA同步工作，触发选择ADC的硬件触发，ADC扫描模式在单个通道完成转换后，不会置任何标志位，也不会产生中断，但是会产生DMA请求，去触发DMA转运。一般来说DMA最常用的用途就是配合ADC的扫描模式，来解决ADC固有的缺陷，数据覆盖的问题。</p>
<h5 id="初始化DMA步骤："><a href="#初始化DMA步骤：" class="headerlink" title="初始化DMA步骤："></a>初始化DMA步骤：</h5><p>第一步，RCC开启DMA的时钟,AHB总线的设别</p>
<p>第二步，直接调用DMA_Init，初始化配置的参数，包括外设和存储器站点的起始地址、数据宽度、地址是否自增、方向、传输计数器、是否需要自动重装、选择触发源、通道优先级</p>
<p>第三步，DMA_Cmd给指定通道使能，如果使用的是硬件触发，要在对应外设调用XXX_DMACmd，开启一下触发信号的输出，需要DMA的中断，就调用DMA_ITConfig，开启中断输出，再在NVIC中配置相应的中断通道，然后写中断函数就行了，如果传输计数器清0，再想给传输计数器赋值，就DMA失能、写传输计数器、DMA使能，就可以了</p>
<h5 id="DMA的库函数"><a href="#DMA的库函数" class="headerlink" title="DMA的库函数"></a>DMA的库函数</h5><h5 id="恢复缺省配置"><a href="#恢复缺省配置" class="headerlink" title="恢复缺省配置"></a>恢复缺省配置</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DMA_DeInit</span><span class="params">(DMA_Channel_TypeDef* DMAy_Channelx)</span></span>;</span><br></pre></td></tr></table></figure>

<p>初始化</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DMA_Init</span><span class="params">(DMA_Channel_TypeDef* DMAy_Channelx, DMA_InitTypeDef* DMA_InitStruct)</span></span>;</span><br></pre></td></tr></table></figure>

<h5 id="结构体初始化"><a href="#结构体初始化" class="headerlink" title="结构体初始化"></a>结构体初始化</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DMA_StructInit</span><span class="params">(DMA_InitTypeDef* DMA_InitStruct)</span></span>;</span><br></pre></td></tr></table></figure>

<h5 id="使能"><a href="#使能" class="headerlink" title="使能"></a>使能</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DMA_Cmd</span><span class="params">(DMA_Channel_TypeDef* DMAy_Channelx, FunctionalState NewState)</span></span>;</span><br></pre></td></tr></table></figure>

<h5 id="中断输出使能"><a href="#中断输出使能" class="headerlink" title="中断输出使能"></a>中断输出使能</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DMA_ITConfig</span><span class="params">(DMA_Channel_TypeDef* DMAy_Channelx, <span class="keyword">uint32_t</span> DMA_IT, FunctionalState NewState)</span></span>;</span><br></pre></td></tr></table></figure>

<h5 id="DMA-设置当前数据寄存器"><a href="#DMA-设置当前数据寄存器" class="headerlink" title="DMA_设置当前数据寄存器"></a>DMA_设置当前数据寄存器</h5><h5 id="给传输计数器写数据的"><a href="#给传输计数器写数据的" class="headerlink" title="给传输计数器写数据的"></a>给传输计数器写数据的</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DMA_SetCurrDataCounter</span><span class="params">(DMA_Channel_TypeDef* DMAy_Channelx, <span class="keyword">uint16_t</span> DataNumber)</span></span>; </span><br></pre></td></tr></table></figure>

<h5 id="DMA获取当前数据寄存器"><a href="#DMA获取当前数据寄存器" class="headerlink" title="DMA获取当前数据寄存器"></a>DMA获取当前数据寄存器</h5><h5 id="返回传输计数器的值"><a href="#返回传输计数器的值" class="headerlink" title="返回传输计数器的值"></a>返回传输计数器的值</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">uint16_t</span> <span class="title">DMA_GetCurrDataCounter</span><span class="params">(DMA_Channel_TypeDef* DMAy_Channelx)</span></span>;</span><br></pre></td></tr></table></figure>

<h5 id="获取标志位状态"><a href="#获取标志位状态" class="headerlink" title="获取标志位状态"></a>获取标志位状态</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">FlagStatus <span class="title">DMA_GetFlagStatus</span><span class="params">(<span class="keyword">uint32_t</span> DMAy_FLAG)</span></span>;</span><br></pre></td></tr></table></figure>

<h5 id="清除标志位状态"><a href="#清除标志位状态" class="headerlink" title="清除标志位状态"></a>清除标志位状态</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DMA_ClearFlag</span><span class="params">(<span class="keyword">uint32_t</span> DMAy_FLAG)</span></span>;</span><br></pre></td></tr></table></figure>



<h5 id="获取中断状态"><a href="#获取中断状态" class="headerlink" title="获取中断状态"></a>获取中断状态</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ITStatus <span class="title">DMA_GetITStatus</span><span class="params">(<span class="keyword">uint32_t</span> DMAy_IT)</span></span>;</span><br></pre></td></tr></table></figure>



<h5 id="清除中断挂起位-1"><a href="#清除中断挂起位-1" class="headerlink" title="清除中断挂起位"></a>清除中断挂起位</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DMA_ClearITPendingBit</span><span class="params">(<span class="keyword">uint32_t</span> DMAy_IT)</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="DMA程序示例"><a href="#DMA程序示例" class="headerlink" title="DMA程序示例"></a>DMA程序示例</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uint16_t</span> AD_Value[<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AD_Init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1, ENABLE);</span><br><span class="line">	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);</span><br><span class="line">	RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1, ENABLE);</span><br><span class="line">	</span><br><span class="line">	RCC_ADCCLKConfig(RCC_PCLK2_Div6);</span><br><span class="line">	</span><br><span class="line">	GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;<span class="comment">//模拟输入</span></span><br><span class="line">	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0 | GPIO_Pin_1 | GPIO_Pin_2 | GPIO_Pin_3;</span><br><span class="line">	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">	GPIO_Init(GPIOA, &amp;GPIO_InitStructure);</span><br><span class="line">	</span><br><span class="line">	ADC_RegularChannelConfig(ADC1, ADC_Channel_0, <span class="number">1</span>, ADC_SampleTime_55Cycles5);<span class="comment">//这只规则组</span></span><br><span class="line">	ADC_RegularChannelConfig(ADC1, ADC_Channel_1, <span class="number">2</span>, ADC_SampleTime_55Cycles5);</span><br><span class="line">	ADC_RegularChannelConfig(ADC1, ADC_Channel_2, <span class="number">3</span>, ADC_SampleTime_55Cycles5);</span><br><span class="line">	ADC_RegularChannelConfig(ADC1, ADC_Channel_3, <span class="number">4</span>, ADC_SampleTime_55Cycles5);</span><br><span class="line">		</span><br><span class="line">	ADC_InitTypeDef ADC_InitStructure;</span><br><span class="line">	ADC_InitStructure.ADC_Mode = ADC_Mode_Independent;</span><br><span class="line">	ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;</span><br><span class="line">	ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None;</span><br><span class="line">	ADC_InitStructure.ADC_ContinuousConvMode = ENABLE;<span class="comment">//连续转换</span></span><br><span class="line">	ADC_InitStructure.ADC_ScanConvMode = ENABLE;<span class="comment">//扫描模式</span></span><br><span class="line">	ADC_InitStructure.ADC_NbrOfChannel = <span class="number">4</span>;<span class="comment">//四个通道</span></span><br><span class="line">	ADC_Init(ADC1, &amp;ADC_InitStructure);</span><br><span class="line">	</span><br><span class="line">	DMA_InitTypeDef DMA_InitStructure;</span><br><span class="line">	DMA_InitStructure.DMA_PeripheralBaseAddr = (<span class="keyword">uint32_t</span>)&amp;ADC1-&gt;DR;<span class="comment">//源地址</span></span><br><span class="line">	DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_HalfWord;<span class="comment">//半字长</span></span><br><span class="line">	DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;<span class="comment">//不自增</span></span><br><span class="line">	DMA_InitStructure.DMA_MemoryBaseAddr = (<span class="keyword">uint32_t</span>)AD_Value;<span class="comment">//目标地址</span></span><br><span class="line">	DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_HalfWord;<span class="comment">//半字长</span></span><br><span class="line">	DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;<span class="comment">//地址自增</span></span><br><span class="line">	DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralSRC;<span class="comment">//外设到存储器</span></span><br><span class="line">	DMA_InitStructure.DMA_BufferSize = <span class="number">4</span>;<span class="comment">//传输计数器为4</span></span><br><span class="line">	DMA_InitStructure.DMA_Mode = DMA_Mode_Circular;<span class="comment">//循环模式</span></span><br><span class="line">	DMA_InitStructure.DMA_M2M = DMA_M2M_Disable;<span class="comment">//硬件触发</span></span><br><span class="line">	DMA_InitStructure.DMA_Priority = DMA_Priority_Medium;<span class="comment">//中等优先级</span></span><br><span class="line">	DMA_Init(DMA1_Channel1, &amp;DMA_InitStructure);</span><br><span class="line">	</span><br><span class="line">	DMA_Cmd(DMA1_Channel1, ENABLE);</span><br><span class="line">	ADC_DMACmd(ADC1, ENABLE);<span class="comment">//打通ADC到DMA的通道</span></span><br><span class="line">	ADC_Cmd(ADC1, ENABLE);</span><br><span class="line">	</span><br><span class="line">	ADC_ResetCalibration(ADC1);</span><br><span class="line">	<span class="keyword">while</span> (ADC_GetResetCalibrationStatus(ADC1) == SET);</span><br><span class="line">	ADC_StartCalibration(ADC1);</span><br><span class="line">	<span class="keyword">while</span> (ADC_GetCalibrationStatus(ADC1) == SET);</span><br><span class="line">	</span><br><span class="line">	ADC_SoftwareStartConvCmd(ADC1, ENABLE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="USART串口"><a href="#USART串口" class="headerlink" title="USART串口"></a>USART串口</h3><h5 id="通信接口"><a href="#通信接口" class="headerlink" title="通信接口"></a>通信接口</h5><ul>
<li><p>通信的目的：将一个设备的数据传送到另一个设备，扩展硬件系统</p>
</li>
<li><p>通信协议：指定通信的规则，通信双方按照协议规则进行数据收发</p>
</li>
<li><p>全双工：通信双方能够同时进行双向通信，全双工，一般有两根通信线</p>
</li>
<li><p>单工：数据只能从一个设备到另一个设备</p>
</li>
<li><p>TX和RX是单端信号，它们的高低信号都是相对于GND的，严格上来说GND也算是通信线，串口通信的TX，RX，GND是必须要接的。</p>
</li>
<li><p>串口通信有两根通信线（发送端TX和接收端RX）</p>
</li>
<li><p>TX和RX要交叉连接</p>
</li>
<li><p>当只需单向的数据传输时，可以只接一根通信线</p>
</li>
<li><p>当电平标准不一致时，需要加电平转换芯片</p>
</li>
<li><p>复杂一点的串口通信还有时钟引脚、硬件流控制的引脚</p>
</li>
</ul>
<p><img src="https://gitee.com/pu-heliang/photos/raw/master/img/202301032043640.png" alt="image-20221227204837052"></p>
<h5 id="串口参数及时序"><a href="#串口参数及时序" class="headerlink" title="串口参数及时序"></a>串口参数及时序</h5><p><img src="https://gitee.com/pu-heliang/photos/raw/master/img/202301032049654.png" alt="image-20221227205148050"></p>
<p>串口数据帧的整体结构：串口中，每一个字节都装载在一个数据帧里面，每个数据帧都由起始位、数据位和停止位组成，数据位有8个，代表一个字节的8位，还可以在数据位的最后加一个奇偶校验位，这样数据位总共就是9位，其中有效载荷时前8位，代表1个字节，校验位跟在有效载荷后面，占1位</p>
<p>波特率：规定串口通信的速率（串口一般使用异步通信，需要双方约定一个通信速率），例如每隔1s发送一位，接收方也要每隔1s接收一位，接收快了，就会重复接收某些位，如果接收慢了，就会漏掉某些位，发送和接收必须约定好速率，波特率本义是每秒传输码元的个数，单位是码元/s，或者直接叫波特(Baud)，比特率是每秒传输的比特数，单位是bit/s，或者叫bps，在二进制调制的情况下，一个码元就是一个bit，此时波特率就等于比特率，单片机的串口通信，基本都是二进制调制，也就是高电平表示1，低电平表示0，一位就是1bit，规定波特率为1000bps，表示1s要发1000位，每一位的时间就是1ms，发送方每隔1ms发送一位，接收方每隔1ms接收一位，</p>
<p>起始位：标志一个数据帧的开始，固定为低电平（串口的空闲状态是高电平，没有数据传输的时候引脚必须置高电平，作为空闲状态）需要传输的时候先发送一个起始位，起始位必须是低电平，来打破空闲状态的高电平，产生一个下降沿（告诉接受设备，这一帧数据要开始了），如果没有起始位，当发送8个1的时候，数据线一直都是高电平，没有任何波动，这样接收方就不知道我是否发送数据，所以必须要有一个固定为低电平的起始位，产生下降沿，来告诉接受设备，为要发送数据了—–起始位固定为0，产生下降沿，表示传输开始</p>
<p>停止位；在一个字节数据发送完成后，必须要有一个停止位，这个停止位的作用是，用于数据帧间隔，固定为高电平，同时这个停止位也是为下一个起始位做准备的，如果没有停止位，那当为数据最后一位是0的时候，下次再发送新的一帧，就没法产生下降沿了—–停止位固定为1，把引脚恢复成高电平，方便下一次的下降沿，如果没有数据了，引脚也为高电平，代表空闲状态</p>
<p>数据位：表示数据帧的有效载荷，1为高电平，0位低电平，低位先行</p>
<p>校验位：用于数据验证，是根据数据位计算得来的，串口使用奇偶校验位方法，奇偶校验可以用来判断数据传输是不是出错了，如果数据出错了可以选择丢弃或者要求重传，校验可以选择三种方式，无校验、奇校验和偶校验，无校验就是不需要校验位，波形就是上图左边的，起始位、数据位，停止位一共3个部分，奇校验和偶校验的波形就是上图右边的，起始位、数据位、校验位、停止位，总共4个部分，如果使用了奇校验，那么包括校验位在内的9位数据会出现奇数个1，如果传输 0000 1111，目前总共4个1，是偶数个，那么校验位就需要再补一个1，连同校验位就是0000 1111 1，总共5个1，保证1的个数为奇数，如果数据是0000 1110，此时3个1，是奇数个，那么校验位就补1个0，连同校验位就是0000 1110 0，总共还是3个1,1的个数为奇数，发送方，在发送数据后，会补一个校验位，保证1的个数为奇数，接收方在接收数据后，会验证数据位和校验位，如果1的个数还是奇数，就认为数据没有出错，如果在传输中，因为干扰，有一位由1变成0，或者由0变成1了，那么整个数据的奇偶特性就会变化，接收方一验证，发现1的个数不是奇数，那就认为传输出错，就可以选择丢弃，或者要求重传，这就是奇校验的差错控制方法。如果选择双方约定偶校验，那就是保证1的个数是偶数，校验方法也是同理，但是奇偶校验的检出率不是很高，例如，如果有两位数据同时出错，就特性不变，那就校验不出来了，就能校验只能保证一定程度上的数据校验，如果想要更高的检出率可以选择CRC校验，STM32内部也有CRC外设。</p>
<p>数据位：有两种表示方法，一种是把校验位作为数据位的一部分，另一种就是把校验位和数据位独立开，数据位就是有效载荷，校验位就是独立的1位，在串口助手里就是选择的把数据位和校验位分开描述的方法，总之无论是合在一起，还是分开描述，描述的都是同一个东西</p>
<p><img src="https://gitee.com/pu-heliang/photos/raw/master/img/202301032050854.png" alt="image-20221227213228380"></p>
<p>第一个波形：这个波形是发送一个数据0x55时，在TX引脚输出的波形，波特率是9600，每一位的时间就是1/9600，大概是104us，没发送数据的时候是空闲状态高电平，数据帧开始，先发送起始位，产生下降沿，代表数据帧开始，数据0x55转为2进制，低位先行，就是依次发送1010 1010，然后参数是，1位停止，无校验，所以数据帧之后就是停止位，把引脚置回高电平，在STM32中，这个根据字节数据翻转高低电平，是由USART外设自动完成的，不用我们管，也可以软件模拟产生这样的波形，定时器定一个104us的时间，时间到之后，按照数据帧要求，调用GPIO_WriteBit置高低电平，产生一个一模一样的波形，也可以完成串口通信，在TX引脚发送就是置高低电平，在RX引脚接收就是读取高低电平，这也可以由USART外设完成，如果想软件模拟的话那就是定时调用GPIO_ReadInputDataBit来读取每一位，接收的时候也需要一个外部中断，在起始位的下降沿触发，进入接收状态，并且对其采样时钟，然后依次采样8次，这就是接受的逻辑</p>
<p>USART ：同步收发器，UART：异步收发器</p>
<p>同步模式一般是为了兼容别的协议或者特殊用途而设计的，并不兼容两个USART之间进行同步同步通信，串口主要还是异步通信</p>
<p>USART (Universal Synchronous/Asynchronous Receiver/Transmitter)</p>
<p>USART是STM32内部集成的硬件外设，可根据数据寄存器的一个字节数据自动生成数据帧时序，从TX引脚发送出去，也可以自动接收RX引脚的数据帧时序，拼接成一个字节数据，存放在数据寄存器里</p>
<p>自带波特率发生器，最高达4.5Mbits/s，起始就是一个分频器，比如APB2总线给个72MHz的频率然后波特率发生器进行一个分频，得到我们想要的波特率时钟，在这个时钟下，进行收发，就是我们指定的通信波特率，</p>
<p>可配置数据位长度(8/9)、停止位长度(0.5/1/1.5/2)</p>
<p>可选校验位（无校验/奇校验/偶校验）</p>
<p>支持同步模式、硬件流控制、DMA、智能卡、IrDA、LIN，硬件流控制：A设备有个TX向B设备的RX发送数据，A设备一直在发，发的太快了，B处理不过来，如果没有硬件流控制，那B就只能抛弃新数据或者覆盖原数据了，如果有硬件流控制，在硬件电路上，就会多出一根线，如果B没准备好接受，就置高电平，如果准备好了，就置低电平，A接收到了B反馈的准备信号，就只会在B准备好的时候，才发数据，如果B没准备好，那数据就不会发送出去，硬件流控制可以防止处理慢而导致数据丢失的问题，硬件流控制STM32也是有的，但是一般不用，串口也支持DMA数据转运，如果有大量的数据进行收发，可以使用DMA转运数据，减轻CPU的负担</p>
<p>STM32F103C8T6 USART资源：USART1、USART2、USART3，USART1是APB2总线的设备，USART2,3是APB1总线的设备</p>
<p><img src="https://gitee.com/pu-heliang/photos/raw/master/img/202301032050963.png" alt="image-20221227221317657"></p>
<p>SW_RX、IRDA_OUT/IN这些是智能卡和IrDA通信的引脚</p>
<p>发送和接收的字节数据存在串口的数据寄存器，数据寄存器分为发送数据寄存器TDR(Transmit)，另一个是接收数据寄存器RDR(Receive DR)，两个寄存器占用同一个地址，在程序上只表现为一个寄存器，就是数据寄存器DR(Data Register)，但实际硬件中，分成了两个寄存器，一个用于发送的TDR，一个用于接收的RDR，TDR是只写的,RDR是只读的，当进行写操作时，数据就写入到TDR，当进行读操作的时候，数据就是从RDR中读出来的，还有两个移位寄存器，一个用于发送，一个用于接受，发送移位寄存器的作用就是，把一个字节的数据一位一位地移出去，正好对应串口协议的波形数据位，例如为在某时刻给TDR写入了0x55这个数据，在寄存器就是二进制存储,0101 0101,此时硬件检测到我写入数据了，就会检查移位寄存器是否有数据正在移位，如果没有，这个0101 0101就会立刻全部移动到发送移位寄存器，准备发送，当数据从TDR移动到移位寄存器的时候会置一个标志位，叫TXE(TX Empty)，发送寄存器空，检查这个标志位，如果置1了，就可以在TDR继续写入下一个数据了，当TXE标志位置1时，数据其实还没有发送出去，只要数据从TDR转移到发送移位寄存器了TXE就会置1，我们就可以写入新的数据了，然后发送移位寄存器就会在发生器控制的驱动下，向右移位，然后一位一位地，把数据输出到TX引脚，向右移位，正好与串口协议规定的低位先行是一致的，当数据移位完成后，新的数据就会在此自动地从TDR转移到发送移位寄存器里来，如果当前移位寄存器的移位还没有完成，TDR的数据进行等待，一但移位完成，就会立刻转移过来，TDR和移位寄存器的双重缓存，可以保证连续发送数据的时候，数据帧之间不会有空闲，提高了工作效率，简单来说就是数据一但从TDR转移到发送移位寄存器了，就立刻把下一个数据放在TDR等着，一但转移完毕，新的数据就会立刻跟上，这样做效率比较高。</p>
<p>接收端也是类似的，数据从RX引脚通向接收移位寄存器，在接收器控制器的驱动下，一位一位的读取RX电平，先放在最高位，然后向右移，移位8次后，就能接收板一个字节了，因为串口协议规定是低位先行，所以接受移位寄存器是从个高位往低位方向移动的，之后，当一个字节移位完成之后，这一个字节的数据就会整体地一下子转移到接收数据寄存器RDR里来，在转移的过程中也会置一个标志位，叫RXNE(RX Not Empty)，接收数据寄存器非空，当检测到RXNE置1之后，就可以把数据读走了，同样也是两个寄存器进行缓存，当数据从移位寄存器转移到RDR时，就可以直接接受下一帧数据了，这就是USART外设整个的工作流程。发送需要加上帧头帧尾，接收需要剔除帧头帧尾，这些操作内部电路会自动执行。</p>
<p>发送器控制：用来控制发送移位寄存器的工作的</p>
<p>接收器控制：用来控制接受移位寄存器的工作</p>
<p>硬件数据流控制：有两个引脚，一个是nRTS，一个是nCTS，nRTS(Request To Send)是请求发送，是输出脚，也就是告诉别人，我当前能不能接受，nCTS(Clear To Send)是清除发送，是输入脚也就是接受别人的nRTS的信号的，前面的n是低电平有效，使用步骤：找另一个支持流控的串口它的TX接到我的RX，然后我的RTS输出一个能不能接受的反馈信号，接到对方CTS，当我能接收的是吧，RTS就置低电平，请求对方发送，对方的CTS收到后们就可以一直发，当我处理不过来时，比如接收数据寄存器一直没有读，又有新的数据过来了，代表我没有及时处理，那RTS就置高电平，对方CTS接收到之后，就会暂停发送，直到接受数据寄存器被读走，RTS置低电平，新的数据才会继续发送，反过来，TX给对方发送数据时我的CTS就接到对方的RTS，用于判断对方，能不能接收，TX和CTS是一对的，RX和RTS是一对的，CTS和RTS也要交叉连接，这就是流控的工作模式（一般不使用流控）</p>
<p>右边的模块用于产生同步的时钟信号，配合发送移位寄存器输出，发送移位寄存器每移位一次，同步时钟就跳变一个周期，时钟告诉对方，我移出去一位数据了，看是否需要时钟信号来指导接受一下，这个时钟只支持输出不支持输入，两个USART之间，不能实现同步的串口通信，这个时钟信号的用途，第一个就是兼容别的协议，比如串口加上时钟之后，和SPI协议特别像，所以有了时钟输出的串口，就可以兼容SPI，这个时钟也可以做自适应波特率，比如接受设备不确定发送设备给的什么波特率，可以测量一下这个时钟的周期，然后计算得到波特率（需要另外写程序来实现这个功能）</p>
<p>唤醒单元：实现串口挂在多设备，串口一般是点对点的通信，点对点，只支持两个设备互相通信，想发数据直接发就行，而多设备，在一条总线上，可以接多个从设备，每个设备分配一个地址，先跟某个设备通信，就先进行寻址，确定通信对象，在定义数据收发，这个唤醒单元就可以用来实现多设备的功能，可以给串口分配一个地址，当我发送指定地址时，此设备唤醒开始工作，当我发送别的设备地址时，别的设备就唤醒工作，这个设备没收到地址，就会保持沉默，这样实现多设备的串口通信了。</p>
<p>中断输出控制：中断申请位就是状态寄存器的各种标志位，状态寄存器这里有两个标志位比较重要，一个是TXE发送寄存器空，另一个是RXNE接收寄存器空，这两个是判断发送状态和接收状态的必要标志位，中断输出控制就是配置中断是不是能够通向NVIC</p>
<p>波特率发生器：其实就是分频器，APB时钟进行分频，得到发送和接收移位的时钟，时钟输入是发PCLKx(x=1或2)，因为USART1挂载在APB2，所以就是PCLK2的时钟，一般是72M，其他的USART都挂载在APB1，所以是PCLK1的时钟，一般是36M，之后时钟在进行一个分频，除以一个USARTDIV的分频系数，USARTDIV是一个数值，分为整数部分和小数部分，因为有些波特率，用72M除于一个整数的话，可能除不尽，会有误差，所以这里的分频系数是支持小数点后4位的，分频就更加精准，之后分频完还要再除个16，得到发送时钟和接收器时钟，通向控制部分，然后右边，如果TE（TX Enable）为1，就是发送器使能，发送部分的波特率就有效，如果RE（RX Enable）为1，就是接收器使能了，接收部分的波特率就有效。</p>
<h5 id="USART的基本结构"><a href="#USART的基本结构" class="headerlink" title="USART的基本结构"></a>USART的基本结构</h5><p><img src="https://gitee.com/pu-heliang/photos/raw/master/img/202301032050891.png" alt="image-20221227231140269"></p>
<p>最左边的是波特率发生器，用于产生约定的通信速率，时钟来源是PCLK2或1，经过波特率发生器分频后，产生的时钟通向发送控制器和接收控制器，发送控制器和接收控制器用来控制发送移位和接收移位，之后由发送数据寄存器和发送移位寄存器这两个寄存器的配合，将数据一位一位的移出去，通过GPIO口的复用输出，输出到TX引脚，产生串口协议规定的波形，这个移位寄存器是向右移的，是低位先行，当数据由数据寄存器转移到移位寄存器时，会置一个TXE的标志位，通过判断这个标志位，就可以知道是不是可以写入下一个数据了，接收部分也是类似的，RX引脚的波形，通过GPIO输入，在接收控制器的控制下，一位一位地移入接收移位寄存器，移完一帧数据后，数据就会统一转运到接收数据寄存器，在转移的同时，置一个RXNE标志位，检查这个标志位，就可以知道是不是收到数据了，同时这个标志位也可以去申请中断，这样就可以在收到数据时，直接进入中断函数，快速的读取和保存数据，虽然有四个寄存器但是在软件层面上，只有一个DR寄存器可以供我们读写，写入DR时，数据走上面这条路，进行发送，读取DR时，数据走下面这条路，进行接收，这就是USART进行串口数据收发的过程，右下角是个开关控制。</p>
<p><img src="https://gitee.com/pu-heliang/photos/raw/master/img/202301032050078.png" alt="image-20221227234306675"></p>
<p>四种选择：9位字长，有校验或无校验，8位字长有校验或者无校验，最好选择9位字长，有校验或者8位字长无校验，这样每一帧的有效载荷都是1字节，</p>
<p><img src="https://gitee.com/pu-heliang/photos/raw/master/img/202301032050088.png" alt="image-20221227234437636"></p>
<p>STM32的串口可以配置停止位为0.5、1、1.5、2，这四种参数的区别，就是停止位的时长不一样，1位停止位，这时停止位的时长就和数据位的一位，时长一样，1.5停止位就是数据位一位，时长的1.5倍，2个停止位，那停止位时长就是2倍，0.5个停止位，时长就是0.5倍，一般选择1位停止位。</p>
<p><img src="https://gitee.com/pu-heliang/photos/raw/master/img/202301032050872.png" alt="image-20221227234843163"></p>
<p>串口的输出TX比输入RX简单很多，输出就定时翻转TX引脚高低电平就可以，输入不仅要保证采样频率和波特率一致，还要保证每次输入采样的位置，要正好处于每一位的正中间，只有在每一位的正中间采样，这样高低电平读进来，才是最可靠的，如果采样点过于靠前或者靠后，那有可能高低电平正在翻转，电平还不稳定，或者稍有误差，数据就采样错了，输入最好还要对噪声有一定的判断能力，如果是噪声，最好能置个标志位提醒一下，STM32设计的输入电路，上图展示的是USART的起始位侦测，当输入电路侦测到一个数据帧的起始位后，就会以波特率的频率，连续采样一帧数据，同时，从起始位开始，采样位置就要对齐到位的正中间，只要第一位对齐了，后面都是对齐的，为了实现这些功能对输入的电路对采样时钟进行了细分，它会以波特率的16倍频率进行采样，也就是在一位地时间里，可以进行16次采样，它的策略是最开始，空闲状态高电平，那采样就一直是1，在某个位置突然采集到一个0，那么就说明在这两次采样之间，出现了下降沿，如果没有任何噪声，那之后就应该是起始位了，在起始位，会进行连续16次采样，没有噪声的话，这16次采样，肯定都是0，实际电路有噪声，即使出现下降沿了，后序也要再采样几次，以防万一，这个接收电路还会再下降沿之后的第3次、5次、7次，进行一批采样，在第8次、9次、10次，再进行一批采样，且这两批采样，都要要求每3位里面至少有2个0，没有噪声就全是0，满足情况，如果有轻微的噪声，导致3位里面，只有两个0，另一个是1，也算是检测到了起始位，但是在状态寄存器里会置一个NE（Noise Error），噪声标志位，提醒一下，数据收到了，但是有噪声，如果3位里面只有一个0，就不算检测到了起始位，这时电路就忽略前面的数据，重新开始捕捉下降沿，这就是STM32的串口，在接收过程中，对噪声的处理，如果通过了这个起始位侦测，那接收状态就由空闲，变为接收起始位，同时，第8、9、10次采样的位置，就正好是起始位的正中间，之后接收数据位时，就都在第8、9、10次，进行采样，这样就能保证采样位置在位的正中间了，这就是起始位侦测和采样位置对齐的策略</p>
<p>串口初始化：</p>
<p>第一步，开启时钟，把需要用的USART和GPIO的时钟打开</p>
<p>第二步，GPIO初始化，把TX配置成复用输出，RX配置成输入</p>
<p>第三步，配置USART，直接用一个结构体，就可以配置好所有参数</p>
<p>第四步，如果只需要发送的功能就直接开启USART，如果需要接收的功能，还需要再配置中断，在开启USART之前，加上ITConfig和NVIC的代码就可以了</p>
<h5 id="回复缺省值函数"><a href="#回复缺省值函数" class="headerlink" title="回复缺省值函数"></a>回复缺省值函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">USART_DeInit</span><span class="params">(USART_TypeDef* USARTx)</span></span>;</span><br></pre></td></tr></table></figure>

<h5 id="配置结构体函数"><a href="#配置结构体函数" class="headerlink" title="配置结构体函数"></a>配置结构体函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">USART_Init</span><span class="params">(USART_TypeDef* USARTx, USART_InitTypeDef* USART_InitStruct)</span></span>;</span><br></pre></td></tr></table></figure>

<h5 id="给结构体配置默认值函数"><a href="#给结构体配置默认值函数" class="headerlink" title="给结构体配置默认值函数"></a>给结构体配置默认值函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">USART_StructInit</span><span class="params">(USART_InitTypeDef* USART_InitStruct)</span></span>;</span><br></pre></td></tr></table></figure>

<h5 id="配置同步时钟输出函数"><a href="#配置同步时钟输出函数" class="headerlink" title="配置同步时钟输出函数"></a>配置同步时钟输出函数</h5><p>包括时钟是否输出，时钟的极性相位等参数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">USART_ClockInit</span><span class="params">(USART_TypeDef* USARTx, USART_ClockInitTypeDef* USART_ClockInitStruct)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">USART_ClockStructInit</span><span class="params">(USART_ClockInitTypeDef* USART_ClockInitStruct)</span></span>;</span><br></pre></td></tr></table></figure>

<h5 id="开启串口函数"><a href="#开启串口函数" class="headerlink" title="开启串口函数"></a>开启串口函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">USART_Cmd</span><span class="params">(USART_TypeDef* USARTx, FunctionalState NewState)</span></span>;</span><br></pre></td></tr></table></figure>

<h5 id="开启串口中断函数"><a href="#开启串口中断函数" class="headerlink" title="开启串口中断函数"></a>开启串口中断函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">USART_ITConfig</span><span class="params">(USART_TypeDef* USARTx, <span class="keyword">uint16_t</span> USART_IT, FunctionalState NewState)</span></span>;</span><br></pre></td></tr></table></figure>

<h5 id="开启USART到DMA的触发通道函数"><a href="#开启USART到DMA的触发通道函数" class="headerlink" title="开启USART到DMA的触发通道函数"></a>开启USART到DMA的触发通道函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">USART_DMACmd</span><span class="params">(USART_TypeDef* USARTx, <span class="keyword">uint16_t</span> USART_DMAReq, FunctionalState NewState)</span></span>;</span><br></pre></td></tr></table></figure>

<h5 id="设置地址函数"><a href="#设置地址函数" class="headerlink" title="设置地址函数"></a>设置地址函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">USART_SetAddress</span><span class="params">(USART_TypeDef* USARTx, <span class="keyword">uint8_t</span> USART_Address)</span></span>;</span><br></pre></td></tr></table></figure>

<h5 id="唤醒函数"><a href="#唤醒函数" class="headerlink" title="唤醒函数"></a>唤醒函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">USART_WakeUpConfig</span><span class="params">(USART_TypeDef* USARTx, <span class="keyword">uint16_t</span> USART_WakeUp)</span></span>;</span><br></pre></td></tr></table></figure>

<h5 id="LIN函数"><a href="#LIN函数" class="headerlink" title="LIN函数"></a>LIN函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">USART_ReceiverWakeUpCmd</span><span class="params">(USART_TypeDef* USARTx, FunctionalState NewState)</span></span>;</span><br></pre></td></tr></table></figure>

<h5 id="发送数据函数"><a href="#发送数据函数" class="headerlink" title="发送数据函数"></a>发送数据函数</h5><p>写DR寄存器</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">USART_SendData</span><span class="params">(USART_TypeDef* USARTx, <span class="keyword">uint16_t</span> Data)</span></span>;</span><br></pre></td></tr></table></figure>

<h5 id="接收数据"><a href="#接收数据" class="headerlink" title="接收数据"></a>接收数据</h5><h5 id="读DR寄存器函数"><a href="#读DR寄存器函数" class="headerlink" title="读DR寄存器函数"></a>读DR寄存器函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">uint16_t</span> <span class="title">USART_ReceiveData</span><span class="params">(USART_TypeDef* USARTx)</span></span>;</span><br></pre></td></tr></table></figure>

<h5 id="智能卡、IrDA函数"><a href="#智能卡、IrDA函数" class="headerlink" title="智能卡、IrDA函数"></a>智能卡、IrDA函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">USART_SendBreak</span><span class="params">(USART_TypeDef* USARTx)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">USART_SetGuardTime</span><span class="params">(USART_TypeDef* USARTx, <span class="keyword">uint8_t</span> USART_GuardTime)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">USART_SetPrescaler</span><span class="params">(USART_TypeDef* USARTx, <span class="keyword">uint8_t</span> USART_Prescaler)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">USART_SmartCardCmd</span><span class="params">(USART_TypeDef* USARTx, FunctionalState NewState)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">USART_SmartCardNACKCmd</span><span class="params">(USART_TypeDef* USARTx, FunctionalState NewState)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">USART_HalfDuplexCmd</span><span class="params">(USART_TypeDef* USARTx, FunctionalState NewState)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">USART_OverSampling8Cmd</span><span class="params">(USART_TypeDef* USARTx, FunctionalState NewState)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">USART_OneBitMethodCmd</span><span class="params">(USART_TypeDef* USARTx, FunctionalState NewState)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">USART_IrDAConfig</span><span class="params">(USART_TypeDef* USARTx, <span class="keyword">uint16_t</span> USART_IrDAMode)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">USART_IrDACmd</span><span class="params">(USART_TypeDef* USARTx, FunctionalState NewState)</span></span>;</span><br></pre></td></tr></table></figure>

<h5 id="在中断函数外获取标志位函数"><a href="#在中断函数外获取标志位函数" class="headerlink" title="在中断函数外获取标志位函数"></a>在中断函数外获取标志位函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">FlagStatus <span class="title">USART_GetFlagStatus</span><span class="params">(USART_TypeDef* USARTx, <span class="keyword">uint16_t</span> USART_FLAG)</span></span>;</span><br></pre></td></tr></table></figure>

<h5 id="在中断函数外清除标志位函数"><a href="#在中断函数外清除标志位函数" class="headerlink" title="在中断函数外清除标志位函数"></a>在中断函数外清除标志位函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">USART_ClearFlag</span><span class="params">(USART_TypeDef* USARTx, <span class="keyword">uint16_t</span> USART_FLAG)</span></span>;</span><br></pre></td></tr></table></figure>

<h5 id="在中断函数内获取标志位函数"><a href="#在中断函数内获取标志位函数" class="headerlink" title="在中断函数内获取标志位函数"></a>在中断函数内获取标志位函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ITStatus <span class="title">USART_GetITStatus</span><span class="params">(USART_TypeDef* USARTx, <span class="keyword">uint16_t</span> USART_IT)</span></span>;</span><br></pre></td></tr></table></figure>

<h5 id="在中断函数内清除标志位函数"><a href="#在中断函数内清除标志位函数" class="headerlink" title="在中断函数内清除标志位函数"></a>在中断函数内清除标志位函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">USART_ClearITPendingBit</span><span class="params">(USART_TypeDef* USARTx, <span class="keyword">uint16_t</span> USART_IT)</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="串口通信程序示例"><a href="#串口通信程序示例" class="headerlink" title="串口通信程序示例"></a>串口通信程序示例</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Serial_Init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE);</span><br><span class="line">	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);</span><br><span class="line">	</span><br><span class="line">	GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;</span><br><span class="line">	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;</span><br><span class="line">	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">	GPIO_Init(GPIOA, &amp;GPIO_InitStructure);</span><br><span class="line">	</span><br><span class="line">	USART_InitTypeDef USART_InitStructure;</span><br><span class="line">	USART_InitStructure.USART_BaudRate = <span class="number">9600</span>;<span class="comment">//波特率</span></span><br><span class="line">	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;<span class="comment">//无流控</span></span><br><span class="line">	USART_InitStructure.USART_Mode = USART_Mode_Tx;<span class="comment">//发送模式</span></span><br><span class="line">	USART_InitStructure.USART_Parity = USART_Parity_No;<span class="comment">//无校验位</span></span><br><span class="line">	USART_InitStructure.USART_StopBits = USART_StopBits_1;<span class="comment">//停止位一位</span></span><br><span class="line">	USART_InitStructure.USART_WordLength = USART_WordLength_8b;<span class="comment">//8位1字节</span></span><br><span class="line">	USART_Init(USART1, &amp;USART_InitStructure);</span><br><span class="line">	</span><br><span class="line">	USART_Cmd(USART1, ENABLE);<span class="comment">//开启串口</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Serial_SendByte</span><span class="params">(<span class="keyword">uint8_t</span> Byte)</span><span class="comment">//发送字符</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	USART_SendData(USART1, Byte);</span><br><span class="line">	<span class="keyword">while</span> (USART_GetFlagStatus(USART1, USART_FLAG_TXE) == RESET);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Serial_SendArray</span><span class="params">(<span class="keyword">uint8_t</span> *Array, <span class="keyword">uint16_t</span> Length)</span><span class="comment">//发送数组</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">uint16_t</span> i;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; Length; i ++)</span><br><span class="line">	&#123;</span><br><span class="line">		Serial_SendByte(Array[i]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Serial_SendString</span><span class="params">(<span class="keyword">char</span> *String)</span><span class="comment">//发送字符串</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">uint8_t</span> i;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; String[i] != <span class="string">&#x27;\0&#x27;</span>; i ++)</span><br><span class="line">	&#123;</span><br><span class="line">		Serial_SendByte(String[i]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">Serial_Pow</span><span class="params">(<span class="keyword">uint32_t</span> X, <span class="keyword">uint32_t</span> Y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">uint32_t</span> Result = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (Y --)</span><br><span class="line">	&#123;</span><br><span class="line">		Result *= X;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> Result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Serial_SendNumber</span><span class="params">(<span class="keyword">uint32_t</span> Number, <span class="keyword">uint8_t</span> Length)</span><span class="comment">//发送数字</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">uint8_t</span> i;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; Length; i ++)</span><br><span class="line">	&#123;</span><br><span class="line">		Serial_SendByte(Number / Serial_Pow(<span class="number">10</span>, Length - i - <span class="number">1</span>) % <span class="number">10</span> + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fputc</span><span class="params">(<span class="keyword">int</span> ch, FILE *f)</span><span class="comment">//重定向printf</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Serial_SendByte(ch);</span><br><span class="line">	<span class="keyword">return</span> ch;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Serial_Printf</span><span class="params">(<span class="keyword">char</span> *format, ...)</span><span class="comment">//重定向printf多串口使用</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> String[<span class="number">100</span>];</span><br><span class="line">	va_list arg;</span><br><span class="line">	va_start(arg, format);</span><br><span class="line">	<span class="built_in">vsprintf</span>(String, format, arg);</span><br><span class="line">	va_end(arg);</span><br><span class="line">	Serial_SendString(String);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="串口收发数据包"><a href="#串口收发数据包" class="headerlink" title="串口收发数据包"></a>串口收发数据包</h3><p>数据包的作用是：把一个个单独的数据给打包起来，方便进行多字节的数据通信，例如，陀螺仪传感器，需要用串口发送数据到STM32，陀螺仪的数据，X轴为一个字节、Y轴为一个字节、Z轴一个字节，一共3个数据需要连续不断的发送，当我像这样XYZXYZXYZ连续发送的时候，接受方不知道这个数据哪个对应Y，哪个对应X，哪个对应Z，因为接收方可能从任意的位置接收，所以可能出现数据错位的现象，我们需要一种方式把数据进行分割，把XYZ这一批数据分割开来，分割成一批批数据包，这样在接收的时候，就知道了，数据包第一个数据就是X，数据包第二个数据就是Y，数据包第三个数据就是Z，这就是数据包的任务，就是把同一批的数据进行打包和分割。</p>
<p>串口数据包，通常使用的是额外添加包头包尾的这种方式</p>
<p>防止数据包包头包尾和数据重复的方法，第一种，限制载荷数据的范围，在发送的时候对数据进行限幅，第二种，尽量使用固定长度的数据包，第三种，增加包头包尾的数量，并且让它尽量呈现出载荷数据出现不了的状态。</p>
<h5 id="串口收发Hex数据包"><a href="#串口收发Hex数据包" class="headerlink" title="串口收发Hex数据包"></a>串口收发Hex数据包</h5><p><img src="https://gitee.com/pu-heliang/photos/raw/master/img/202301032050993.png" alt="image-20221228025831646"></p>
<h5 id="串口收发文本数据包"><a href="#串口收发文本数据包" class="headerlink" title="串口收发文本数据包"></a>串口收发文本数据包</h5><p><img src="https://gitee.com/pu-heliang/photos/raw/master/img/202301032050392.png" alt="image-20221228031427199"></p>
<h5 id="数据包的收发流程"><a href="#数据包的收发流程" class="headerlink" title="数据包的收发流程"></a>数据包的收发流程</h5><h5 id="数据包的发送"><a href="#数据包的发送" class="headerlink" title="数据包的发送"></a>数据包的发送</h5><p>数据包的接收</p>
<p>接收固定包长的数据包，设计一种能够记住不同状态的机制，在不同状态执行不同的操作，同时还要进行状态的合理转移，这种程序设计思维叫做“状态机”。</p>
<p><img src="https://gitee.com/pu-heliang/photos/raw/master/img/202301032051259.png" alt="image-20221228032032420"></p>
<p>第一个状态是等待包头，第二个状态是接收数据，第三个状态是等待包尾，每个状态需要一个变量来标志一下，类似于置置标志位，标志位只有0和1，状态机是多标志位的一种方式</p>
<p>执行流程是最开始S = 0，收到一个数据，进中断，根据S = 0，进入第一个状态的程序，判断数据是不是包头FF，如果是FF，则代表收到包头，之后置S = 1，退出中断，结束，这样下次再进中断，根据S = 1，就可以进行接收数据的程序了，在第一个状态，如果收到的不是FF就说明数据包没有对齐，应该等待数据包包头的出现，这时状态仍然是0，下次进中断，就还是判断包头的逻辑，直到出现FF，才能转到下一个状态，之后出现了FF，就可以转移到接收数据的状态了，这时再收到数据，就可以直接把它存在数据中，另外再用一个变量，记录收了多少个数据，如果没收够4个，就一直是接收状态，如果收够了，就置S = 2，下次进中断时，就可以进入下一个状态了，最后一个状态就是等待包尾，判断数据是不是FE，这样就可以置S = 0，回到最初的状态，开始下一个轮回。</p>
<p>状态机使用的基本步骤：先根据项目要求，画几个圈，考虑好各个状态在什么情况下会进行转移，如何转移，画好线和转移条件，最后根据图来进行编程，例如，做个菜单，按什么键，切换什么菜单，执行什么程序。</p>
<p><img src="https://gitee.com/pu-heliang/photos/raw/master/img/202301032051552.png" alt="image-20221228033422462"> </p>
<h3 id="I2C"><a href="#I2C" class="headerlink" title="I2C"></a>I2C</h3><ul>
<li>I2C总线（Inter IC Bus）</li>
<li>两根通信线：SCL（Serial Clock）、SDA（Serial Data）</li>
<li>同步，半双工</li>
<li>带数据应答</li>
<li>支持总线挂在多设备（一主多从、多主多从）</li>
<li>起始条件：SCL高电平期间，SDA从高电平切换到低电平</li>
<li>终止条件：SCL高电平期间，SDA从低电平切换到高电平</li>
<li>每个时序单元的SCL都是以低电平开始，低电平结束</li>
<li>从机不允许产生起始和终止</li>
</ul>
<p><img src="https://gitee.com/pu-heliang/photos/raw/master/img/202301032051634.png" alt="image-20221225003129365"></p>
<ul>
<li>发送一个字节：SCL低电平期间，主机将数据位依次放到SDA线上（高位先行），然后释放SCL，从机将在SCL高电平期间读取数据位，所以SCL高电平期间SDA不允许有数据变化，依次循环上述过程8次即可发生一个字节</li>
</ul>
<p><img src="https://gitee.com/pu-heliang/photos/raw/master/img/202301032051462.png" alt="image-20221226205443369"></p>
<ul>
<li><p>主机拉低SCL，把数据放在SDA上，主机松开SCL，从机读取SDA的数据</p>
</li>
<li><p>（高位先行）在SCL低电平期间，主机如果想要发送0，就拉低SDA到低电平，如果想要发送1，就放手，SDA回弹到高电平，在SCL低电平期间允许改变SDA的电平，当这一位放好后，主机就松手时钟线，SCL回弹到高电平，在高电平期间是从机读取SDA的时候，SCL高电平期间，SDA不允许变化，SDA处于高电平时从机需要尽快读取SDA，一般是在上升沿的时刻，从机已经读取完成了，主机在放手SCL一段时间后，就可以继续拉低SCL传输下一位，主机需要在SCL下降沿之后尽快把数据放在SDA上，主机有时钟的主导权，不需要着急，只需要在低电平的任意时刻把数据放在SDA上就行了，数据放完之后，主机再松手SCL，SCL高电平从机读取这一位，在SCL的同步下，依次进行主机发送和从机接收，循环8次就发送了8位数据，也就是一个字节。</p>
</li>
<li><p>接收一个字节：SCL低电平期间，从机将数据位依次放到SDA线上（高位先行），然后释放SCL，主机将在SCL高电平期间读取数据位，所以SCL高电平期间期间SDA不允许有数据变化，依次循环上述过程8次，即可接收一个字节（主机再接收之前，需要释放SDA，释放SDA就相当于切换为输入模式）。</p>
</li>
</ul>
<p><img src="https://gitee.com/pu-heliang/photos/raw/master/img/202301032051676.png" alt="image-20221225004611284"></p>
<ul>
<li><p>也可以理解为：所有设备包括主机始终都属于输入模式，当主机需要发送的时候，就可以去主动拉低SDA，而主机再被动接收的时候，就必须先释放SDA，总线是线与的特征，任何一个设备拉低了，总线就是低电平，如果接收的时候还拽着SDA不放手，无论别人发什么数据，总线都始终属于是低电平。</p>
</li>
<li><p>发送应答：主机在接收完一个字节之后，在下一个时钟发送一位数据，数据0表示应答，数据1表示非应答</p>
</li>
<li><p>接收应答：主机在发送完一个字节之后，在下一个时钟接收一位数据，判断从机是否应答，数据0表示应答，数据1表示非应答（主机在接收之前，需要释放SDA）</p>
</li>
</ul>
<p><img src="https://gitee.com/pu-heliang/photos/raw/master/img/202301032051606.png" alt="image-20221225005553172"></p>
<ul>
<li>也可以理解为发送1位和接收1位，这一位用来作为应答，在发送完一个数据之后，就要立即进行接收应答，来判断从机是否接收到主机发送的数据</li>
<li>主机在起始条件之后，要先发送一个字节叫一下从机名字，所有从机都会收到第一个字节，与自己的名字（地址）比较，如果一样，相对应的从机就会响应主机的读写操作，在同一条I2C总线里，挂在的每个设别地址必须不一样，防止主机叫一个地址有多个设备都响应。</li>
<li>从机设备地址，在I2C协议标准里分为7位地址和10位地址</li>
<li>每个I2C设厂时，厂商都会为它分配一个7位的地址、</li>
<li>MPU6050的地址是：1101 000</li>
<li>一般不同型号的设备地址都是不同的，相同型号的设备地址都是相同的</li>
<li>如果相同型号的设备挂在在同一条总线上，可以利用设备的地址的可变部分，一般器件地址的最后几位是可以在电路中改变的，例如MPU6050地址的最后一位，由板子上的AD0引脚确定，AD0引脚接低电平，那它的地址就是1101 000，AD0引脚接高电平那它的地址就是1101 001，AT24C02地址的最后三位都可以分别由这个板子上的A0、A1、A2引脚确定</li>
</ul>
<h4 id="指定地址写"><a href="#指定地址写" class="headerlink" title="指定地址写"></a>指定地址写</h4><ul>
<li><p>对于指定设备（Slave Address），在指定地址（Reg Address）下写入数据（Data）</p>
</li>
<li><p>空闲状态下两个总线都是高电平，主机需要给从机写入数据的时候，在SCL高电平期间，拉低SDA，产生起始条件，在起始条件之后紧跟的时序，必须是发送一个字节的时序，字节的内容必须是从机地址+读写位，（从机地址是7位，读写位是1位加起来就是1个字节8位）（发送从机地址：确定通信的对象），（发送读写位：确认接下来是要写入还是读出，0：写入，1：读出），紧跟着的单元是接收从机的应答位(Receive Ack,RA),这个时刻主机需要释放SDA，如果从机应答，从机会立即拉低SDA，应答位产生后，从机释放SDA，从机交出SDA的控制权，同样的时序再来一遍，第二个字节数据就会送入指定数据的内部，一般第二个字节是寄存器地址或者是指令控制字，第三个字节是想要往寄存器地址中写入的值，如果主机不想发送数据了，要产生停止条件，在产生停止条件之前，先拉低SDA，会后续的上升沿做准备，然后释放SCL，再释放SDA，产生SCL高电平期间SDA的上升沿</p>
</li>
</ul>
<p><img src="https://gitee.com/pu-heliang/photos/raw/master/img/202301032051953.png" alt="image-20221228195109520"></p>
<ul>
<li>此数据帧的作用是：对于从机地址为1101000的设备在其内部0x19地址的寄存器中，写入0xAA这个数据</li>
</ul>
<h4 id="当前地址读"><a href="#当前地址读" class="headerlink" title="当前地址读"></a>当前地址读</h4><ul>
<li>对于不指定设别（Slave Address），在当前地址指针指示的地址下，读取从机数据（Data）</li>
</ul>
<p><img src="https://gitee.com/pu-heliang/photos/raw/master/img/202301032051730.png" alt="image-20221228195140964"></p>
<ul>
<li>在SCL高电平期间，拉低SDA，产生起始条件，主机首先发送一个字节，来进行从机的寻址和读写标志位，图示波形代表，本次寻址的目标是1101000的设备，读写标志为1，表示主机接下来想要读取设备，发送一个字节后，接收从机应答位，代表从机收到了第一个字节，把SDA的控制权交给从机，主机调用接收一个字节的时序，进行接收操作，从机接收到了主机的允许，可以在SCL低电平期间写入SDA，主机在哪SCL高电平期间读取SDA，主机再SCL高电平期间依次读取8位，就接收到了从机发送的一个字节数据0000 1111也就是（0x0F），没有指定地址这个环节，0x0F，（在从机中所有寄存器被分配到了一个线性区域中，会有个单独的指针变量，指示着其中一个寄存器，这个指针上电一般默认0地址，每写入一个字节或者读出一个字节后，这个指针就是自动自增一次，移动到下一个位置），从机返回的是当前指针指向的寄存器的值</li>
</ul>
<h4 id="指定地址读"><a href="#指定地址读" class="headerlink" title="指定地址读"></a>指定地址读</h4><ul>
<li>对于指定设备（Slave Address），在指定地址（Reg Address）下读取从机数据（Data）</li>
</ul>
<p><img src="https://gitee.com/pu-heliang/photos/raw/master/img/202301032052615.png" alt="image-20221225014731596"></p>
<ul>
<li>指定从机地址是1101000 读写标志位是0，代表要进行写的操作，经过从机应答后，在发送一个字节第二个字节0001 1001，用来指定地址，这个数据就写入到从机的地址指针里了，从机接收到这个地址后，它的寄存器指针就指向了0x19这个位置，不给从机发要写入的数据，而是再来个起始条件，起始条件后，重新寻址并且指定读写标志位，此时读写标志位为1代表开始读，继续主机接收一个字节，这个字节数据就是0x19地址下的数据。</li>
</ul>
<p>写多个字节：重复三遍，发送一个字节和接收应答，第一个数据就写入0x19的位置（写入一个地址后地址指针会自动+1，编程吧0x1A）第二个数据就会写到0x1A的位置，第三个数据写入的是0x1B的位置</p>
<p>S欧拉角：飞机与XYZ轴的夹角，反应了飞机的姿态，侧仰，上倾，下倾；</p>
<p>获得欧拉角需要多个数据，常用的数据融合算法：互补滤波、卡尔曼滤波等</p>
<p>MPU6050 XCL和SDA是扩展使用，通常是外接磁力计或者气压计</p>
<h3 id="I2C外设"><a href="#I2C外设" class="headerlink" title="I2C外设"></a>I2C外设</h3><p>STM32内部集成了硬件收发电路，可以由硬件自动执行时钟生成、起始终止条件生成、应答位收发、数据收发等功能，软件只需要写入控制寄存器CR和数据寄存器DR就可以实现协议，为了实时监控时序的状态，软件还需要读取状态寄存器SR，来了解外设电路当前处于什么状态，类似于开车，写入控制寄存器CR，就像是踩油门、打方向盘来控制汽车的运行，读取状态寄存器SR，就像是观看仪表盘，来观测汽车的运行状态，有了这些寄存器，就可以完全掌握外设电路的运行了，同时也可以减轻CPU的负担，</p>
<ul>
<li>支持多主机模型</li>
<li>支持7位/10位地址模式</li>
<li>支持不同的通讯速度，标准速度(高达100kHz)，快速(高达400kHz)</li>
<li>支持DMA</li>
<li>兼容SMBus协议</li>
<li>STM32F103C8T6 硬件I2C资源：I2C1、I2C2</li>
</ul>
<p>I2C通信，分为主机和从机，主机拥有主动控制总线的权利，从机只能在主机允许的情况下，才能控制总线，主机一个人掌控所有，不存在权利冲突</p>
<p><img src="https://gitee.com/pu-heliang/photos/raw/master/img/202301131852537.png" alt="image-20230113185249502"></p>
<p>进阶版的I2C设计了多主机的模型，多主机模型分为固定多主机和可变多主机，固定多主机就是总线上有两个或多个固定的主机，上面几个始终固定为主机，下面的几个时钟固定为从机，就像是教室里讲台上站了多个老师，下面坐的学生可以被任意一个老师点名，老师可以主动发起对学生的控制，学生不能控制老师，当两个老师同时想说话就是总线冲突状态，这时要进行总线仲裁，仲裁失败的一方让出总线控制权，这种讲台上站多个老师的情况就是固定多主机。</p>
<p><img src="https://gitee.com/pu-heliang/photos/raw/master/img/202301131853676.png" alt="image-20230113185309643"></p>
<p>可变多主机就是，总线上可以挂载多个设备，总线上没有固定的主机和从机，任何一个设备都可以在总线空闲时跳出来作为主机，然后指定其他任何一个设备进行通信，当这个通信完成后，跳出来的主机要退回从机的位置，就像是在教室里，只有一堆学生，没有老师，默认情况下，所有学生都是从机，都不能说话，当有某个学生想说话 时，站出来变成主机，然后指定其他任何一个学生进行通信，通信完成后坐下变成从机。当有多个学生同时跳出来时，就是总线冲突状态，这时要进行总线仲裁，仲裁失败的一方让出总线控制权，这种所有设备一视同仁，谁做主机谁跳出来的模型，就是可变多主机，对stm32的I2C使用的是可变多主机的模型</p>
<p><img src="https://gitee.com/pu-heliang/photos/raw/master/img/202301131853476.png" alt="image-20230113185326426"></p>
<p>I2C起始之后的第一个字节，必须是寻址+读写位，一个字节只能有7位地址，只需要在规定，起始位之后的前两个字节，都作为寻址，就可以完成10位地址寻址，这就是10位地址的基本思路，第一个字节有7个空位，第二个字节，有8ge空位，加一起是15位地址，但是I2C只有10位地址模式，还剩下5位当标志位，因为发送第一个字节后，不知道后面这个字节是不是寻址，所以需要再第一个字节写个特定的数据，作为10位寻址位的标志位，标志位就是11110，也就是第二个字节如果也是寻址，那第一个字节的前5位就必须是11110，如果前5位是11010，就说明它是7位寻址，如果前五位是11110，那第一个字节剩下的两位，和第二个字节的8位，都作为寻址，这就组成了10位地址，11110作为10位地址模式的标志位，不会在7位地址模式下出现的，这就是7位地址和10位地址的1区别。</p>
<p>支持DMA可以在多字节传输的时候提高传输效率，比如指定地址读多字节或写多字节的时序，如果想要连续读或者写非常多的字节那用一下DMA自动帮忙转运数据，这个过程的效率就会大大提升，如果只有几个字节就没必要用DMA了。</p>
<p>兼容SMBus（System Management Bus）协议，是系统管理总线，SMBus是基于I2C总线改建而来的，主要用于电源管理系统中。</p>
<p>I2C外设的框图：</p>
<p><img src="https://gitee.com/pu-heliang/photos/raw/master/img/202301131910399.png" alt="image-20230113191059347"></p>
<p>上图是STM32内部I2C外设的结构图</p>
<p>左边是外设的通信引脚SDA和SCL，SMBALERT是SMBus用的，这种外设模块引出来的引脚，一般都是借助GPIO口的复用模式与外部世界相连的。</p>
<p>上面的那部分是SDA，数据控制部分，数据收发的核心部分是数据寄存器和数据移位寄存器，当我们需要发送数据时，可以把一个字节数据写到数据寄存器DR，当移位寄存器没没有数据移位时这个数据寄存器的值就会进一步转到移位寄存器里，在移位的过程中把下一个数据放到数据寄存器里等着了，一旦前一个数据移位完成，下一个数据就可以无缝衔接，继续发送，当数据从数据寄存器转运到移位寄存器时，就会置状态寄存器的TXE位为1，表示发送寄存器为空，这是发送的流程，在接收时，输入的数据，一位一位地，从引脚移入到移位寄存器里，当一个字节的数据收齐之后，数据就整体从移位寄存器转到数据寄存器，同时置标志位RXNE，表示接受寄存器非空，这时候就可以把数据从数据寄存器读出来了。I2C是半双工，所以数据收发是同一组数据寄存器和移位寄存器比较器和地址寄存器这是从机模式使用的，STM32的I2C是基于可变多主机模型设计的，STM32不进行通信的时候,就是从机，作为从机，就能被别人召唤，它就应该有从机地址，从机地址由自身地址寄存器指定，可以自定一个从机地址，写到这个自身地址寄存器，当STM32作为从机，被寻址时，如果收到的寻址通过比较器判断，和自身地址相同那STM32就作为从机，响应外部主机的召唤，并且STM32支持同时响应两个从机地址，所以就有自身地址寄存器和双地址寄存器，这里需要再多主机模式下理解，STM32作为从机才需要有这部分，STM32一般是一主多从的模型，STM32不会作为从机，所以这一块就不需要用。右边是STM32设计的数据校验模块，当我们发生多字节的数据帧时，在这里硬件可以自动执行CRC校验计算，CRC是一种常见的数据校验算法，它会根据前面的数据，进行各种数据运算，然后会得到一个字节的校验位，附加在数据帧后面，在接收到这一帧数据后，STM32硬件也可以自动执行校验的判定，如果数据在传输的过程中出错了，CRC校验算法就通不过，硬件就会置校验错误标志位，告诉你数据错了，类似于串口的奇偶校验，也是进行数据有效性验证的。</p>
<p>再看SCL部分，时钟控制是用来控制SCL线的，在时钟控制寄存器写对应位，电路就会执行对应的功能，写入控制寄存器，可以对整个控制逻辑电路进行控制，读取状态寄存器，可以得知电路的工作状态。内部有一些标志位置1后，可以申请中断，如果开启了中断，当事件发生后，程序就可以跳到中断函数来处理这个事件了，在很多字节进行收发时，可以配个DMA提高效率，这些就是I2C外设的框图</p>
<p>基本结构图：</p>
<p><img src="https://gitee.com/pu-heliang/photos/raw/master/img/202301131958678.png" alt="image-20230113195826630"></p>
<p>移位寄存器和数据寄存器DR的配合是通信的核心部分，因为I2C是高位先行所以，这个移位寄存器是向左移位，在发送的时候，最高位先移出去，然后是次高位，等等，一个SCL时钟，移位一次，移位8次，这样就能把一个字节由高位到低位，依次放到SDA线上了，在接收的时候，数据通过GPIO口从右边依次移进来，最终移8次，一个字节就接受完成了，之后GPIO口使用硬件I2C的时候，这两个对应的GPIO口都要配置成复用开漏输出的模式，复用，就是GPIO口的状态是交由片上外设来控制的，开漏输出，这是I2C协议里要求的端口配置，SCL这里时钟控制器通过GPIO去控制时钟线，这里简化成一主多从的模型，时钟这里只画了输出的方向，实际上，如果是多主机的模型，时钟线也是会进行输入的，这个时钟的输入可以先不管，SDA的部分输出数据，输出到端口，输入数据也是通过GPIO，输入到移位寄存器。最后打开开关控制</p>
<h4 id="主机发送"><a href="#主机发送" class="headerlink" title="主机发送"></a>主机发送</h4><p><img src="https://gitee.com/pu-heliang/photos/raw/master/img/202301132010735.png" alt="image-20230113201052661"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/04/27/CUDA-SGEMM%E4%BC%98%E5%8C%96%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/04/27/CUDA-SGEMM%E4%BC%98%E5%8C%96%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">CUDA SGEMM优化笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-04-27 17:27:01 / Modified: 17:31:20" itemprop="dateCreated datePublished" datetime="2023-04-27T17:27:01+08:00">2023-04-27</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>blockDim.x</p>
<p>ptxas info    : Used 63 registers, 8192 bytes smem, 368 bytes cmem[0]<br>ptxas info    : Compiling entry function ‘_Z18sgemm2DBlocktilingILi64ELi64ELi8ELi8ELi8EEviiifPKfS1_fPf’ for ‘sm_30’<br>ptxas info    : Function properties for _Z18sgemm2DBlocktilingILi64ELi64ELi8ELi8ELi8EEviiifPKfS1_fPf<br>    104 bytes stack frame, 260 bytes spill stores, 184 bytes spill loads</p>
<pre><code>ptxas info    : Used 63 registers, 8192 bytes smem, 368 bytes cmem[0]
</code></pre>
<p>ptxas info    : Compiling entry function ‘_Z18sgemm2DBlocktilingILi64ELi64ELi8ELi8ELi8EEviiifPKfS1_fPf’ for ‘sm_30’<br>ptxas info    : Function properties for _Z18sgemm2DBlocktilingILi64ELi64ELi8ELi8ELi8EEviiifPKfS1_fPf<br>    600 bytes stack frame, 1636 bytes spill stores, 1440 bytes spill loads</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/04/25/CUDA-prefix-scan%E4%BC%98%E5%8C%96%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/04/25/CUDA-prefix-scan%E4%BC%98%E5%8C%96%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">CUDA prefix scan优化笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-04-25 20:11:31" itemprop="dateCreated datePublished" datetime="2023-04-25T20:11:31+08:00">2023-04-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-04-26 01:04:58" itemprop="dateModified" datetime="2023-04-26T01:04:58+08:00">2023-04-26</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="什么是prefix-scan"><a href="#什么是prefix-scan" class="headerlink" title="什么是prefix scan"></a>什么是prefix scan</h2><p>前缀和是一个很常见的操作，刷LC的时候，也有很多题需要用到前缀和，以达到减少计算量的效果，最近一次用到前缀和是在写SPGEMM的时候，在symbolic阶段，我们计算出了一个长度为m的向量nnz，nnz[i]表示结果C中第i行有多少个非零的结果，需要计算的矩阵C需要按CSR格式储存，其中col和val数组被分成多个段，每一个段代表对应稠密的一行，而段的起始和结束位置由row数组来指示，具体来说，row[i]表示起始位置，row[i+1]代表结束位置， 也就是<code>val[row[i]]</code> 至val<code>[row[i+1]]</code>是第i行的数据(注意不包括<code>[row[i+1]]</code>， 是一个左闭右开的区间)。 因此求前缀和就理所当然了，而且是exclusive scan, 因为第i个位置的结果<code>f[i]</code>不包含第i个输入。 <code>f[i]</code>可以理解为前i-1行有多少个非0元素。</p>
<h2 id="double-buffered-version"><a href="#double-buffered-version" class="headerlink" title="double buffered version"></a>double buffered version</h2><p>首先是双缓冲版本：<br><img src="/../imgs/2023-04-25-20-31-00.png"></p>
<p>示意图如下：<br><img src="/../imgs/2023-04-25-20-31-26.png"></p>
<p>这是一个nlogn的算法，<br>证明如下：<br><img src="/../imgs/2023-04-25-22-08-29.png"></p>
<p>第i次迭代，有2*(i-1)个结果被计算出来，所以下一次参与计算线程个数会减少2^(i-1)，因此第i次迭代，所有线程操作次数是2^M-2^(i-1)， i取值从0到M-1。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__global__ <span class="keyword">void</span> <span class="title">scan</span><span class="params">(<span class="keyword">float</span> *g_odata, <span class="keyword">float</span> *g_idata, <span class="keyword">int</span> n)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">extern</span>  __shared__  <span class="keyword">float</span> temp[]; <span class="comment">// allocated on invocation </span></span><br><span class="line">    <span class="keyword">int</span> thid = threadIdx.x; </span><br><span class="line">    <span class="keyword">int</span> pout = <span class="number">0</span>, pin = <span class="number">1</span>; </span><br><span class="line">    <span class="comment">// load input into shared memory.  </span></span><br><span class="line">    <span class="comment">// This is exclusive scan, so shift right by one and set first elt to 0 </span></span><br><span class="line">    temp[pout*n + thid] = (thid &gt; <span class="number">0</span>) ? g_idata[thid<span class="number">-1</span>] : <span class="number">0</span>; </span><br><span class="line">    __syncthreads(); </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> offset = <span class="number">1</span>; offset &lt; n; offset *= <span class="number">2</span>) </span><br><span class="line">    &#123; </span><br><span class="line">        pout = <span class="number">1</span> - pout; <span class="comment">// swap double buffer indices </span></span><br><span class="line">        <span class="comment">// 这里应该写错了， pin = 1-pin才对</span></span><br><span class="line">        pin  = <span class="number">1</span> - pout; </span><br><span class="line">        <span class="keyword">if</span> (thid &gt;= offset) </span><br><span class="line">            temp[pout*n+thid] += temp[pin*n+thid - offset]; </span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            temp[pout*n+thid] = temp[pin*n+thid]; </span><br><span class="line">        __syncthreads(); </span><br><span class="line">    &#125; </span><br><span class="line">    g_odata[thid] = temp[pout*n+thid1]; <span class="comment">// write output </span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>上面这段算法问题在于复杂度不如串行低，而且只能处理一个block可以处理的数据，如果一个block最多可以有512个线程，那么数组长度最多为1024. 因此大佬提出了基于平衡树的算法。</p>
<h2 id="work-efficient-算法"><a href="#work-efficient-算法" class="headerlink" title="work efficient 算法"></a>work efficient 算法</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>这个算法使用了平衡树，但是并不是在GPU上使用平衡树这种数据结构，而是用来决定每次迭代，每个线程应该做什么。说起来很抽象，看图应该很清晰。算法分为两个阶段。</p>
<ul>
<li>第一个阶段自底向上从叶子到根遍历，作用是构建部分和，每一个root的值都是其所有叶子节点之和。</li>
<li>第二个阶段自顶向下从root到leaves遍历，根据partial sum来构建scan。</li>
</ul>
<h3 id="算法过程"><a href="#算法过程" class="headerlink" title="算法过程"></a>算法过程</h3><p>第一个阶段如下：<br><img src="/../imgs/2023-04-25-22-31-03.png"></p>
<p>第二个阶段：<br><img src="/../imgs/2023-04-25-22-32-04.png"></p>
<p>代码如下：<br><img src="/../imgs/2023-04-25-22-32-57.png"></p>
<p>看这个代码的时候，觉得确实应该是这样，很巧妙，但是自己想肯定大概率是想不出来的。 分析一下代码，首先是每个线程加载2个元素到smem中，0号线程加载内存位置为0,1， 1号线程加载2，3，… 这样的模式，可以预见，应该是会产生bank conflict的，因为第16个线程会加载内存位置为32，33的元素，和0号线程加载的内存位置在同一个bank。 接下来，进入循环，</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">这里有一个假设，如果block中线程个数为<span class="number">512</span>， n一定是<span class="number">1024</span>, 第一轮肯定是相邻的元素相加，这会得到<span class="number">512</span>个结果，所以需要用<span class="number">512</span>个线程。</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> d = n&gt;&gt;<span class="number">1</span>; d &gt; <span class="number">0</span>; d &gt;&gt;= <span class="number">1</span>) <span class="comment">// build sum in place up the tree </span></span><br><span class="line">&#123; </span><br><span class="line">    __syncthreads(); </span><br><span class="line">    <span class="keyword">if</span> (thid &lt; d)    </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="comment">// bi是线程要写入的数组下标， 可以观察到如果将线程id+1，那么</span></span><br><span class="line">        <span class="comment">// 第一轮迭代写入的下标就是2*(thid+1)， 第二轮迭代写入的下标bi会</span></span><br><span class="line">        <span class="comment">// 加倍，offset的作用就是这个，它每轮迭代会加倍，因此bi=offset*2*(thid+1)</span></span><br><span class="line">        <span class="comment">// 但是要注意， 下标是从0开始的，所以所有下标都要减1，而ai可以看出，和bi相差offset。因此ai=bi-offset</span></span><br><span class="line">        <span class="keyword">int</span> ai = offset*(<span class="number">2</span>*thid+<span class="number">1</span>)<span class="number">-1</span>; </span><br><span class="line">        <span class="keyword">int</span> bi = offset*(<span class="number">2</span>*thid+<span class="number">2</span>)<span class="number">-1</span>; </span><br><span class="line">        temp[bi] += temp[ai];         </span><br><span class="line">    &#125; </span><br><span class="line">    offset *= <span class="number">2</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来要清除temp的最后一个位置的元素。然后进行从root到leaves的遍历。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> d = <span class="number">1</span>; d &lt; n; d *= <span class="number">2</span>) <span class="comment">// traverse down tree &amp; build scan </span></span><br><span class="line">&#123; </span><br><span class="line">    offset &gt;&gt;= <span class="number">1</span>; </span><br><span class="line">    __syncthreads(); </span><br><span class="line">    <span class="keyword">if</span> (thid &lt; d) </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="keyword">int</span> ai = offset*(<span class="number">2</span>*thid+<span class="number">1</span>)<span class="number">-1</span>; </span><br><span class="line">        <span class="comment">// int bi = offset*2*(thid+1)-1</span></span><br><span class="line">        <span class="keyword">int</span> bi = offset*(<span class="number">2</span>*thid+<span class="number">2</span>)<span class="number">-1</span>; </span><br><span class="line">        <span class="comment">// 因为没有用double buffer， 所以要先保存ai位置的值，然后再写这个位置</span></span><br><span class="line">        <span class="keyword">float</span> t   = temp[ai]; </span><br><span class="line">        <span class="comment">// 把root的值传到左孩子。</span></span><br><span class="line">        temp[ai]  = temp[bi]; </span><br><span class="line">        <span class="comment">// 把root和左孩子的和写到右孩子</span></span><br><span class="line">        temp[bi] += t; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解决bank-conflict"><a href="#解决bank-conflict" class="headerlink" title="解决bank conflict"></a>解决bank conflict</h3><p>这个代码有个问题需要解决，那就是bank conflict， 解决方案就是使用padding</p>
<p><img src="/../imgs/2023-04-26-00-17-27.png"></p>
<p>我们定义这样的宏：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SHARED_MEMORY_BANKS 32</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOG_MEM_BANKS 5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ROW_BY_32(n) ((n) &gt;&gt; LOG_MEM_BANKS)</span></span><br></pre></td></tr></table></figure>
<p>我们将smem抽象成int smem[][32], ROW_BY_32计算传入的地址属于smem的第几行。第几行。如果我们加了padding，那么smem的定义就会变成int smem[][33], 原本要访问的地址是n：</p>
<ul>
<li>如果属于第0行，那么加padding之后的地址应该变成n+0,</li>
<li>如果属于第1行，那么加padding之后的地址应该变成n+1,</li>
<li>如果属于第2行，那么加padding之后的地址应该变成n+2,</li>
<li>以此类推…</li>
</ul>
<p>可以看出，如果数据有n行，就需要浪费n*4 byte的空间，虽然浪费了空间，但是避免了bank conflict，是一种以时间换空间的思想。一个block的线程是512的话，512/32=16，所以padding会占用64 byte的空间。</p>
<p>一开始我们从全局内存加载数据到smem中的时候，每个线程加载两个相邻的数据，可以知道，第16个线程会加载第32，33个数据，第32个线程会加载第64,65个数据，因此发生了3-way bank conflict， 因此我们改变策略，我们知道，一个block的数据个数是线程个数的2倍，因此将数据分为两半，block的第i个线程加载第<code>g_data[0]</code>和<code>g_data[0+n/2]</code>， 这样可以保证一个warp访问的数据是连续的，因此不会发生bank conflict。代码如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ai = threadID;</span><br><span class="line"><span class="keyword">int</span> bi = threadID + (n / <span class="number">2</span>);</span><br><span class="line"><span class="keyword">int</span> bankOffsetA = <span class="built_in">CONFLICT_FREE_OFFSET</span>(ai);</span><br><span class="line"><span class="keyword">int</span> bankOffsetB = <span class="built_in">CONFLICT_FREE_OFFSET</span>(bi);</span><br><span class="line">temp[ai + bankOffsetA] = input[ai];</span><br><span class="line">temp[bi + bankOffsetB] = input[bi];</span><br></pre></td></tr></table></figure>

<p>root和leaves之间的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ai = offset*(<span class="number">2</span>*thid+<span class="number">1</span>)<span class="number">-1</span>; </span><br><span class="line"><span class="keyword">int</span> bi = offset*(<span class="number">2</span>*thid+<span class="number">2</span>)<span class="number">-1</span>; </span><br><span class="line">ai += <span class="built_in">CONFLICT_FREE_OFFSET</span>(ai); </span><br><span class="line">bi += <span class="built_in">CONFLICT_FREE_OFFSET</span>(bi);</span><br></pre></td></tr></table></figure>
<p>假设offset=1, 那么ai=2*thid, 0~32线程访问的bi为1，3，5，…31,33,<br>三个线程会访问bank0：</p>
<ul>
<li>thid=0,  ai=0</li>
<li>thid=16, ai=32</li>
<li>thid=32, ai=64</li>
</ul>
<p>加了padding之后， ai = ai + ai/32</p>
<ul>
<li>thid=0,  ai=0  + 0 = 0</li>
<li>thid=16, ai=32 + 1 = 33</li>
<li>thid=32, ai=64 + 2 = 66</li>
</ul>
<p>可以看出，他们的bank分别变成了0,1,2，从而避免了bank conflict， bi同理。</p>
<h3 id="任意大小的数据"><a href="#任意大小的数据" class="headerlink" title="任意大小的数据"></a>任意大小的数据</h3><p>上面的代码问题在于只能处理blockDim.x*2个数据，因此需要考虑更多数据如何设计算法，其实也很简单，因为可以将大的数组分为多个block，每个block单独处理，最后再设计一个kernel更新最终的答案。</p>
<p>流程如下：<br><img src="/../imgs/2023-04-26-01-01-08.png"></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="http://users.umiacs.umd.edu/~ramani/cmsc828e_gpusci/ScanTalk.pdf">http://users.umiacs.umd.edu/~ramani/cmsc828e_gpusci/ScanTalk.pdf</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/04/24/CUDA-reduce%E4%BC%98%E5%8C%96%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/04/24/CUDA-reduce%E4%BC%98%E5%8C%96%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">CUDA reduce优化笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-04-24 21:03:25" itemprop="dateCreated datePublished" datetime="2023-04-24T21:03:25+08:00">2023-04-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-05-27 02:13:09" itemprop="dateModified" datetime="2023-05-27T02:13:09+08:00">2023-05-27</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="问题介绍"><a href="#问题介绍" class="headerlink" title="问题介绍"></a>问题介绍</h3><p>reduce就是对一个数组的数据求sum, min, max, avg等操作，中文名叫规约，规约得到的结果数据维度应该是小于输入的的数据维度的。</p>
<p>reduce操作一般是一个memory-bound的kernel，算术强度(AI)很低，因此目标是提升peak bandwidth。 对于compute-bound的kernel，比如gemm，我们应该去实现peak GFLOPS/s.</p>
<h3 id="kernel-1-naive实现"><a href="#kernel-1-naive实现" class="headerlink" title="kernel 1 naive实现"></a>kernel 1 naive实现</h3><p>第一个kernel如下：</p>
<p><img src="/../imgs/2023-04-24-21-10-39.png"></p>
<p>这个问题在于判断会导致warp divergent, 以及取模操作非常耗费cycle。<br>warp divergent指一个warp内的线程只有满足条件的线程会执行if内的语句，其他线程则处于idle状态，这些idle线程会占用宝贵的硬件资源，数据规模小的时候问题不大，因为硬件够用，但是一般用cuda都是大规模数据，因此必须消除这种divergent。</p>
<h3 id="kernel-2-避免warp-divergent"><a href="#kernel-2-避免warp-divergent" class="headerlink" title="kernel 2 避免warp divergent"></a>kernel 2 避免warp divergent</h3><p>第二个kernel如下：<br><img src="/../imgs/2023-04-24-21-16-12.png"></p>
<p>干活的线程个数其实没有变，只是将任务分配给具有连续全局id的线程，换句话说，将全局id连续的线程映射到需要处理的任务， 而之前是则不是这样，第一次循环，干活的线程id相差2， 第二次循环，干活的线程id相差4。 因为从0开始，每32个全局id连续的线程，它们是在同一个warp内的。因此， 除非需要处理的任务小于32个， 否则是不会发生warp divergent。 但是这样会带来新的问题, bank conflict.</p>
<h3 id="kernel-3-避免bank-conflict"><a href="#kernel-3-避免bank-conflict" class="headerlink" title="kernel 3 避免bank conflict"></a>kernel 3 避免bank conflict</h3><p>shared memory虽然很快，但是容易产生bank conflict。将shared memory可以想象成被组织成int smem[][32], smem数组的32列就是32个bank， 一个warp内的两个线程，如果访问一个bank内的不同地址，就会发生bank conflict。</p>
<p>对于kernel2， 第一轮迭代，<code>index=2*1*tid</code>, 对于一个warp中的32个线程，线程0，和线程16， 他们要访问的地址分别是0， 32， 对应到smen上，就是smem[0][0], smem[1][0], 他们位于同一个bank，因此会发生2-way bank conflict。第二轮迭代中， <code>index=2*2*tid</code>, warp中的32线程，线程0，8，16，32会访问一个bank的数据，因此发生了4-way的conflict。以此类推。</p>
<p>下面这样，即可避免bank conflict：<br><img src="/../imgs/2023-04-24-21-50-16.png"></p>
<p>这样之所以可以避免bank conflict， 是因为之前写smem不是连续的，同一个warp都乘了2的幂， 因此会发生bank conflict， 修改之后使用tid作为smem写入时的下标，对于一个warp，它们写入的是连续的地址，不会bank conflict。示意图如下所示：<br><img src="/../imgs/2023-04-24-21-57-40.png"></p>
<h3 id="kernel-4-make-idle-thread-do-more"><a href="#kernel-4-make-idle-thread-do-more" class="headerlink" title="kernel 4 make idle thread do more"></a>kernel 4 make idle thread do more</h3><p>加下来的问题是第一次迭代时，有一半的线程都处于空闲状态，这样是非常浪费的。</p>
<p><img src="/../imgs/2023-04-24-22-08-29.png"></p>
<p>这个优化，个人觉得是提高创建线程的性价比，修改之前，空闲的线程的唯一作用就是从global mem加载一个数据到smem。修改之后，每个线程加载两个数据，除此 之外，还做了一次加法。 要注意，因为每个线程现在处理两个数据，而BLOCKSIZE又没有变，因此，BLOCK个数要减半。</p>
<h3 id="kernel-循环展开"><a href="#kernel-循环展开" class="headerlink" title="kernel 循环展开"></a>kernel 循环展开</h3><p>循环展开是一个很通用的优化手段，对于循环体内指令很少的kernel来说，循环控制部分的开销是不能忽略的，展开之后，可以有效的降低循环控制部分的占比。此外计算地址的开销也可以避免。 但是也不是展开了就一定好，展开过多可能会导致I-CACHE抖动（这个时候程序的瓶颈可能就在Instruction Fetch），或者寄存器不够，将数据写到local memory， local memory也是out of chip， 具有和globalmemory一样慢的速度。 具体如下：</p>
<p><img src="/../imgs/2023-04-24-22-27-46.png"></p>
<p>当s&lt;=32， 只有一个warp在干活，但是__syncthreads()会在所有block的所有warp之间同步，warp在一个simd单元上工作，本身就是同步，因此工作任务小于warpsize的时候，__syncthreads()完全没有必要。所以我们展开一个waro工作的情况。</p>
<p>关于volatile, 主要原因是因为smem也会被寄存器缓存，而寄存器又是线程私有的，如果B线程访问被A线程的寄存器缓存的位置，而A寄存器还没写会smem，这个时候结果肯定是不对的，volatile关键字告诉编译器从内存中读取，而不是寄存器。因此我猜测要么所有线程都不会将变量缓存到自己的寄存器，要么就访问的时候将寄存器中的值写会smem，但是这样感觉开销很大。 </p>
<p>看了Stack Overflow， 上面说</p>
<p>Removing the volatile keyword from that code could break that code on Fermi and Kepler GPUS. Those GPUs lack instructions to directly operate on shared memory. Instead, the compiler must emit a load/store pair to and from register.</p>
<p>What the volatile keyword does in this context is make the compiler honour that load-operate-store cycle and not perform an optimisation that would keep the value of s_data[tid] in register. To keep the sum accumulating in register would break the implicit memory syncronisation required to make that warp level shared memory summation work correctly.</p>
<p>所以sdata[tid]加了之后可能还存在于寄存器中，如果不写回smem， 其他线程要读取这个数据，就读取的没有更新的数据，这样算出来结果肯定是错的。</p>
<h3 id="kernel-6-完全展开"><a href="#kernel-6-完全展开" class="headerlink" title="kernel 6 完全展开"></a>kernel 6 完全展开</h3><p>上面只展开了剩下任务个数等于warpsize的情况，还可以再展开，但是有一定如果BLOCKSIZE变了，我们需要注释一些或者或者添加一些代码，这样很麻烦，我们可以使用C++提供的模板功能，在编译期生成代码，自动实现展开。<br><img src="/../imgs/2023-04-24-22-59-32.png"></p>
<h3 id="kernel-7-一个线程计算更多元素"><a href="#kernel-7-一个线程计算更多元素" class="headerlink" title="kernel 7 一个线程计算更多元素"></a>kernel 7 一个线程计算更多元素</h3><p><img src="/../imgs/2023-04-24-23-13-21.png"></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>CSE 599 I Accelerated Computing - Programming GPUs Lecture 18.pdf<br><a target="_blank" rel="noopener" href="https://tschmidt23.github.io/cse599i/CSE%20599%20I%20Accelerated%20Computing%20-%20Programming%20GPUs%20Lecture%2018.pdf">https://tschmidt23.github.io/cse599i/CSE%20599%20I%20Accelerated%20Computing%20-%20Programming%20GPUs%20Lecture%2018.pdf</a></p>
<p><a target="_blank" rel="noopener" href="https://www.eecs.umich.edu/courses/eecs570/hw/parprefix.pdf">https://www.eecs.umich.edu/courses/eecs570/hw/parprefix.pdf</a></p>
<p><a target="_blank" rel="noopener" href="https://developer.download.nvidia.com/assets/cuda/files/reduction.pdf">https://developer.download.nvidia.com/assets/cuda/files/reduction.pdf</a></p>
<p><a target="_blank" rel="noopener" href="http://giantpandacv.com/project/OneFlow/%E3%80%90BBuf%E7%9A%84CUDA%E7%AC%94%E8%AE%B0%E3%80%91%E4%B8%89%EF%BC%8Creduce%E4%BC%98%E5%8C%96%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">http://giantpandacv.com/project/OneFlow/%E3%80%90BBuf%E7%9A%84CUDA%E7%AC%94%E8%AE%B0%E3%80%91%E4%B8%89%EF%BC%8Creduce%E4%BC%98%E5%8C%96%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</a></p>
<p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/21205471/cuda-in-warp-reduction-and-volatile-keyword?noredirect=1&amp;lq=1">https://stackoverflow.com/questions/21205471/cuda-in-warp-reduction-and-volatile-keyword?noredirect=1&amp;lq=1</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/04/19/spgemm%E7%9A%84cuda%E5%AE%9E%E7%8E%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/04/19/spgemm%E7%9A%84cuda%E5%AE%9E%E7%8E%B0/" class="post-title-link" itemprop="url">spgemm的cuda实现</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-04-19 15:11:39" itemprop="dateCreated datePublished" datetime="2023-04-19T15:11:39+08:00">2023-04-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-04-20 16:57:02" itemprop="dateModified" datetime="2023-04-20T16:57:02+08:00">2023-04-20</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="CSR格式的数据"><a href="#CSR格式的数据" class="headerlink" title="CSR格式的数据"></a>CSR格式的数据</h2><p>CSR有三个数组， val数组和col数据按行优先的顺序储存了每个元素的值和列下标， row: row[i+1]-row[i]表示第i行有多少个元素。也就是说row[i]到row[i+1]这个左闭右开的区间的每个元素是下标，用于在val，col数组索引元素。</p>
<p><a target="_blank" rel="noopener" href="https://netlib.org/linalg/html_templates/node91.html">Compressed Row Storage (CRS)</a></p>
<p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Sparse_matrix">Sparse matrix - Wikipedia</a></p>
<h2 id="基于hash的2-stage方法"><a href="#基于hash的2-stage方法" class="headerlink" title="基于hash的2-stage方法"></a>基于hash的2-stage方法</h2><h3 id="symbolic阶段"><a href="#symbolic阶段" class="headerlink" title="symbolic阶段"></a>symbolic阶段</h3><p>用于确定结果矩阵C中第i行的非零元素的个数。第i行的每一列j作为B矩阵的行索引，对于B矩阵的第j行的每一个元素，我们找到它的列下标，然后将它存到哈希表中。一般会有多个线程来协同做这些事情，因此最后还需要规约操作。</p>
<h3 id="numiric阶段"><a href="#numiric阶段" class="headerlink" title="numiric阶段"></a>numiric阶段</h3><p>这个阶段用于计算结果矩阵，因为上一个阶段我们已经知道了每一行有多少个非零的值，因此这个阶段，就能很方便分配内存了。</p>
<h3 id="misc"><a href="#misc" class="headerlink" title="misc"></a>misc</h3><h4 id="reduce-操作"><a href="#reduce-操作" class="headerlink" title="reduce 操作"></a>reduce 操作</h4><p><a target="_blank" rel="noopener" href="https://developer.download.nvidia.com/assets/cuda/files/reduction.pdf">https://developer.download.nvidia.com/assets/cuda/files/reduction.pdf</a></p>
<h4 id="一些资源"><a href="#一些资源" class="headerlink" title="一些资源"></a>一些资源</h4><p><a target="_blank" rel="noopener" href="https://www.csd.uwo.ca/~mmorenom/CS9635-4402-2021.html">https://www.csd.uwo.ca/~mmorenom/CS9635-4402-2021.html</a></p>
<h3 id="HIP"><a href="#HIP" class="headerlink" title="HIP"></a>HIP</h3><h4 id="CACHE"><a href="#CACHE" class="headerlink" title="CACHE"></a>CACHE</h4><p>每个CU有自己的L1 cache。</p>
<h4 id="BANDWIDTH"><a href="#BANDWIDTH" class="headerlink" title="BANDWIDTH"></a>BANDWIDTH</h4><p>显卡一般使用GDDR内存，代码500GB/s， DCU使用HBM2，带宽可达1TB/s</p>
<h4 id="WAVEFRONT"><a href="#WAVEFRONT" class="headerlink" title="WAVEFRONT"></a>WAVEFRONT</h4><p>在CUDA里面是warp， 但是WAVEFRONT的大小是64， warp大小是32， 一个CU包含4个SIMD，每个SIMD有10个WAVEFRONT。</p>
<h4 id="REG"><a href="#REG" class="headerlink" title="REG"></a>REG</h4><p>每个线程最多可以用256个寄存器</p>
<h4 id="LDS"><a href="#LDS" class="headerlink" title="LDS"></a>LDS</h4><p>HIP中共享内存是在CU单元之间共享，因此HIP中CU相当于CUDA的BLOCK， 和CUDA一样， LDS也有32个bank。 </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/02/06/mit-6-828-Notes/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/06/mit-6-828-Notes/" class="post-title-link" itemprop="url">mit 6.828 Notes</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-02-06 13:23:11 / Modified: 13:40:28" itemprop="dateCreated datePublished" datetime="2023-02-06T13:23:11+08:00">2023-02-06</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="分布式系统关键点"><a href="#分布式系统关键点" class="headerlink" title="分布式系统关键点"></a>分布式系统关键点</h2><p><a target="_blank" rel="noopener" href="http://nil.csail.mit.edu/6.824/2020/notes/l01.txt">nil.csail.mit.edu/6.824/2020/notes/l01.txt</a></p>
<h3 id="fault-tolerance-容错"><a href="#fault-tolerance-容错" class="headerlink" title="fault tolerance 容错"></a>fault tolerance 容错</h3><p>we want:</p>
<ul>
<li>Availability – app can make progress despite failures</li>
<li>Recoverability – app will come back to life when failures are repaired</li>
</ul>
<p>sulution: replicated servers, If one server crashes, can proceed using the other(s).</p>
<h3 id="consistency-一致性"><a href="#consistency-一致性" class="headerlink" title="consistency 一致性"></a>consistency 一致性</h3><p>Consistency and performance are enemies.</p>
<h3 id="performance-性能"><a href="#performance-性能" class="headerlink" title="performance 性能"></a>performance 性能</h3><p>scalable throughput</p>
<h2 id="MR"><a href="#MR" class="headerlink" title="MR"></a>MR</h2><h3 id="GFS-cluster-file-system"><a href="#GFS-cluster-file-system" class="headerlink" title="GFS cluster file system"></a>GFS cluster file system</h3><p>GFS splits files over many servers, in 64 MB chunks<br>    - Maps read in parallel<br>    - Reduces write in parallel<br>GFS also replicates each file on 2 or 3 servers</p>
<p>What will likely limit the performance?<br>CPU? memory? disk? network?</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/12/27/AlgorithmNotes/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/12/27/AlgorithmNotes/" class="post-title-link" itemprop="url">AlgorithmNotes</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-12-27 15:18:02" itemprop="dateCreated datePublished" datetime="2022-12-27T15:18:02+08:00">2022-12-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-02-15 12:35:48" itemprop="dateModified" datetime="2023-02-15T12:35:48+08:00">2023-02-15</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="classic"><a href="#classic" class="headerlink" title="classic"></a>classic</h3><ol start="113">
<li>路径总和 II - 力扣（LeetCode）<br><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/path-sum-ii/">https://leetcode.cn/problems/path-sum-ii/</a></li>
</ol>
<h2 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h2><ol start="141">
<li>环形链表 - 力扣（LeetCode）<br><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/linked-list-cycle/">https://leetcode.cn/problems/linked-list-cycle/</a></li>
</ol>
<ol start="142">
<li>环形链表 II - 力扣（LeetCode）<br><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/linked-list-cycle-ii/">https://leetcode.cn/problems/linked-list-cycle-ii/</a></li>
</ol>
<ol start="160">
<li>相交链表 - 力扣（LeetCode）<br><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/intersection-of-two-linked-lists/">https://leetcode.cn/problems/intersection-of-two-linked-lists/</a><br>快慢指针或者哈希map，哈希map很简单，</li>
</ol>
<ol>
<li> 删除链表的倒数第 N 个结点 - 力扣（LeetCode）<br><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">https://leetcode.cn/problems/remove-nth-node-from-end-of-list/</a></li>
</ol>
<p>快慢指针，技巧，需要对链表进行修改时，可以在头结点前面增加dummy节点，可以避免讨论删除头结点的情况。</p>
<p>===============================================<br>21. 合并两个有序链表 - 力扣（LeetCode）<br><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/merge-two-sorted-lists/">https://leetcode.cn/problems/merge-two-sorted-lists/</a></p>
<p>使用dummy节点，不用单独处理当添加第一个节点的情况，不然判断新链表的头结点是否为空（也就是添加第一个节点的情况）</p>
<p>=====================================</p>
<ol start="23">
<li>合并K个升序链表 - 力扣（LeetCode）<br><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/merge-k-sorted-lists/">https://leetcode.cn/problems/merge-k-sorted-lists/</a></li>
</ol>
<p>=================</p>
<ol>
<li> 分隔链表 - 力扣（LeetCode）<br><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/partition-list/">https://leetcode.cn/problems/partition-list/</a></li>
</ol>
<p>思路： 使用dummy节点为头结点，创建一个链表，然后遍历两次链表，即可。</p>
<p>========</p>
<ol>
<li>  链表的中间结点 - 力扣（LeetCode）<br><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/middle-of-the-linked-list/">https://leetcode.cn/problems/middle-of-the-linked-list/</a></li>
</ol>
<p>思路：快慢指针即可。</p>
<p>====<br>剑指 Offer 22. 链表中倒数第k个节点 - 力扣（LeetCode）<br><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/">https://leetcode.cn/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/</a></p>
<p>思路：快慢指针即可。</p>
<h3 id="双指针-数组"><a href="#双指针-数组" class="headerlink" title="双指针 数组"></a>双指针 数组</h3><ol start="167">
<li>两数之和 II - 输入有序数组 - 力扣（LeetCode）<br><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/">https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/</a><br>思路：<br>双指针，一个在0，一个在n-1， 然后逐渐向中间靠拢。</li>
</ol>
<p>乱序的two sum：</p>
<ol>
<li>两数之和 - 力扣（LeetCode）<br><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/two-sum/">https://leetcode.cn/problems/two-sum/</a></li>
</ol>
<blockquote>
<ol>
<li> 删除有序数组中的重复项 - 力扣（LeetCode）<br><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-duplicates-from-sorted-array/">https://leetcode.cn/problems/remove-duplicates-from-sorted-array/</a></li>
</ol>
</blockquote>
<p>===</p>
<ol>
<li> 移除元素 - 力扣（LeetCode）<br><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-element/">https://leetcode.cn/problems/remove-element/</a></li>
</ol>
<p>===</p>
<ol start="5">
<li>最长回文子串 - 力扣（LeetCode）<br><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-palindromic-substring/">https://leetcode.cn/problems/longest-palindromic-substring/</a></li>
</ol>
<p>关键是要注意回文串长度也可以为偶数。</p>
<p>===</p>
<ol>
<li> 删除排序链表中的重复元素 - 力扣（LeetCode）<br><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-duplicates-from-sorted-list/">https://leetcode.cn/problems/remove-duplicates-from-sorted-list/</a></li>
</ol>
<p>也可以不用额外的空间</p>
<h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><ol start="3">
<li>无重复字符的最长子串 - 力扣（LeetCode）<br><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/">https://leetcode.cn/problems/longest-substring-without-repeating-characters/</a></li>
</ol>
<h2 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h2><ol start="216">
<li>组合总和 III - 力扣（LeetCode）<br><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/combination-sum-iii/">https://leetcode.cn/problems/combination-sum-iii/</a><br>保证每次向下一次递归时，元素比递增的，可以避免出现重复元素，或者重复的路径</li>
</ol>
<p>剑指 Offer II 082. 含有重复元素集合的组合 - 力扣（LeetCode）<br><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/4sjJUc/">https://leetcode.cn/problems/4sjJUc/</a></p>
<p>回溯要注意剪枝，当当前sum大于target时，我们没必要进入下一层决策树的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 每次进入决策树的下一层时，都必须保证不能原则路径上出现过的元素</span></span><br><span class="line"><span class="keyword">if</span>(used[i]==<span class="literal">true</span>) <span class="keyword">continue</span>;</span><br><span class="line"><span class="comment">// 避免出现重复的路径，但是注意这里没有等号=， 因为可以选择所给候选数组冲重复的元素</span></span><br><span class="line"><span class="comment">// 因此我们得到的数组是一个单调不减的数组</span></span><br><span class="line"><span class="keyword">if</span>(path.<span class="built_in">size</span>()&gt;<span class="number">0</span>&amp;&amp;path.<span class="built_in">back</span>()&gt;candidates[i]) <span class="keyword">continue</span>;</span><br><span class="line"><span class="comment">//剪枝： 如果当前的sum已经大于我们的目标target，那么也没必要进入决策树的下一层了。</span></span><br><span class="line"><span class="keyword">if</span>(sum+candidates[i]&gt;target) <span class="keyword">continue</span>;</span><br></pre></td></tr></table></figure>


<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/submissions/">104. 二叉树的最大深度 - 力扣（LeetCode）</a></p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/diameter-of-binary-tree/">543. 二叉树的直径 - 力扣（LeetCode）</a></p>
<p>思路：首先<code>最大直径=max(最大直径, 左右子树深度之和)</code>， 然后，我们知道<code>左右子树的深度=1+max(左子树深度，右子树深度)</code>，这个深度是相对于根节点来说的，是最末端叶子节点到根节点的路径长度。</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-binary-tree/">654. 最大二叉树 - 力扣（LeetCode）</a></p>
<p>思路： 首先构造根节点，然后再递归地构建其左右子树。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/09/06/about-pimpl-you-should-know/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/09/06/about-pimpl-you-should-know/" class="post-title-link" itemprop="url">about pimpl, you should know...</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-09-06 22:39:19" itemprop="dateCreated datePublished" datetime="2022-09-06T22:39:19+08:00">2022-09-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-09-21 15:10:00" itemprop="dateModified" datetime="2022-09-21T15:10:00+08:00">2022-09-21</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="pimpl是什么"><a href="#pimpl是什么" class="headerlink" title="pimpl是什么"></a>pimpl是什么</h2><p>pimpl主要的目的是为了隐藏信息，我们的确可以在头文件中声明一个类，然后把定义藏到cpp文件中，但是这样还是不够安全，因为用户可能根据private里面的数据结构和私有函数猜到具体实现的思路。所以我们需要pimpl，p就是指指针，我们给用户看到的东西，就一个类，类里面是一个指向具体实现类的指针，具体实现类的实现全都放到cpp文件中。</p>
<p>声明(用户可见):</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test.hpp</span></span><br><span class="line"><span class="comment">//  Note that even though example::implementation is an incomplete type in</span></span><br><span class="line"><span class="comment">//  some translation units using this header, shared_ptr&lt; implementation &gt;</span></span><br><span class="line"><span class="comment">//  is still valid because the type is complete where it counts - in the</span></span><br><span class="line"><span class="comment">//  shared_ptr_example2.cpp translation unit where functions requiring a</span></span><br><span class="line"><span class="comment">//  complete type are actually instantiated.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">example</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">example</span>();</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">do_something</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">implementation</span>;</span></span><br><span class="line">  boost::shared_ptr&lt; implementation &gt; _imp; <span class="comment">// hide implementation details</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>实现(用户不可见)：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;shared_ptr_example2.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">example</span>:</span>:implementation</span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  ~<span class="built_in">implementation</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;destroying implementation\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">example::<span class="built_in">example</span>() : _imp( <span class="keyword">new</span> implementation ) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">example::do_something</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123; std::cout &lt;&lt; <span class="string">&quot;use_count() is &quot;</span> &lt;&lt; _imp.<span class="built_in">use_count</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>; &#125;</span><br></pre></td></tr></table></figure>

<p>用户使用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#include &quot;shared_ptr_example2.hpp&quot;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  example a;</span><br><span class="line">  a.do_something();</span><br><span class="line">  example b(a);</span><br><span class="line">  b.do_something();</span><br><span class="line">  example c;</span><br><span class="line">  c = a;</span><br><span class="line">  c.do_something();</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是这样似乎感觉哪里不对：implementation类是一个imcomplete type，我们可以在这里使用它吗？ 是的，可以。<br>上面给的注释解释了原因，这里的boost::shared_ptr储存的不过是一个指针，一个指针的长度是固定的，因此编译器可以编译通过。</p>
<h2 id="为什么用shared-ptr来持有implementation类呢？"><a href="#为什么用shared-ptr来持有implementation类呢？" class="headerlink" title="为什么用shared_ptr来持有implementation类呢？"></a>为什么用shared_ptr来持有implementation类呢？</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>;</span></span><br><span class="line">A* a = ...;</span><br><span class="line"><span class="keyword">delete</span> a;</span><br></pre></td></tr></table></figure>
<p>上面的代码可能会导致未定义行为，如果幸运，程序会崩溃，更糟糕的是可能会产生内存泄露，因为析构函数不会被调用。</p>
<p>我们可以看下面的例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> ;</span> <span class="comment">// declare A: A is an incomplete type at this point</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">( A* ptr )</span> <span class="comment">// ptr is a pointer to an incomplete type at this point</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// LLVM clang++: *** warning: deleting pointer to incomplete type &#x27;A&#x27; may cause undefined behavior</span></span><br><span class="line">    <span class="comment">//                   note: forward declaration of &#x27;A&#x27; (line 3)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// GNU g++     :     *** warning: possible problem detected in invocation of delete operator</span></span><br><span class="line">    <span class="comment">//                   *** warning: &#x27;ptr&#x27; has incomplete type</span></span><br><span class="line">    <span class="comment">//                   note: forward declaration of &#x27;struct A&#x27; (line 3)</span></span><br><span class="line">    <span class="comment">//                   note: neither the destructor nor the class-specific operator delete will be called, even if they are declared when the class is defined</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Microsoft cl: *** warning: deletion of pointer to incomplete type &#x27;A&#x27;; no destructor called</span></span><br><span class="line">    <span class="comment">//                   note: see declaration of &#x27;A&#x27; (line 3)</span></span><br><span class="line">    <span class="keyword">delete</span> ptr ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// get a compile-time error if you try to use the smart pointer with an </span></span><br><span class="line"><span class="comment">// incomplete type at that point. no more UB</span></span><br><span class="line"><span class="comment">// void foo2( std::shared_ptr&lt;A&gt; sb )</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> &#123;</span> </span><br><span class="line">    <span class="keyword">int</span> *i;</span><br><span class="line">    <span class="built_in">A</span>():<span class="built_in">i</span>(<span class="keyword">new</span> <span class="keyword">int</span>)&#123;&#125;</span><br><span class="line">    ~<span class="built_in">A</span>()&#123;std::cout&lt;&lt;<span class="string">&quot;~A\n&quot;</span>;&#125;</span><br><span class="line">    </span><br><span class="line">&#125;; <span class="comment">// define A: A is a complete type at this point</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">( A* ptr )</span> <span class="comment">// // ptr is a pointer to a complete type at this point</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">delete</span> ptr ; <span class="comment">// this is fine</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A *a = <span class="keyword">new</span> <span class="built_in">A</span>();</span><br><span class="line">    <span class="built_in">foo</span>(a);</span><br><span class="line">    A *b = <span class="keyword">new</span> <span class="built_in">A</span>();</span><br><span class="line">    <span class="built_in">bar</span>(b);</span><br><span class="line">    <span class="comment">// you can&#x27;t instantiated here, </span></span><br><span class="line">    <span class="comment">//std::shared_ptr&lt;A&gt; sb = new A();</span></span><br><span class="line">    <span class="comment">//foo2(sb);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个例子更加直观，当编译器编译到foo函数的时候，A是一个imcomplete type，ptr是一个指针，指向imcomplete type，delete这个指针，会造成内存泄露(A的变量i指向的堆上的内存)，因为这个时候我们不知道A这个类的任何信息，自然也不知道deconstructer了。 而bar就会调用A的deconstructer，因为编译到bar函数的时候，A已经是一个complete type了，自然可以调用其析构函数。<br>根据godbolt产生的汇编代码可以证明这一点：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">foo</span>(A*):</span><br><span class="line">        push    rbp</span><br><span class="line">        mov     rbp, rsp</span><br><span class="line">        sub     rsp, <span class="number">16</span></span><br><span class="line">        mov     QWORD PTR [rbp<span class="number">-8</span>], rdi</span><br><span class="line">        mov     rax, QWORD PTR [rbp<span class="number">-8</span>]</span><br><span class="line">        test    rax, rax</span><br><span class="line">        je      .L3</span><br><span class="line">        mov     rdi, <span class="function">rax</span></span><br><span class="line"><span class="function">        call    <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span>*)</span></span></span><br><span class="line"><span class="function">.L3:</span></span><br><span class="line"><span class="function">        nop</span></span><br><span class="line"><span class="function">        leave</span></span><br><span class="line"><span class="function">        ret</span></span><br><span class="line"><span class="function">.LC0:</span></span><br><span class="line"><span class="function">        .string <span class="string">&quot;~A\n&quot;</span></span></span><br><span class="line"><span class="function">A::~A() [base object destructor]:</span></span><br><span class="line"><span class="function">        push    rbp</span></span><br><span class="line"><span class="function">        mov     rbp, rsp</span></span><br><span class="line"><span class="function">        sub     rsp, <span class="number">16</span></span></span><br><span class="line"><span class="function">        mov     QWORD PTR [rbp<span class="number">-8</span>], rdi</span></span><br><span class="line"><span class="function">        mov     esi, OFFSET FLAT:.LC0</span></span><br><span class="line"><span class="function">        mov     edi, OFFSET FLAT:_ZSt4cout</span></span><br><span class="line"><span class="function">        call    std::basic_ostream&lt;char, std::char_traits&lt;char&gt; &gt;&amp; std::operator&lt;&lt; &lt;std::char_traits&lt;char&gt; &gt;(std::basic_ostream&lt;char, std::char_traits&lt;char&gt; &gt;&amp;, char const*)</span></span><br><span class="line"><span class="function">        nop</span></span><br><span class="line"><span class="function">        leave</span></span><br><span class="line"><span class="function">        ret</span></span><br><span class="line"><span class="function">bar(A*):</span></span><br><span class="line"><span class="function">        push    rbp</span></span><br><span class="line"><span class="function">        mov     rbp, rsp</span></span><br><span class="line"><span class="function">        push    rbx</span></span><br><span class="line"><span class="function">        sub     rsp, <span class="number">24</span></span></span><br><span class="line"><span class="function">        mov     QWORD PTR [rbp<span class="number">-24</span>], rdi</span></span><br><span class="line"><span class="function">        mov     rbx, QWORD PTR [rbp<span class="number">-24</span>]</span></span><br><span class="line"><span class="function">        test    rbx, rbx</span></span><br><span class="line"><span class="function">        je      .L7</span></span><br><span class="line"><span class="function">        mov     rdi, rbx</span></span><br><span class="line"><span class="function">        call    A::~A() [complete object destructor]</span></span><br><span class="line"><span class="function">        mov     esi, <span class="number">1</span></span></span><br><span class="line"><span class="function">        mov     rdi, rbx</span></span><br><span class="line"><span class="function">        call    operator delete(void*, unsigned long)</span></span><br><span class="line"><span class="function">.L7:</span></span><br><span class="line"><span class="function">        nop</span></span><br><span class="line"><span class="function">        mov     rbx, QWORD PTR [rbp<span class="number">-8</span>]</span></span><br><span class="line"><span class="function">        leave</span></span><br><span class="line"><span class="function">        ret</span></span><br><span class="line"><span class="function">main:</span></span><br><span class="line"><span class="function">        push    rbp</span></span><br><span class="line"><span class="function">        mov     rbp, rsp</span></span><br><span class="line"><span class="function">        sub     rsp, <span class="number">16</span></span></span><br><span class="line"><span class="function">        mov     edi, <span class="number">1</span></span></span><br><span class="line"><span class="function">        call    operator new(unsigned long)</span></span><br><span class="line"><span class="function">        mov     QWORD PTR [rbp<span class="number">-8</span>], rax</span></span><br><span class="line"><span class="function">        mov     rax, QWORD PTR [rbp<span class="number">-8</span>]</span></span><br><span class="line"><span class="function">        mov     rdi, rax</span></span><br><span class="line"><span class="function">        call    foo(A*)</span></span><br><span class="line"><span class="function">        mov     edi, <span class="number">1</span></span></span><br><span class="line"><span class="function">        call    operator new(unsigned long)</span></span><br><span class="line"><span class="function">        mov     QWORD PTR [rbp<span class="number">-16</span>], rax</span></span><br><span class="line"><span class="function">        mov     rax, QWORD PTR [rbp<span class="number">-16</span>]</span></span><br><span class="line"><span class="function">        mov     rdi, rax</span></span><br><span class="line"><span class="function">        call    bar(A*)</span></span><br><span class="line"><span class="function">        mov     eax, <span class="number">0</span></span></span><br><span class="line"><span class="function">        leave</span></span><br><span class="line"><span class="function">        ret</span></span><br><span class="line"><span class="function">__static_initialization_and_destruction_0(int, int):</span></span><br><span class="line"><span class="function">        push    rbp</span></span><br><span class="line"><span class="function">        mov     rbp, rsp</span></span><br><span class="line"><span class="function">        sub     rsp, <span class="number">16</span></span></span><br><span class="line"><span class="function">        mov     DWORD PTR [rbp<span class="number">-4</span>], edi</span></span><br><span class="line"><span class="function">        mov     DWORD PTR [rbp<span class="number">-8</span>], esi</span></span><br><span class="line"><span class="function">        cmp     DWORD PTR [rbp<span class="number">-4</span>], <span class="number">1</span></span></span><br><span class="line"><span class="function">        jne     .L12</span></span><br><span class="line"><span class="function">        cmp     DWORD PTR [rbp<span class="number">-8</span>], <span class="number">65535</span></span></span><br><span class="line"><span class="function">        jne     .L12</span></span><br><span class="line"><span class="function">        mov     edi, OFFSET FLAT:_ZStL8__ioinit</span></span><br><span class="line"><span class="function">        call    std::ios_base::Init::Init() [complete object constructor]</span></span><br><span class="line"><span class="function">        mov     edx, OFFSET FLAT:__dso_handle</span></span><br><span class="line"><span class="function">        mov     esi, OFFSET FLAT:_ZStL8__ioinit</span></span><br><span class="line"><span class="function">        mov     edi, OFFSET FLAT:_ZNSt8ios_base4InitD1Ev</span></span><br><span class="line"><span class="function">        call    __cxa_atexit</span></span><br><span class="line"><span class="function">.L12:</span></span><br><span class="line"><span class="function">        nop</span></span><br><span class="line"><span class="function">        leave</span></span><br><span class="line"><span class="function">        ret</span></span><br><span class="line"><span class="function">_GLOBAL__sub_I_foo(A*):</span></span><br><span class="line"><span class="function">        push    rbp</span></span><br><span class="line"><span class="function">        mov     rbp, rsp</span></span><br><span class="line"><span class="function">        mov     esi, <span class="number">65535</span></span></span><br><span class="line"><span class="function">        mov     edi, <span class="number">1</span></span></span><br><span class="line"><span class="function">        call    __static_initialization_and_destruction_0(int, int)</span></span><br><span class="line"><span class="function">        pop     rbp</span></span><br><span class="line"><span class="function">        ret</span></span><br></pre></td></tr></table></figure>

<p>这是一个UB(未定义行为)，如何避免呢</p>
<p>如何避免这个UB呢，答案是使用智能指针，当有必要使用一个完整类型的时候，使用智能指针会得到一个编译错误，从来帮助我们避免UB。</p>
<p>参考：</p>
<p><a target="_blank" rel="noopener" href="https://cs.brown.edu/~jwicks/boost/libs/smart_ptr/shared_ptr.htm">shared_ptr</a></p>
<p><a target="_blank" rel="noopener" href="https://howardhinnant.github.io/incomplete.html">Incomplete Types</a></p>
<p><a target="_blank" rel="noopener" href="https://cplusplus.com/forum/beginner/227343/">C4150 deletion of pointer to incomplete - C++ Forum
</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/08/02/notes-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/02/notes-1/" class="post-title-link" itemprop="url">notes-1</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-08-02 10:45:26" itemprop="dateCreated datePublished" datetime="2022-08-02T10:45:26+08:00">2022-08-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-05-21 22:56:12" itemprop="dateModified" datetime="2023-05-21T22:56:12+08:00">2023-05-21</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><h3 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h3><h4 id="为什么01背包要逆序而完全背包不用"><a href="#为什么01背包要逆序而完全背包不用" class="headerlink" title="为什么01背包要逆序而完全背包不用"></a>为什么01背包要逆序而完全背包不用</h4><p>首先，通过上一个问题，我们确认了我们目前一维的dp数组，保存的是确认过的最新一层的数据，即上一层的数据。</p>
<p>当我们计算当前层时，对于二维时的状态转移方程有</p>
<p>dp[i][j] = max(dp[i][j], dp[i - 1][j - v[i]] + w[i]);</p>
<p>可以看到，dp[i - 1][j - v[i]] + w[i] 使用的上一层的原始数据（dp[i - 1]），而我们使用一维的状态转移方程时有</p>
<p>dp[j] = max(dp[j], dp[j - v[i]] + w[i]);</p>
<p>当我们从小到大更新是， 因为j - v[i] 是严格小于j 的，所以我们可以举个例子 dp[3] = max(dp[3], dp[2] + 1); 因为我们是从小到大更新的，所以当更新到dp[3]的时候，dp[2]已经更新过了，已经不是上一层的dp[2]。</p>
<p>而当我们逆序更新时有，举例 dp[8] = max(dp[8], dp[6] + 2)当更新dp[8]时，dp[6]还没有被更新，还是上一层的数据，这样才能保证没有读入脏数据。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> dp[N][N];</span><br><span class="line"><span class="keyword">int</span> v[N], w[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cin &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">            <span class="keyword">if</span>(j &gt;= v[i]) dp[i][j] = <span class="built_in">max</span>(dp[i][j], dp[i - <span class="number">1</span>][j - v[i]] + w[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; dp[n][m];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> dp[N];</span><br><span class="line"><span class="keyword">int</span> v[N], w[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cin &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = m; j &gt;= v[i]; j --)</span><br><span class="line">            dp[j] = <span class="built_in">max</span>(dp[j], dp[j - v[i]] + w[i]);</span><br><span class="line">    cout &lt;&lt; dp[m];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="K排序"><a href="#K排序" class="headerlink" title="K排序"></a>K排序</h3><p><img src="/../imgs/2023-03-28-21-58-29.png"><br>每次拿K个放到最后，最少要放多少次数组有序。<br>思路： 从前往后遍历数组， 找到不按顺序的数，然后除以K就是答案，比如<code>1,2,5,4,3</code>，那么不按顺序的数就是<code>5,4</code>，因此需要2/2=1依次即可。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> next_find = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> n=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> uo_cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.<span class="built_in">size</span>(); i++&gt;)&#123;</span><br><span class="line">	<span class="keyword">if</span>(nums[i]==next_find) next_find++;</span><br><span class="line">&#125;</span><br><span class="line">uo_cnt = n-next_find;</span><br><span class="line"><span class="keyword">if</span>(uo_cnt%k==<span class="number">0</span>) ans = ans/k;</span><br><span class="line"><span class="keyword">else</span> ans = ans/k + <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<h3 id="删除字符串，得到最大的小数"><a href="#删除字符串，得到最大的小数" class="headerlink" title="删除字符串，得到最大的小数"></a>删除字符串，得到最大的小数</h3><p><img src="/../imgs/2023-03-28-22-06-37.png"></p>
<p>思路1： 从前往后找，一次找最大的数，然后再在剩下的数中找最大的数，直到找到最后。这个方法会超时， 因为复杂度是ON2。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">string ans;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tr</span><span class="params">(string s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s.<span class="built_in">size</span>()==<span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">auto</span> it = std::<span class="built_in">max_element</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">int</span> idx = it-s.<span class="built_in">begin</span>();</span><br><span class="line">    ans.<span class="built_in">push_back</span>(*it);</span><br><span class="line">    std::cout&lt;&lt;*it&lt;&lt;std::endl;</span><br><span class="line">    <span class="built_in">tr</span>(s.<span class="built_in">substr</span>(idx+<span class="number">1</span>, s.<span class="built_in">size</span>()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">string  <span class="title">s</span><span class="params">(<span class="string">&quot;0.411523&quot;</span>)</span></span>;</span><br><span class="line">    <span class="built_in">tr</span>(s.<span class="built_in">substr</span>(<span class="number">1</span>, s.<span class="built_in">size</span>()));</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;0.&quot;</span>+ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>思路2：从后往前找，最后一个数是肯定是要的，依次找比上一次数字大的数字，直到遍历完整个字符串， 这个方法复杂度是ON</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">string ans;</span><br><span class="line">ans.<span class="built_in">push_back</span>(s[s.<span class="built_in">size</span>()<span class="number">-1</span>])</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=s.<span class="built_in">size</span>()<span class="number">-2</span>; i&gt;=<span class="number">2</span>; i--)&#123;</span><br><span class="line">	<span class="keyword">if</span>(s[i]&gt;=s[s.<span class="built_in">size</span>()<span class="number">-1</span>]) s.<span class="built_in">push_back</span>(s[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="01串变成全0或者1"><a href="#01串变成全0或者1" class="headerlink" title="01串变成全0或者1"></a>01串变成全0或者1</h3><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/exam/test/67568180/detail?pid=43184608&amp;examPageSource=Company&amp;testCallback=https://www.nowcoder.com/exam/company&amp;testclass=%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91">https://www.nowcoder.com/exam/test/67568180/detail?pid=43184608&amp;examPageSource=Company&amp;testCallback=https%3A%2F%2Fwww.nowcoder.com%2Fexam%2Fcompany&amp;testclass=%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91</a></p>
<p>给定一个只包含’0’和’1’两种字符的字符串，每次操作可以选择相邻的两个字符，将它们同时变成’0’或者同时变成’1’。<br>请问最少多少次操作后，所有的字符都相同？</p>
<p>思路：选择0或者1作为分隔符，然后统计另一种字符连续出现个数，然后判断需要几次变成全1或者全0.<br>比如选择1作为分隔符，我们要做的就是找到所有0，然后把他们变成1。 如果当前字符是0， 则cnt++，如果是1，则计算前面的0需要多少次才能变成全1，然后将cnt=0.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @param str string字符串 </span></span><br><span class="line"><span class="comment">     * @return int整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(string str, <span class="keyword">char</span> dem)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;str.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(str[i]==dem)&#123;</span><br><span class="line">                <span class="keyword">if</span>(cnt%<span class="number">2</span>==<span class="number">0</span>) ans += cnt/<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">else</span> ans += cnt/<span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">                cnt = <span class="number">0</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cnt%<span class="number">2</span>==<span class="number">0</span>) ans += cnt/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">else</span> ans += cnt/<span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minOperations</span><span class="params">(string str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min</span>(<span class="built_in">f</span>(str, <span class="string">&#x27;0&#x27;</span>), <span class="built_in">f</span>(str, <span class="string">&#x27;1&#x27;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h3 id="将链表分组，然后两两交换"><a href="#将链表分组，然后两两交换" class="headerlink" title="将链表分组，然后两两交换"></a>将链表分组，然后两两交换</h3><p><img src="/../imgs/2023-03-28-21-58-04.png"><br>两个组就四个节点，用四个指针，将将他们首尾交换，然后再找下一个四个节点的子链表，直到剩下的节点不足4个，将其特殊处理。</p>
<h3 id="最大公约数的个数"><a href="#最大公约数的个数" class="headerlink" title="最大公约数的个数"></a>最大公约数的个数</h3><p><img src="/../imgs/2023-03-28-22-04-03.png"><br><img src="/../imgs/2023-03-28-22-04-15.png"></p>
<h3 id="异或等于乘积"><a href="#异或等于乘积" class="headerlink" title="异或等于乘积"></a>异或等于乘积</h3><p><img src="/../imgs/image.png.png"></p>
<h2 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">A</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;default constructer: &quot;</span>&lt;&lt;<span class="keyword">this</span>&lt;&lt;<span class="string">&quot;\n&quot;</span>; &#125; <span class="comment">// 1</span></span><br><span class="line">	<span class="built_in">A</span>(<span class="keyword">const</span> A&amp; a) &#123; std::cout &lt;&lt; <span class="string">&quot;copy constructer: &quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>; &#125;<span class="comment">// 2</span></span><br><span class="line">	<span class="built_in">A</span>(A&amp;&amp; a) &#123; std::cout &lt;&lt; <span class="string">&quot;move constructer: &quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>; &#125;<span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">	~<span class="built_in">A</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;de-constructer: &quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>; &#125; <span class="comment">// 4</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">A <span class="title">test1</span><span class="params">(A a)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	A a;</span><br><span class="line">	<span class="built_in">test1</span>(a);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>the output?</p>
<p>在函数里面的对象，函数退出的时候对象会被销毁，所以一定会构造一个新的对象，而且一个对象反正要销毁了，不如用移动构造函数偷一点资源(比如堆上的)</p>
<h3 id="make-shared"><a href="#make-shared" class="headerlink" title="make_shared"></a>make_shared</h3><p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/20895648/difference-in-make-shared-and-normal-shared-ptr-in-c">c++11 - Difference in make_shared and normal shared_ptr in C++ - Stack Overflow</a></p>
<h2 id="gdb"><a href="#gdb" class="headerlink" title="gdb"></a>gdb</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set disassemble-next-line on</span><br></pre></td></tr></table></figure>

<h2 id="内联汇编"><a href="#内联汇编" class="headerlink" title="内联汇编"></a>内联汇编</h2><p><a target="_blank" rel="noopener" href="https://gcc.gnu.org/onlinedocs/gcc/Extended-Asm.html">Extended Asm (Using the GNU Compiler Collection (GCC))</a></p>
<h2 id="代码粘贴"><a href="#代码粘贴" class="headerlink" title="代码粘贴"></a>代码粘贴</h2><p><a target="_blank" rel="noopener" href="https://www.regendus.com/best-pastebin-alternatives/">7 Best Pastebin Alternatives and Similar Sites in 2022 - REGENDUS</a></p>
<h2 id="C-1"><a href="#C-1" class="headerlink" title="C++"></a>C++</h2><h3 id="读取char-比const-char-快"><a href="#读取char-比const-char-快" class="headerlink" title="读取char[]比const char*快"></a>读取char[]比const char*快</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">char</span> a = <span class="number">1</span>;  </span><br><span class="line">    <span class="keyword">char</span> c[] = <span class="string">&quot;1234567890&quot;</span>;  </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *p =<span class="string">&quot;1234567890&quot;</span>;  </span><br><span class="line">    a = c[<span class="number">1</span>];  </span><br><span class="line">    a = p[<span class="number">1</span>];  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>对于<code>a = c[1]</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">movzx   eax, BYTE PTR [rbp-26]</span><br><span class="line">mov     BYTE PTR [rbp-1], al</span><br></pre></td></tr></table></figure>
<p>这是因为c是一个栈上的数组，初始化在栈上，编译器知道<code>rbp-26</code>就是<code>c[1]</code>的地址, 因此一行代码就可以将栈上的值读到寄存器上。 <code>[rbp-1]</code>表示a的地址，因为a是char，所以-1，如果是int， 应该-4.</p>
<p>而<code>a = p[1]</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov     rax, QWORD PTR [rbp-16]</span><br><span class="line">add     rax, 1</span><br><span class="line">movzx   eax, BYTE PTR [rax]</span><br><span class="line">mov     BYTE PTR [rbp-1], al</span><br></pre></td></tr></table></figure>
<p>然而p是一个指针，指向的”1234567890”位于rodata上，p本身是在栈上的，所以为了读取p[1]，首先将p代表的地址读到rax寄存器中(<code>mov     rax, QWORD PTR [rbp-16]</code>)，然后再加1，表示读取p[1]，读到寄存器中之后还要写到栈上。</p>
<p>但是这都是没优化的代码, 如果用了O1,O2,O3，这两句代码没什么区别，因为编译器一句汇编都不会为他们生成。</p>
<h3 id="C-Using-weak-ptr-for-circular-references-nextptr"><a href="#C-Using-weak-ptr-for-circular-references-nextptr" class="headerlink" title="C++ | Using weak_ptr for circular references - nextptr"></a><a target="_blank" rel="noopener" href="https://www.nextptr.com/tutorial/ta1382183122/using-weak_ptr-for-circular-references">C++ | Using weak_ptr for circular references - nextptr</a></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">		std::shared_ptr&lt;Person&gt; best_friend;</span><br><span class="line">		<span class="built_in">Person</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;ctor &quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">		~<span class="built_in">Person</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;dtor &quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">auto</span> pa = std::make_shared&lt;Person&gt;();</span><br><span class="line">	<span class="keyword">auto</span> pb = std::make_shared&lt;Person&gt;();</span><br><span class="line">	pa-&gt;best_friend = pb;</span><br><span class="line">	pb-&gt;best_friend = pa;</span><br><span class="line">&#125;<span class="comment">//1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<pre><code>上面的析构函数一个都不会打印。当离开1的时候，pa是一个智能指针，它会查看它自己的ref count，发现是2（pa和pb-&gt;best_friend都指向同一个对象），所以它的ref count减一，但并不销毁pa指向的对象。pb也是一样，他们各自离开1之后，pa和pb指向的std::shared_ptr&lt;Person&gt;对象的ref count都是1，因此，发生了内存泄露。 

如果我们把best_friend的类型改写成std::weak_ptr&lt;Person&gt;就不会出现上述的问题，因此weak_ptr指向一个shared对象并不会使该对象的ref count计数加一。weak_ptr只是拥有使用权，但并不拥有管理权。
</code></pre>
<h3 id="c-11-When-is-std-weak-ptr-useful-Stack-Overflow"><a href="#c-11-When-is-std-weak-ptr-useful-Stack-Overflow" class="headerlink" title="c++11 - When is std::weak_ptr useful? - Stack Overflow"></a><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/12030650/when-is-stdweak-ptr-useful">c++11 - When is std::weak_ptr useful? - Stack Overflow</a></h3><pre><code>   std::weak_ptr is a very good way to solve the dangling pointer problem. By just using raw pointers it is impossible to know if the referenced data has been deallocated or not. Instead, by letting a std::shared_ptr manage the data, and supplying std::weak_ptr to users of the data, the users can check validity of the data by calling expired() or lock().

You could not do this with std::shared_ptr alone, because all std::shared_ptr instances share the ownership of the data which is not removed before all instances of std::shared_ptr are removed. 
</code></pre>
<h3 id="c-Why-would-I-std-move-an-std-shared-ptr-Stack-Overflow"><a href="#c-Why-would-I-std-move-an-std-shared-ptr-Stack-Overflow" class="headerlink" title="c++ - Why would I std::move an std::shared_ptr? - Stack Overflow"></a><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/41871115/why-would-i-stdmove-an-stdshared-ptr">c++ - Why would I std::move an std::shared_ptr? - Stack Overflow</a></h3><pre><code>share _ ptr 引用计数是原子的。增加或减少引用计数需要原子增量或减量。这比非原子的递增/递减要慢几百倍（原子操作可能需要几百个时钟周期），更不用说如果我们递增/递减相同的计数器，我们最终得到的是准确的数字，在这个过程中浪费了大量的时间和资源。
</code></pre>
<h3 id="c-What-is-The-Rule-of-Three-Stack-Overflow"><a href="#c-What-is-The-Rule-of-Three-Stack-Overflow" class="headerlink" title="c++ - What is The Rule of Three? - Stack Overflow"></a><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/4172722/what-is-the-rule-of-three">c++ - What is The Rule of Three? - Stack Overflow</a></h3><p>Rule of Three:<br>如果需要自己显式声明析构函数、复制构造函数或复制赋值操作符，那么可能需要显式声明所有这三个操作符。</p>
<p>之所以有三规则，是因为对于类的成员变量，编译器生成的默认构造函数会自动帮我们将他们复制到新的类的成员变量中。</p>
<p>如果我们这样定义一个类：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    std::string name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">person</span>(<span class="keyword">const</span> std::string&amp; name, <span class="keyword">int</span> age) : <span class="built_in">name</span>(name), <span class="built_in">age</span>(age)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>编译器会为我们隐式生成下面的函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. copy constructor</span></span><br><span class="line"><span class="built_in">person</span>(<span class="keyword">const</span> person&amp; that) : <span class="built_in">name</span>(that.name), <span class="built_in">age</span>(that.age)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. copy assignment operator</span></span><br><span class="line">person&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> person&amp; that)</span><br><span class="line">&#123;</span><br><span class="line">    name = that.name;</span><br><span class="line">    age = that.age;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. destructor</span></span><br><span class="line">~<span class="built_in">person</span>()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此，如果我们的类要<code>管理资源</code>，这个资源需要我们自己申请和释放，这个时候很显然我们应该把上面三个函数都显式定义。不然默认的构造函数只是复制指针的值，并不会帮我们将指针指向的内容拷贝一份。同样，如果没有定义析构函数，那么会发生内存泄露。 如果我们只定义了析构函数去delete指针，而不在构造函数中拷贝指针指向的内存，两个类都去delete同一个内存区域，肯定会发生段错误的。</p>
<p>The Rule of Five</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    std::string name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">person</span>(<span class="keyword">const</span> std::string&amp; name, <span class="keyword">int</span> age);        <span class="comment">// Ctor</span></span><br><span class="line">    <span class="built_in">person</span>(<span class="keyword">const</span> person &amp;) = <span class="keyword">default</span>;                <span class="comment">// 1/5: Copy Ctor</span></span><br><span class="line">    <span class="built_in">person</span>(person &amp;&amp;) <span class="keyword">noexcept</span> = <span class="keyword">default</span>;            <span class="comment">// 4/5: Move Ctor</span></span><br><span class="line">    person&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> person &amp;) = <span class="keyword">default</span>;     <span class="comment">// 2/5: Copy Assignment</span></span><br><span class="line">    person&amp; <span class="keyword">operator</span>=(person &amp;&amp;) <span class="keyword">noexcept</span> = <span class="keyword">default</span>; <span class="comment">// 5/5: Move Assignment</span></span><br><span class="line">    ~<span class="built_in">person</span>() <span class="keyword">noexcept</span> = <span class="keyword">default</span>;                    <span class="comment">// 3/5: Dtor</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>




<h3 id="c-Why-is-auto-ptr-being-deprecated-Stack-Overflow"><a href="#c-Why-is-auto-ptr-being-deprecated-Stack-Overflow" class="headerlink" title="c++ - Why is auto_ptr being deprecated? - Stack Overflow"></a><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/3697686/why-is-auto-ptr-being-deprecated">c++ - Why is auto_ptr being deprecated? - Stack Overflow</a></h3><p>限制：</p>
<ul>
<li>auto_ptr不能指向数组。删除指向数组的指针时，我们必须使用delete[]来确保为数组中的所有对象调用析构函数，但 auto_ptr 使用delete。</li>
<li>它不能与STL 容器中的 STL 容器元素一起使用。复制 auto_ptr 时，内存的所有权将转移到新的 auto_ptr 并且原始设置为 NULL。</li>
</ul>
<p>auto_ptr的直接替代品（或最接近的东西）是unique_ptr. 就“问题”而言，它非常简单：auto_ptr在分配时转移所有权，也就是说，复制auto_ptr时，内存的所有权将转移到新的auto_ptr并且原始设置为NULL，这很不合理，复制一个对象，不应该修改被复制对象的状态，除非我们有移动语义。unique_ptr也转移所有权，但由于移动语义的编码和右值引用的魔力，它可以更自然地完成。它还“适合”标准库的其余部分（尽管，公平地说，其中一些要归功于库的其余部分进行了更改以适应移动语义，而不是总是需要复制）。 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::auto_ptr&lt;T&gt; <span class="title">ap</span><span class="params">(<span class="keyword">new</span> T&#123;...&#125;)</span></span>; </span><br><span class="line"><span class="function">std::auto_ptr&lt;T&gt; <span class="title">ap2</span><span class="params">(ap)</span></span>; <span class="comment">// 复制构造函数调用的时候，ap会变成nullptr</span></span><br><span class="line">ap-&gt;xyz; <span class="comment">// 段错误</span></span><br></pre></td></tr></table></figure>

<p>简而言之，auto_ptr和unique_ptr都表示在任何时刻，程序中只能有一份这样的智能指针，但区别在于auto_ptr没有禁用复制构造函数，这样会导致auto_ptr的所有权被悄悄的偷取，然后将原指针设置为nullptr，我们如果没有发现原auto_ptr被设置成nullptr，再次通过指针做一些事情的时候，比如调用函数，就会段错误。 但是unique_tpr会阻止这种情况的发生，除非使用move。</p>
<h3 id="手写一个shared-ptr"><a href="#手写一个shared-ptr" class="headerlink" title="手写一个shared_ptr"></a>手写一个shared_ptr</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">shared_ptr</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">shared_ptr</span><span class="params">()</span>: _refcnt(nullptr), _ptr(nullptr)&#123;</span>&#125;</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">shared_ptr</span><span class="params">(T *ptr)</span>:_ptr(ptr), _refcnt(new uint(<span class="number">1</span>))&#123;</span>&#125;</span><br><span class="line">  ~<span class="built_in">shared_ptr</span>()&#123;</span><br><span class="line">    <span class="keyword">delete</span> _refcnt;</span><br><span class="line">    <span class="keyword">delete</span> _ptr;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// copy constructor</span></span><br><span class="line">  <span class="built_in">shared_ptr</span>(shared_ptr&lt;T&gt; &amp;sp)&#123;</span><br><span class="line">    _ptr = sp._ptr;</span><br><span class="line">    _refcnt = sp._refcnt;</span><br><span class="line">    ++(*_refcnt);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//copy assignment</span></span><br><span class="line">  shared_ptr&lt;T&gt;&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> shared_ptr&lt;T&gt; &amp;sp)&#123;</span><br><span class="line">    <span class="keyword">if</span>(sp._ptr!=_ptr)&#123;</span><br><span class="line">      <span class="keyword">if</span>(--(*_refcnt)==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">delete</span> _ptr;</span><br><span class="line">        <span class="keyword">delete</span> _refcnt;</span><br><span class="line">      &#125;</span><br><span class="line">      _refcnt = sp._refcnt;</span><br><span class="line">      _ptr = sp._ptr;</span><br><span class="line">      ++(*_refcnt);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// move constructor</span></span><br><span class="line">  <span class="built_in">shared_ptr</span>(shared_ptr&lt;T&gt;&amp;&amp; sp)&#123;</span><br><span class="line">    _ptr = sp.ptr;</span><br><span class="line">    _refcnt = sp.refcnt;</span><br><span class="line">    sp.ptr=sp.refcnt = <span class="literal">nullptr</span>;</span><br><span class="line">  &#125; </span><br><span class="line"></span><br><span class="line">  <span class="comment">// move assignment</span></span><br><span class="line">  <span class="function">shared_ptr&lt;T&gt;&amp; <span class="title">shared_ptr</span><span class="params">(shared_ptr&lt;T&gt;&amp;&amp; sp)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(--(*_refcnt)==<span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">delete</span> _refcnt;</span><br><span class="line">      <span class="keyword">delete</span> _ptr;</span><br><span class="line">    &#125;</span><br><span class="line">    _ptr = sp.ptr;</span><br><span class="line">    _refcnt = sp.refcnt;</span><br><span class="line">    sp.ptr=sp.refcnt = <span class="literal">nullptr</span>;</span><br><span class="line">  &#125; </span><br><span class="line"></span><br><span class="line">  T&amp; <span class="keyword">operator</span>*() &#123;<span class="keyword">return</span> *_ptr;&#125;</span><br><span class="line">  T* <span class="keyword">operator</span>-&gt;()&#123;<span class="keyword">return</span> _ptr;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">void</span> _clean()&#123;</span><br><span class="line">    <span class="keyword">if</span>(--(*_refcnt)==<span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">delete</span> _ptr;</span><br><span class="line">      <span class="keyword">delete</span> _refcnt;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  uint *_refcnt;</span><br><span class="line">  T *_ptr;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="C-声明移动-复制操作会抑制相关操作的生成"><a href="#C-声明移动-复制操作会抑制相关操作的生成" class="headerlink" title="C++ 声明移动/复制操作会抑制相关操作的生成"></a><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/44049179/c-declare-a-move-copy-operation-will-suppress-generation-of-related-operations">C++ 声明移动/复制操作会抑制相关操作的生成</a></h3><p>关于类的构造函数：</p>
<p>如果为类声明任何其他构造函数，则不会定义默认构造函数。<br>如果声明移动操作，则复制操作将被隐式删除。<br>如果声明复制操作，则移动操作将被隐式删除。</p>
<h3 id="C-return-local-object-Stack-Overflow"><a href="#C-return-local-object-Stack-Overflow" class="headerlink" title="C++ return local object - Stack Overflow"></a><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/6350882/c-return-local-object">C++ return local object - Stack Overflow</a></h3><p>从函数返回一个局部对象，会在caller堆栈中调用复制构造函数。但是这个步骤可以被省略，叫做copy elision。<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/12953127/what-are-copy-elision-and-return-value-optimization/12953145#12953145">c++ - What are copy elision and return value optimization? - Stack Overflow</a></p>
<h3 id="Indirect-vs-Direct-Function-Call-Overhead-in-C-C"><a href="#Indirect-vs-Direct-Function-Call-Overhead-in-C-C" class="headerlink" title="Indirect vs Direct Function Call Overhead in C/C++"></a><a target="_blank" rel="noopener" href="https://gist.github.com/rianhunter/0be8dc116b120ad5fdd4">Indirect vs Direct Function Call Overhead in C/C++</a></h3><p>间接调用（通过指向函数的指针）要比直接调用慢3.4倍. 函数参数是多个函数指针的时候，寄存器就不够用了. 如果寄存器够用，那速度应该差不多。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">direct_version</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i, b = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; INT_MAX; ++i) &#123;</span><br><span class="line">      b = <span class="built_in">foo</span>(b) + <span class="built_in">bar</span>(b) + <span class="built_in">baz</span>(b);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indirect_version</span><span class="params">(<span class="keyword">int</span> (*fn)(<span class="keyword">int</span>), <span class="keyword">int</span> (*fn2)(<span class="keyword">int</span>), <span class="keyword">int</span> (*fn3)(<span class="keyword">int</span>))</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i, b = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; INT_MAX; ++i) &#123;</span><br><span class="line">    b = <span class="built_in">fn</span>(b) + <span class="built_in">fn2</span>(b) + <span class="built_in">fn3</span>(b);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (argc == <span class="number">2</span> &amp;&amp; argv[<span class="number">1</span>][<span class="number">0</span>] == <span class="string">&#x27;d&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">direct_version</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">indirect_version</span>(&amp;foo, &amp;bar, &amp;baz);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="c-How-do-I-use-a-custom-deleter-with-a-std-unique-ptr-member-Stack-Overflow"><a href="#c-How-do-I-use-a-custom-deleter-with-a-std-unique-ptr-member-Stack-Overflow" class="headerlink" title="c++ - How do I use a custom deleter with a std::unique_ptr member? - Stack Overflow"></a><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/19053351/how-do-i-use-a-custom-deleter-with-a-stdunique-ptr-member">c++ - How do I use a custom deleter with a std::unique_ptr member? - Stack Overflow</a></h3><p>当unique_ptr管理的对象不是一个对象时，需要传递一个一个自定义的deleter。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">deleted_unique_ptr&lt;FILE&gt; <span class="title">file</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    fopen(<span class="string">&quot;file.txt&quot;</span>, <span class="string">&quot;r&quot;</span>),</span></span></span><br><span class="line"><span class="params"><span class="function">    [](FILE* f) &#123; fclose(f); &#125;)</span></span>;</span><br></pre></td></tr></table></figure>




<h3 id="vector的reserve和resize-李大嘴-博客园"><a href="#vector的reserve和resize-李大嘴-博客园" class="headerlink" title="vector的reserve和resize - 李大嘴 - 博客园"></a><a target="_blank" rel="noopener" href="https://www.cnblogs.com/qlee/archive/2011/05/16/2048026.html">vector的reserve和resize - 李大嘴 - 博客园</a></h3><p>如下代码会造成程序奔溃:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">vec.<span class="built_in">reserse</span>(<span class="number">10</span>);</span><br><span class="line">vec[<span class="number">0</span>] = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>错误原因在于vector的reverse函数只改变vector的capacity但是它的size并不会改变。<br>size和capacity的区别:</p>
<ul>
<li>size是vector中当前包含的元素个数</li>
<li>capacity是vector的最大可容纳的元素</li>
</ul>
<p>上面的代码调用reserve之后，vector中时没有元素的，因此如果对vec使用下标操作符，在msvc编译器中将导致如下的错误：</p>
<p><img src="/../imgs/2022-12-03-21-45-50.png"></p>
<p>正确的方式为:</p>
<ul>
<li>使用push_back/insert向容器中添加新元素，而不是用下标</li>
<li>或者将reserve替换为resize</li>
</ul>
<h3 id="C-new与delete"><a href="#C-new与delete" class="headerlink" title="C++ new与delete"></a>C++ new与delete</h3><p>new operator 和delete operator 是运算符</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string *ps = <span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">&quot;Hands up!&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>等价于：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *mem = <span class="keyword">operator</span> <span class="built_in"><span class="keyword">new</span></span>(<span class="built_in"><span class="keyword">sizeof</span></span>(string));      <span class="comment">//申请内存</span></span><br><span class="line"><span class="function">call <span class="title">string::string</span><span class="params">(<span class="string">&quot;Hands up!&quot;</span>)</span> on *mem</span>;     <span class="comment">// 调用构造函数</span></span><br><span class="line">string *ps = <span class="keyword">static_cast</span>&lt;string*&gt;(mem);       <span class="comment">// 返回string*指针</span></span><br></pre></td></tr></table></figure>

<p>同样</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> ps</span><br></pre></td></tr></table></figure>
<p>等价于</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ps-&gt;~<span class="built_in">string</span>()</span><br><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(ps)</span></span></span><br></pre></td></tr></table></figure>

<p>编译器看到类类型的new或者delete运算符的时候，首先查看该类是否是有operator new或者operator delete成员，如果类定义了自己的operator new和operator delete函数，则使用这些函数为对象分配和释放内存，否则调用标准库版本（:: operator new和:: operator delete）。</p>
<h3 id="shared-ptr是线程安全的吗"><a href="#shared-ptr是线程安全的吗" class="headerlink" title="shared_ptr是线程安全的吗"></a>shared_ptr是线程安全的吗</h3><ul>
<li>refcnt是使用原子操作来更新的</li>
<li>多个shared_ptr指向同一个对象，在多线程中，只有一个会调用析构函数</li>
<li>不保证储存在其内的对象的线程安全，多个线程同时写的时候需要自己加锁，否则产生UB</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/9127816/stdshared-ptr-thread-safety-explained">c++ - std::shared_ptr thread safety explained - Stack Overflow</a></p>
<p><a target="_blank" rel="noopener" href="https://web.archive.org/web/20140318233637/http://gcc.gnu.org/onlinedocs/libstdc++/manual/shared_ptr.html">libstdc++ shared_ptr</a></p>
<p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/14482830/stdshared-ptr-thread-safety">c++ - std::shared_ptr thread safety - Stack Overflow</a></p>
<h3 id="如何避免shared-ptr的内存碎片问题"><a href="#如何避免shared-ptr的内存碎片问题" class="headerlink" title="如何避免shared_ptr的内存碎片问题"></a>如何避免shared_ptr的内存碎片问题</h3><p>先说结论：先 new 然后赋值的方式，会导致内存碎片化；make_shared 的方法分配内存，不会导致内存产生过多的碎片。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">T* pt = <span class="keyword">new</span> T;</span><br><span class="line"><span class="function">std::shared_ptr&lt;T&gt; <span class="title">p</span><span class="params">(pt)</span></span>;</span><br></pre></td></tr></table></figure>
<p>上面这段代码是先在堆上分配一块内存，然后在堆上再建一个智能指针控制块，这两个东西是不连续的，会造成内存碎片化</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::shared_ptr&lt;T&gt; p = std::make_shared&lt;T&gt;();</span><br></pre></td></tr></table></figure>
<p>上面这段代码是直接在堆上新建一块足够大的内存，其中包含两部分，上面是内存（用来使用），下面是控制块（包含引用计数）。然后用 T 的构造函数去初始化分配的内存（分配一块内存的步骤：先分配内存，再进分配的内存调用构造函数进行构造，构造完毕才能使用）。</p>
<h3 id="vptr和vtable"><a href="#vptr和vtable" class="headerlink" title="vptr和vtable"></a>vptr和vtable</h3><p>只有有类有虚函数或者子类中有虚函数才会产生vptr，vptr指向vtable， vtable第一个slot是关于类的信息，主要用于实现运行时类型识别RTTI技术，后面才是虚函数的地址。 RTTI的用处之一就是为了实现安全的downcast，也就是基类cast为派生类。 在C++里面，需要我们使用dynamic_cast来实现安全的向下转型， 这是发生在运行时的，如果是安全的(如果base type pointer指向一个derived class object), 这个dynamic_cast会返回指向derived class的指针，不过不安全则返回0。</p>
<p>但是注意上面说的指针，如果是引用，会抛出bad_cast exception，因为没有空引用。</p>
<p>vtable位于只读数据区，vptr则不是，可能在堆区，也可能在栈区，因此vtable的开销在编译期，而vptr的开销则在运行时。</p>
<p><a target="_blank" rel="noopener" href="https://www.quora.com/Where-are-virtual-tables-stored-in-C">Where are virtual tables stored in C++? - Quora</a></p>
<h3 id="虚函数是如何工作的呢？"><a href="#虚函数是如何工作的呢？" class="headerlink" title="虚函数是如何工作的呢？"></a>虚函数是如何工作的呢？</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Base *ptr = &amp;obj;</span><br><span class="line">ptr-&gt;<span class="built_in">z</span>();</span><br></pre></td></tr></table></figure>
<ol>
<li>虽然不知道ptr指向的类型是什么，但是可以使用ptr找到obj的vtable，而vtable的第一个slot记录的对象的真正的类型。</li>
<li>虽然不知道z的真正地址，但是可以知道它被放到vtable的哪一个slot中。因此只要访问对应的slot我们就可以找到真正的函数地址。</li>
</ol>
<p>第二点里面，我觉得应该是Base的虚表里面的虚函数，派生类要么不改写直接继承，要么改写，不管怎么样，派生类的vtable都是基于Base的vtable的，在编译时就能知道Base类的每个虚函数在vtable中的slot索引，运行时只不过是换了个vtable而已，slot索引还是不变的。所以可以看出，如果子类自己又加了一个Base类不存在的虚函数，如果ptr真的指向了Base类并调用子类自己加的虚函数，这个时候调用肯定会UB的，大概率会coredump。</p>
<p><a target="_blank" rel="noopener" href="http://notes.tanchuanqi.com/_static/attachment/%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2C++%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B_%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.pdf">深度探索C++对象模型_读书笔记.pdf</a></p>
<h3 id="手动模拟多态的行为"><a href="#手动模拟多态的行为" class="headerlink" title="手动模拟多态的行为"></a>手动模拟多态的行为</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>()&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123; cout &lt;&lt; <span class="string">&quot;Base::print()\n&quot;</span>; &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base</span>()&#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span>* baseI;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Derived</span>(<span class="keyword">int</span> i)&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123; cout &lt;&lt; <span class="string">&quot;Derived::print()\n&quot;</span>;&#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Derived</span>()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Base *b = <span class="keyword">new</span> <span class="built_in">Derived</span>(<span class="number">1000</span>);</span><br><span class="line">    b-&gt;<span class="built_in">print</span>();</span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*Fun)</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">    Fun vfunc = (Fun)*(<span class="keyword">uint64_t</span> *)*((<span class="keyword">uint64_t</span> *)b);</span><br><span class="line">    (*vfunc)();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="RTTI和typeid的区别"><a href="#RTTI和typeid的区别" class="headerlink" title="RTTI和typeid的区别"></a>RTTI和typeid的区别</h3><p>RTTI只适用于多态类型，因为RTTI的信息存在于vtable之中，没有多态，自然也没有vtable。</p>
<p>typeid既可以用于多态也可以用于非多态。<br><img src="/../imgs/2023-04-29-21-31-26.png"></p>
<p>也可以用于多态：<br><img src="/../imgs/2023-04-29-21-31-57.png"><br>这次输出</p>
<p>  Struct A * <br>  Struct B</p>
<p><a target="_blank" rel="noopener" href="http://notes.tanchuanqi.com/_static/attachment/%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2C++%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B_%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.pdf">深度探索C++对象模型_读书笔记.pdf</a></p>
<h3 id="构造函数和析构函数可以是虚函数吗？"><a href="#构造函数和析构函数可以是虚函数吗？" class="headerlink" title="构造函数和析构函数可以是虚函数吗？"></a>构造函数和析构函数可以是虚函数吗？</h3><p>虚函数的主要用途是实现多态，也就是当我们并不知道一个基类指针指向的对象是什么类型的时候。</p>
<ul>
<li><p>构造函数不可以是虚函数，因为虚函数和对象有关，但和类无关，虚函数是通过虚表来调用的，在调用的构造函数之前，对象都还不存在，那么虚表肯定也不存在，所以构造函数不能是虚函数。</p>
</li>
<li><p>对于析构函数，如果基类指针pa指向派生类b，如果我们析构函数不是virtual，那么delete pa，派生类的析构函数将不会调用，因此可能会发生内存泄露。 delete也是调用函数，如果是用派生类指向b，就算析构函数不是虚函数，那么派生类和基类的析构函数也都会被执行。</p>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/733360/why-do-we-not-have-a-virtual-constructor-in-c">Why do we not have a virtual constructor in C++? - Stack Overflow</a></p>
<p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/461203/when-to-use-virtual-destructors/15903538#15903538.this">c++ - When to use virtual destructors? - Stack Overflow</a></p>
<h3 id="map和unoreded-map"><a href="#map和unoreded-map" class="headerlink" title="map和unoreded_map"></a>map和unoreded_map</h3><p><img src="/../imgs/2023-04-28-16-31-23.png"><br>图中哈希表的建立 比较耗时间应该是指哈希函数本省比较耗时。</p>
<p><a target="_blank" rel="noopener" href="https://xzchsia.github.io/2020/04/09/cpp-map-unordered_map/">c++中map与unordered_map的区别 - Hsia的博客 | Hsia Blog</a><br><a target="_blank" rel="noopener" href="https://akaedu.github.io/book/ch26s03.html">3. 哈希表</a></p>
<h3 id="vector和list的比较"><a href="#vector和list的比较" class="headerlink" title="vector和list的比较"></a>vector和list的比较</h3><p>其实就是数据的链表的区别。list不支持随机存取，因此没有operator[].<br>值得关注的问题是下面的迭代器失效的问题。 </p>
<h3 id="迭代器失效"><a href="#迭代器失效" class="headerlink" title="迭代器失效"></a>迭代器失效</h3><h4 id="Insertion"><a href="#Insertion" class="headerlink" title="Insertion"></a>Insertion</h4><p>对于顺序容器：</p>
<ul>
<li><p>Vector: 插入点之前的所有迭代器和引用都不受影响，除非新的容器大小大于以前的容量(在这种情况下，所有迭代器和引用都无效)[23.2.4.3/1]</p>
</li>
<li><p>Deque: 所有迭代器和引用都是无效的，除非插入的成员位于 deque 的末尾(前面或后面)(在这种情况下，所有迭代器都是无效的，但对元素的引用不受影响)[23.2.1.3/1]</p>
</li>
<li><p>List: 所有迭代器和引用不受影响[23.2.2.3/1]</p>
</li>
</ul>
<p>对于关联容器，比如map和set， 插入操作不会发生迭代器失效。</p>
<p>对于容器适配器，如stack，queue， priority_queue来说，取决于他们继承自什么容器。</p>
<h4 id="Erasure"><a href="#Erasure" class="headerlink" title="Erasure"></a>Erasure</h4><p>对于顺序容器：<br>Vector: 擦除点之后的每个迭代器和引用都是无效的[23.2.4.3/3]</p>
<p>Deque: 所有迭代器和引用都是无效的，除非被擦除的成员位于 deque 的末尾(前面或后面)(在这种情况下，只有对被擦除成员的迭代器和引用是无效的)[23.2.1.3/4]</p>
<p>List: 只有对擦除元素的迭代器和引用是无效的[23.2.2.3/3]</p>
<p>关联容器：<br>只有对被擦除元素的迭代器和引用是无效的[23.1.2/8]</p>
<p>对于容器适配器，如stack，queue， priority_queue来说，取决于他们继承自什么容器。</p>
<p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/6438086/iterator-invalidation-rules-for-c-containers">Iterator invalidation rules for C++ containers - Stack Overflow</a></p>
<p><a target="_blank" rel="noopener" href="https://users.cs.fiu.edu/~weiss/Deltoid/msvc_stl_7.html">https://users.cs.fiu.edu/~weiss/Deltoid/msvc_stl_7.html</a></p>
<h3 id="vector的erase和remove的区别"><a href="#vector的erase和remove的区别" class="headerlink" title="vector的erase和remove的区别"></a>vector的erase和remove的区别</h3><p>remove调用后size不会变，只是将后面的值移动到前面来。 所以一般还要配合erase调整vector的大小。看下面例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="keyword">int</span>&gt; vec&#123;<span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;;</span><br><span class="line"><span class="comment">// std::remove move elements and return iterator for vector erase funtion</span></span><br><span class="line"><span class="keyword">auto</span> last = std::<span class="built_in">remove</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), <span class="number">6</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> a:vec)</span><br><span class="line">    cout&lt;&lt;a&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">cout&lt;&lt;endl;</span><br><span class="line"><span class="comment">// 8 10 3 4 5 7 8 6 6 7 8 </span></span><br><span class="line"></span><br><span class="line">vec.<span class="built_in">erase</span>(last, vec.<span class="built_in">end</span>());</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> a:vec)</span><br><span class="line">    cout&lt;&lt;a&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">cout&lt;&lt;endl;</span><br><span class="line"><span class="comment">// 8 10 3 4 5 7 8 </span></span><br></pre></td></tr></table></figure>
<p><img src="/../imgs/2023-04-28-17-39-00.png"></p>
<p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/799314/difference-between-erase-and-remove">c++ - Difference between erase and remove - Stack Overflow</a></p>
<h3 id="关于虚函数和多态的题"><a href="#关于虚函数和多态的题" class="headerlink" title="关于虚函数和多态的题"></a>关于虚函数和多态的题</h3><h4 id=""><a href="#" class="headerlink" title=""></a></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;B::f()&quot;</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span>:</span><span class="keyword">public</span> B</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;D::f()&quot;</span>;&#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    B b;</span><br><span class="line">    B &amp;p1=b;</span><br><span class="line">    D &amp;p2=<span class="keyword">static_cast</span>&lt;D&amp;&gt;(p1);</span><br><span class="line">    p2.<span class="built_in">f</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h4 id="-1"><a href="#-1" class="headerlink" title=""></a></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">A</span> (<span class="keyword">int</span> k):<span class="built_in">num1</span>(k) &#123;&#125;</span><br><span class="line">  ~<span class="built_in">A</span> ()&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">setNum</span> <span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;num2 = val;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">getNum</span> <span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">  <span class="keyword">int</span> num1;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="keyword">int</span> num2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">A::getNum</span> <span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">max</span> (num1, num2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span><span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">B</span> (<span class="keyword">int</span> val):<span class="built_in">A</span> (val)&#123;&#125;</span><br><span class="line">  </span><br><span class="line">  ~<span class="built_in">B</span> ()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">const</span> A <span class="title">a</span> <span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">  <span class="function">B <span class="title">b</span> <span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line"><span class="comment">//   a.setNum (6);</span></span><br><span class="line">  b.<span class="built_in">setNum</span> (<span class="number">2</span>);</span><br><span class="line">  cout &lt;&lt; b.num1 &lt;&lt; endl;</span><br><span class="line"><span class="comment">//   cout &lt;&lt; b.num2 &lt;&lt; endl; //error: ‘int A::num2’ is protected within this context</span></span><br><span class="line">  cout &lt;&lt; a.<span class="built_in">getNum</span> () &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt; b.<span class="built_in">getNum</span> () &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="-2"><a href="#-2" class="headerlink" title=""></a></h3><h3 id="-3"><a href="#-3" class="headerlink" title=""></a></h3><h3 id="-4"><a href="#-4" class="headerlink" title=""></a></h3><h3 id="-5"><a href="#-5" class="headerlink" title=""></a></h3><h3 id="-6"><a href="#-6" class="headerlink" title=""></a></h3><h3 id="-7"><a href="#-7" class="headerlink" title=""></a></h3><h2 id="体系结构"><a href="#体系结构" class="headerlink" title="体系结构"></a>体系结构</h2><h3 id="如果理解CPU的流水线"><a href="#如果理解CPU的流水线" class="headerlink" title="如果理解CPU的流水线"></a>如果理解CPU的流水线</h3><p>首先，流水线增加的不是单条指令的执行速度，而是程序整体单位时间执行的指令个数，也就是提高了吞吐量。为什么可以提高吞吐量呢，现代的处理器将一条指令的执行分为多个步骤，比如经典的取值，译码，执行，访存，写回5级流水线。 如果不用流水线，只有上一条指令的这5个步骤结束了，下一个指令才能开始执行这5个步骤，如下：<br><img src="/../imgs/2023-05-04-22-04-37.png"></p>
<p>但是如果使用流水线，这5个步骤就可以并行进行，从上面的图可以看出，没有流水线，一条指令执行的时候，其他4个部件都是空闲的。而使用流水线，可以保证大部分时间，这几个部件都是处于工作状态的。从指令的视角如下图：<br><img src="/../imgs/2023-05-04-22-08-19.png"></p>
<p>从每个处理器部件的角度来看：<br><img src="/../imgs/2023-05-04-22-09-41.png"></p>
<p>流水线存在的问题的流水线风险hazard, 也就是在执行下一条指令的时候，数据还没准备好。从下面的图可以看出，下一条指令的源寄存器依赖于上一条指令结果。</p>
<p><img src="/../imgs/2023-05-04-22-14-43.png"></p>
<h3 id="如何判断大小端？"><a href="#如何判断大小端？" class="headerlink" title="如何判断大小端？"></a>如何判断大小端？</h3><p>首先，大端小端的区别：<br><img src="/../imgs/2023-05-18-23-16-50.png"></p>
<p>大端模式（Big-Endian）：指的是数据的低位保存在内存的高地址中，而数据的高位保存在内存的低地址中.</p>
<p>小端模式（Little-Endian）：指的是数据的低位保存在内存的低地址中，而数据的高位保存在内存的高地址中。</p>
<p>上面可以看出，对于0x12345678， 我们怎么把他放进内存呢？ 如果先放0x12，那这就是大端， 如果先放0x78，那么就是小端。 可以看出，大端很符合人的阅读习惯。 而小端，由于数据低位，由于CPU的运算逻辑， 数据低位在内存低位很符合CPU的“阅读习惯”</p>
<h4 id="怎么判断电脑是大端还是小端呢？"><a href="#怎么判断电脑是大端还是小端呢？" class="headerlink" title="怎么判断电脑是大端还是小端呢？"></a>怎么判断电脑是大端还是小端呢？</h4><h5 id="对于不同CPU"><a href="#对于不同CPU" class="headerlink" title="对于不同CPU"></a>对于不同CPU</h5><p>大端模式: PowerPC、IBM、Sun；<br>小端模式 : x86、DEC；<br>ARM既可以工作在大端模式，也可以工作在小端模式。</p>
<h5 id="写代码实现"><a href="#写代码实现" class="headerlink" title="写代码实现"></a>写代码实现</h5><p>根据上面说的， 应该很简单就可以写出来了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">0x12345678</span>;</span><br><span class="line"><span class="comment">// 取地址是为了让编译器将x储存在内存中， 因为大小序表现在内存中</span></span><br><span class="line"><span class="comment">// 如果cx是12， 则是大端</span></span><br><span class="line"><span class="comment">// 如果cx是78， 则是小端</span></span><br><span class="line"><span class="keyword">char</span> cx = <span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>*&gt;(&amp;x)[<span class="number">0</span>];</span><br></pre></td></tr></table></figure>

<h4 id="如何进行大端小端转化呢"><a href="#如何进行大端小端转化呢" class="headerlink" title="如何进行大端小端转化呢"></a>如何进行大端小端转化呢</h4><p>答案是使用C网络编程中htonx, ntohx系列函数， x可以是l和s，分别代表int和short。自己写一个也很简单。 </p>
<p>字节序问题之大小端模式讲解 - 灰色飘零 - 博客园<br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/renhui/p/13600572.html">https://www.cnblogs.com/renhui/p/13600572.html</a></p>
<h2 id="嵌入式"><a href="#嵌入式" class="headerlink" title="嵌入式"></a>嵌入式</h2><h3 id="一些问题"><a href="#一些问题" class="headerlink" title="一些问题"></a>一些问题</h3><h4 id="端口复用和端口重映射的区别？"><a href="#端口复用和端口重映射的区别？" class="headerlink" title="端口复用和端口重映射的区别？"></a>端口复用和端口重映射的区别？</h4><ul>
<li><p>端口复用：STM32有很多的内置外设，这些外设的外部引脚都是与GPIO复用的。当我们把GPIO引脚作为外设的IO引脚时（通过软件配置），这个时候就产生了GPIO引脚复用。</p>
</li>
<li><p>端口重映射：外设里面的输入输出引脚一般都是默认和某个GPIO口一起使用，但是多个外设的端口可能会使用同一个GPIO口，这样就不能同时使用两个外设了，要想同时使用两个外设，这个时候就需要使用端口重映射，即把其中一个外设的输入输出重新映射到其他端口。</p>
</li>
</ul>
<h4 id="什么时候需要开启AFIO时钟？-开启引脚复用的时候需要开启AFIO时钟吗？"><a href="#什么时候需要开启AFIO时钟？-开启引脚复用的时候需要开启AFIO时钟吗？" class="headerlink" title="什么时候需要开启AFIO时钟？ 开启引脚复用的时候需要开启AFIO时钟吗？"></a>什么时候需要开启AFIO时钟？ 开启引脚复用的时候需要开启AFIO时钟吗？</h4><p>首先要搞清楚为什么需要开启时钟， 当我们要对芯片内部的硬件进行控制（读写其寄存器），要控制哪一部分，就要开启那一部分的时钟。</p>
<p>那AFIO有哪些寄存器呢？ 通过手册可以知道，AFIO主要的寄存器和EXTI外部中断和端口重映射相关，因此要使用者两个功能的时候应该开启AFIO时钟。</p>
<h4 id="如果复用功能开启了，如何通过GPIO知道外设输出了什么？"><a href="#如果复用功能开启了，如何通过GPIO知道外设输出了什么？" class="headerlink" title="如果复用功能开启了，如何通过GPIO知道外设输出了什么？"></a>如果复用功能开启了，如何通过GPIO知道外设输出了什么？</h4><p>首先，不应该去读取ODR， 因为手册里说了：如果把端口配置成复用输出功能，则引脚和输出寄存器断开，并和片上外设的输出信号连接。</p>
<p>根据手册上说的：在每个APB2时钟周期，出现在I/O脚上的数据被采样到输入数据寄存器</p>
<p>因此我们可以去读取IDR， 以知道外设输出了什么。</p>
<h4 id="AHB-APB1-APB2"><a href="#AHB-APB1-APB2" class="headerlink" title="AHB, APB1, APB2"></a>AHB, APB1, APB2</h4><p>APB1, APB2是从AHB桥接出去的。APB1操作速度限于36MHz， APB2操作于全速(最高72MHz), 在使用一个外设之前，必须设置寄存器RCC_AHBENR来打开该外设的时钟</p>
<h3 id="网站资源"><a href="#网站资源" class="headerlink" title="网站资源"></a>网站资源</h3><p><a target="_blank" rel="noopener" href="https://aijishu.com/blog/zhiguoxin">嵌入式开发 - 极术社区 - 连接开发者与智能计算生态</a></p>
<p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000042746286?utm_source=sf-similar-article">嵌入式 - 10个问题，让你真正学懂三极管 - 个人文章 - SegmentFault 思否</a></p>
<h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><h3 id="关于TCP三次握手和四次挥手"><a href="#关于TCP三次握手和四次挥手" class="headerlink" title="关于TCP三次握手和四次挥手"></a>关于TCP三次握手和四次挥手</h3><p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/news/646106">终于搞懂了 TCP 的 11 种状态 ，太不容易了… - 腾讯云开发者社区-腾讯云</a></p>
<h4 id="TCP的11个状态："><a href="#TCP的11个状态：" class="headerlink" title="TCP的11个状态："></a>TCP的11个状态：</h4><ul>
<li><p>CLOSED：初始状态，表示TCP连接是”关闭着的”或”未打开的”</p>
</li>
<li><p>LISTEN：表示服务器端的某个SOCKET处于监听状态，可以接受客户端的连接</p>
</li>
<li><p>SYN_RCVD：表示服务器接收到了来自客户端请求连接的SYN报文。这个状态是在服务端的，但是它是一个中间状态，很短暂，平常我们用netstat或ss的时候，不太容易看到这种状态，但是遇到SYN flood之类的SYN攻击时，会出现大量的这种状态，即收不到三次握手最后一个客户端发来的ACK，所以一直是这个状态，不会转换到ESTABLISHED</p>
</li>
<li><p>SYN_SENT：这个状态与SYN_RCVD状态相呼应，，它是TCP连接客户端的状态，当客户端SOCKET执行connect()进行连接时，它首先发送SYN报文，然后随机进入到SYN_SENT状态，并等待服务端的SYN和ACK，该状态表示客户端的SYN已发送<br>ESTABLISHED：表示TCP连接已经成功建立，开始传输数据</p>
</li>
</ul>
<ul>
<li><p>FIN_WAIT_1：这个状态在实际工作中很少能看到，当客户端想要主动关闭连接时，它会向服务端发送FIN报文，此时TCP状态就进入到FIN_WAIT_1的状态，而当服务端回复ACK，确认关闭后，则客户端进入到FIN_WAIT_2的状态，也就是只有在没有收到服务端ACK的情况下，FIN_WAIT_1状态才能看到，然后长时间收不到ACK，通常会在默认超时时间60s(由内核参数tcp_fin_timeout控制)后，直接进入CLOSED状态</p>
</li>
<li><p>FIN_WAIT_2：这个状态相比较常见，也是需要注意的一个状态，FIN_WAIT_1在接收到服务端ACK之后就进入到FIN_WAIT_2的状态，然后等待服务端发送FIN，所以在收到对端FIN之前，TCP都会处于FIN_WAIT_2的状态，也就是，在主动断开的一端发现大量的FIN_WAIT_2状态时，需要注意，可能时网络不稳定或程序中忘记调用连接关闭，FIN_WAIT_2也有超时时间，也是由内核参数tcp_fin_timeout控制，当FIN_WAIT_2状态超时后，连接直接销毁</p>
</li>
<li><p>CLOSE_WAIT：表示正在等待关闭，该状态只在被动端出现，即当主动断开的一端调用close()后发送FIN报文给被动端，被动段必然会回应一个ACK(这是由TCP协议层决定的)，这个时候，TCP连接状态就进入到CLOSE_WAIT</p>
</li>
<li><p>LAST_ACK：当被动关闭的一方在发送FIN报文后，等待对方的ACK报文的时候，就处于LAST_ACK的状态，当收到对方的ACK之后，就进入到CLOSED状态了</p>
</li>
<li><p>TIME_WAIT：该状态是最常见的状态，主动方在收到对方FIN后，就由FIN_WAIT_2状态进入到TIME_WAIT状态</p>
</li>
<li><p>CLOSING：这个状态是一个比较特殊的状态，也比较少见，正常情况下不会出现，但是当双方同时都作为主动的一方，调用 close() 关闭连接的时候，两边都进入FIN_WAIT_1 的状态，此时期望收到的是ACK包，进入 FIN_WAIT_2 的状态，但是却先收到了对方的FIN包，这个时候，就会进入到 CLOSING 的状态，然后给对方一个ACK，接收到 ACK 后直接进入到 CLOSED 状态。</p>
</li>
</ul>
<h4 id="关于-TCP-第-3-部分-TCP-3-次握手（续）。"><a href="#关于-TCP-第-3-部分-TCP-3-次握手（续）。" class="headerlink" title="关于 TCP - 第 3 部分 - TCP 3 次握手（续）。"></a>关于 TCP - 第 3 部分 - TCP 3 次握手（续）。</h4><p><a target="_blank" rel="noopener" href="https://www.linkedin.com/pulse/all-tcp-part-3-3-way-handshaking-explained-mohamed-kamal-1">https://www.linkedin.com/pulse/all-tcp-part-3-3-way-handshaking-explained-mohamed-kamal-1</a></p>
<h4 id="为什么需要-TIME-WAIT-状态？"><a href="#为什么需要-TIME-WAIT-状态？" class="headerlink" title="为什么需要 TIME_WAIT 状态？"></a>为什么需要 TIME_WAIT 状态？</h4><p>主动发起关闭连接的一方，才会有 TIME-WAIT 状态。<br>原因：</p>
<ul>
<li>防止具有相同「四元组」的「旧」数据包被收到；</li>
<li>保证「被动关闭连接」的一方能被正确的关闭，即保证最后的 ACK 能让被动关闭方接收，从而帮助其正常关闭；</li>
</ul>
<h4 id="为什么CLOSE-WAIT需要2MSL"><a href="#为什么CLOSE-WAIT需要2MSL" class="headerlink" title="为什么CLOSE_WAIT需要2MSL"></a>为什么CLOSE_WAIT需要2MSL</h4><p>MSL 是 Maximum Segment Lifetime，报文最大生存时间，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。</p>
<p>2MSL的时间是从客户端接收到 FIN 后发送 ACK 开始计时的。如果在 TIME-WAIT 时间内，因为客户端的 ACK 没有传输到服务端，客户端又接收到了服务端重发的 FIN 报文，那么 2MSL 时间将重新计时。</p>
<p>为了便于描述，我们设想有一个处于断开过程中的TCP连接，这个连接的两端分别是A和B，其中A是主动关闭连接的一端，因为刚刚向对端发送了针对对端发送过来的FIN报文的ACK，此时正处于TIME_WAIT状态；而B是被动关闭的一端，此时正处于LAST_ACK状态，在收到最后一个ACK之前它会一直重传FIN报文直至超时。随着时间的流逝，A发送给B的ACK报文将会有两种结局：</p>
<ul>
<li><p>ACK报文在网络中丢失：如前所述，这种情况我们不需要考虑，因为除非多次重传失败，否则AB两端的状态不会发生变化直至某一个ACK不再丢失。</p>
</li>
<li><p>ACK报文被B接收到。我们假设A发送了ACK报文后过了一段时间t之后B才收到该ACK，则有 0 &lt; t &lt;= MSL。因为A并不知道它发送出去的ACK要多久对方才能收到，所以A至少要维持MSL时长的TIME_WAIT状态才能保证它的ACK从网络中消失。同时处于LAST_ACK状态的B因为收到了ACK，所以它直接就进入了CLOSED状态，而不会向网络发送任何报文。所以晃眼一看，A只需要等待1个MSL就够了，但仔细想一下其实1个MSL是不行的，因为在B收到ACK前的一刹那，B可能因为没收到ACK而重传了一个FIN报文，这个FIN报文要从网络中消失最多还需要一个MSL时长，所以A还需要多等一个MSL。</p>
</li>
</ul>
<p>综上所述，TIME_WAIT至少需要持续2MSL时长，这2个MSL中的第一个MSL是为了等自己发出去的最后一个ACK从网络中消失，而第二MSL是为了等在对端收到ACK之前的一刹那可能重传的FIN报文从网络中消失。可以看到 2MSL时长 这其实是相当于至少允许报文丢失一次。比如，若 ACK 在一个 MSL 内丢失，这样被动方重发的 FIN 会在第 2 个 MSL 内到达，TIME_WAIT 状态的连接可以应对。</p>
<p>为什么不是 4 或者 8 MSL 的时长呢？你可以想象一个丢包率达到百分之一的糟糕网络，连续两次丢包的概率只有万分之一，这个概率实在是太小了，忽略它比解决它更具性价比。</p>
<h3 id="在epoll中为什么用ET-NONBLOCKING"><a href="#在epoll中为什么用ET-NONBLOCKING" class="headerlink" title="在epoll中为什么用ET+NONBLOCKING"></a>在epoll中为什么用ET+NONBLOCKING</h3><ol>
<li>边缘触发只在第一次数据到达的时候通知wait，如果这次没读完，后面也不会通知wait(LT只要缓冲区中有数据就会通知wait)。 对于ET+BLOCKING，如果一个socket一次来了很多数据，一次没读完，这个时候就会从recv或者read返回，如果后面还有数据来还好，如果没数据再来，程序一直阻塞在wait调用，剩下的数据就会一直停留在socket的缓冲区中等待读取。那能不能一次把数据读完呢，这个时候就会出现新的问题，阻塞读可能会花费很长的时间，这样就没机会处理epoll中的其他事件了。使用非阻塞读取的话，<a target="_blank" rel="noopener" href="https://copyconstruct.medium.com/nonblocking-i-o-99948ad7c957">读操作会立即返回(即使数据没有完全被读出来)</a>。这样就可以去处理epoll的其他事件了。</li>
<li>假设一个消息要读三次才能读完，在阻塞IO里要注意，epoll只会通知有数据可以读，但是不会通知可以读多少，所以只能读取一次，然后等待下一次epoll_wait通知下一次读取事件。可能我们会想，为什么不用循环读呢，原因是因为我们不知道到底有多少数据要读，不知道要读多少次，while循环的话，本来只需要读三次就能读完，那么第四次循环就会阻塞。而非阻塞采用这种方案就不会出现这种情况，因为没数据读的时候会直接返回-1，并设置errno为EAGAIN或者EWOULDBLOCK。</li>
<li>还有就是对于select来说，man select里面bug节说一：<br>Under Linux, select() may report a socket file descriptor as “ready for reading”, while nevertheless a subsequent read blocks.  This could for example happen when       data has arrived but upon examination has wrong checksum and is discarded.  There may be other circumstances in which a file descriptor is spuriously reported  as       ready.  Thus it may be safer to use O_NONBLOCK on sockets that should not block.</li>
</ol>
<h3 id="使用Linux-epoll模型的LT水平触发模式，当socket可写时，会不停的触发socket可写的事件，如何处理？"><a href="#使用Linux-epoll模型的LT水平触发模式，当socket可写时，会不停的触发socket可写的事件，如何处理？" class="headerlink" title="使用Linux epoll模型的LT水平触发模式，当socket可写时，会不停的触发socket可写的事件，如何处理？"></a>使用Linux epoll模型的LT水平触发模式，当socket可写时，会不停的触发socket可写的事件，如何处理？</h3><p>网络流传的腾讯面试题<br>这道题目对LT和ET考察比较深入，验证了前文说的LT模式write问题。</p>
<p>普通做法：</p>
<p>当需要向socket写数据时，将该socket加入到epoll等待可写事件。接收到socket可写事件后，调用write()或send()发送数据，当数据全部写完后， 将socket描述符移出epoll列表，这种做法需要反复添加和删除。</p>
<p>改进做法:</p>
<p>向socket写数据时直接调用send()发送，当send()返回错误码EAGAIN，才将socket加入到epoll，等待可写事件后再发送数据，全部数据发送完毕，再移出epoll模型，改进的做法相当于认为socket在大部分时候是可写的(小数据)，不能写了再让epoll帮忙监控(数据太大了触发EAGAIN)。</p>
<pre><code>当客户通过Socket提供的send函数发送大的数据包时，就可能返回一个EGGAIN的错误。该错误产生的原因是由于send 函数中的size变量大小超过了tcp_sendspace的值。
</code></pre>
<h2 id="LINUX"><a href="#LINUX" class="headerlink" title="LINUX"></a>LINUX</h2><h3 id="驱动相关"><a href="#驱动相关" class="headerlink" title="驱动相关"></a>驱动相关</h3><h4 id="设备树是什么"><a href="#设备树是什么" class="headerlink" title="设备树是什么"></a>设备树是什么</h4><p>设备树（device tree）机制是Linux内核从linux-3.x版本开始引进的一种机制，目的是解决内核源码的arch/arm目录下代码混乱的问题：随着ARM生态的快速发展，在内核源码的arch/arm目录下，存放着几十种arm芯片和几百个开发板相关的源文件，很多开发板和处理器的中断、寄存器等相关硬件资源都在这个目录下以.c或.h的文件格式定义。而对于内核来说，与这些硬件耦合，会导致内核代码混乱不堪，每个开发板上运行的内核镜像都必须单独编译配置，无法通用。什么时候Linux内核能像Windows镜像那样，无论你的电脑什么配置，一个Windows安装包，都可以直接下载安装运行呢？</p>
<p>设备树(Device Tree)，将这个词分开就是“设备”和“树”，描述设备树的文件叫做 DTS(DeviceTree Source)，这个 DTS 文件采用树形结构描述板级设备，也就是开发板上的设备信息，比如CPU 数量、 内存基地址、IIC 接口上接了哪些设备、SPI 接口上接了哪些设备等等。</p>
<p>它基本上就是画一棵电路板上 CPU、总线、设备组成的树，Bootloader 会将这棵树传<br>递给内核，然后内核可以识别这棵树，并根据它展开出 Linux 内核中的 platform_device、<br>i2c_client、spi_device 等设备，而这些设备用到的内存、IRQ 等资源，也被传递给了内核，内核会将这些资源绑定给展开的相应的设备。</p>
<p>总结： 以前对于arm来说， 每个硬件都是在.c .h文件中用代码手写的，比如配置寄存器之类的代码，随着arm芯片和开发板不断增加，内核肯定越来越大，而且很混乱。 有了设备树，只有设备树上的设备才是需要的，这些设备的硬件上的细节由DTB提供给内核， 而不需要像之前写在代码里。 DTS经过DTC编译得到DTB， DTB由BootLoader传递给内核。</p>
<p>为什么windows不需要DT呢， 似乎说windows的设备都是通过pcie连接的，可以枚举出来。或者x86 架构的个人计算机通常不使用设备树，而是依靠各种自动配置协议来识别硬件。</p>
<p>不懂Linux Device Tree，被新人嘲笑之后，含泪写完 - 与非网<br><a target="_blank" rel="noopener" href="https://www.eefocus.com/article/474573.html">https://www.eefocus.com/article/474573.html</a></p>
<p>Microsoft Word - ARM Device Tree设备树.docx<br><a target="_blank" rel="noopener" href="http://www.valleytalk.org/wp-content/uploads/2013/05/ARM-Device-Tree%E8%AE%BE%E5%A4%87%E6%A0%91.pdf">http://www.valleytalk.org/wp-content/uploads/2013/05/ARM-Device-Tree%E8%AE%BE%E5%A4%87%E6%A0%91.pdf</a></p>
<h4 id="LINUX设备驱动模型"><a href="#LINUX设备驱动模型" class="headerlink" title="LINUX设备驱动模型"></a>LINUX设备驱动模型</h4><p>一文带你搞懂 Linux 设备树 - 知乎<br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/476561682">https://zhuanlan.zhihu.com/p/476561682</a></p>
<h3 id="LINUX-1"><a href="#LINUX-1" class="headerlink" title="LINUX"></a>LINUX</h3><ol>
<li>sed的/和字符串变量里面的/冲突了怎么办？把sed分隔符随便换一个就行，比如~  <a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/27787536/how-to-pass-a-variable-containing-slashes-to-sed">bash - How to pass a variable containing slashes to sed - Stack Overflow</a></li>
<li></li>
<li></li>
</ol>
<h2 id="循环引用的解释"><a href="#循环引用的解释" class="headerlink" title="循环引用的解释"></a>循环引用的解释</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">		std::shared_ptr&lt;Person&gt; best_friend;</span><br><span class="line">		<span class="built_in">Person</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;ctor &quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">		~<span class="built_in">Person</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;dtor &quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">auto</span> pa = std::make_shared&lt;Person&gt;();</span><br><span class="line">	<span class="keyword">auto</span> pb = std::make_shared&lt;Person&gt;();</span><br><span class="line">	pa-&gt;best_friend = pb;</span><br><span class="line">	pb-&gt;best_friend = pa;</span><br><span class="line">&#125;<span class="comment">//1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<pre><code>上面的析构函数一个都不会打印。当离开1的时候，pa是一个智能指针，它会查看它自己的ref count，发现是2（pa和pb-&gt;best_friend都指向同一个对象），所以它的ref count减一，但并不销毁pa指向的对象。pb也是一样，他们各自离开1之后，pa和pb指向的std::shared_ptr&lt;Person&gt;对象的ref count都是1，因此，发生了内存泄露。 

如果我们把best_friend的类型改写成std::weak_ptr&lt;Person&gt;就不会出现上述的问题，因此weak_ptr指向一个shared对象并不会使该对象的ref count计数加一。weak_ptr只是拥有使用权，但并不拥有管理权。
</code></pre>
<p>Even if both pa and pb are deconstructed out of scope, the memory will not be released. Why? After pa leaves the scope, the only pointer object of pa has actually died, but the object pointed to by pa has not died, because at this time one of pb can only point to this object. After pb leaves the scope, the smart pointer pb is actually finished, but the object pointed to by pb is not dead, because there is still a pointer to it in the object pointed to by pa. Finally, because the two objects hold pointers to each other, their reference counts are both 1, which makes the memory unable to be released. </p>
<p>After understanding the implementation principle of smart pointers and the principle of memory leaks caused by circular references, use</p>
<p>weak_ptr<br>This kind of weak pointer that does not increase the reference count can solve this problem well.</p>
<h2 id="智力题"><a href="#智力题" class="headerlink" title="智力题"></a>智力题</h2><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/2d54e2affb91">https://www.jianshu.com/p/2d54e2affb91</a></p>
<h2 id="misc"><a href="#misc" class="headerlink" title="misc"></a>misc</h2><h3 id="auto-login-remote-server-via-vscode"><a href="#auto-login-remote-server-via-vscode" class="headerlink" title="auto login remote server via vscode"></a>auto login remote server via vscode</h3><p>run following command in powershell(hostname might be a ip adress):</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$USER_AT_HOST</span>=<span class="string">&quot;your-user-name-on-host@hostname&quot;</span></span><br><span class="line"><span class="variable">$PUBKEYPATH</span>=<span class="string">&quot;<span class="variable">$HOME</span>\.ssh\id_ed25519.pub&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$pubKey</span>=(Get-Content <span class="string">&quot;<span class="variable">$PUBKEYPATH</span>&quot;</span> | Out-String); ssh <span class="string">&quot;<span class="variable">$USER_AT_HOST</span>&quot;</span> <span class="string">&quot;mkdir -p ~/.ssh &amp;&amp; chmod 700 ~/.ssh &amp;&amp; echo &#x27;<span class="variable">$&#123;pubKey&#125;</span>&#x27; &gt;&gt; ~/.ssh/authorized_keys &amp;&amp; chmod 600 ~/.ssh/authorized_keys&quot;</span></span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://code.visualstudio.com/docs/remote/troubleshooting">Visual Studio Code Remote Development Troubleshooting Tips and Tricks</a></p>
<h3 id="github镜像站"><a href="#github镜像站" class="headerlink" title="github镜像站"></a>github镜像站</h3><p><a target="_blank" rel="noopener" href="https://github.rc1844.workers.dev/">https://github.rc1844.workers.dev/</a></p>
<p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000041466088">2022目前三种有效加速国内Github - 个人文章 - SegmentFault 思否</a></p>
<h3 id="ANSI，unicode和utf-8的关系"><a href="#ANSI，unicode和utf-8的关系" class="headerlink" title="ANSI，unicode和utf-8的关系"></a>ANSI，unicode和utf-8的关系</h3><p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000003493738">编码基础概念:ANSI和unicode - SegmentFault 思否</a></p>
<h3 id="如何将C盘上的wsl2转移到其他盘"><a href="#如何将C盘上的wsl2转移到其他盘" class="headerlink" title="如何将C盘上的wsl2转移到其他盘"></a>如何将C盘上的wsl2转移到其他盘</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">wsl --list --verbose</span><br><span class="line">mkdir d:\backuplinux</span><br><span class="line">wsl --<span class="built_in">export</span> Ubuntu-18.04 d:\backuplinux\ubuntu.tar</span><br><span class="line">wsl --unregister Ubuntu-18.04</span><br><span class="line">mkdir d:\wsl</span><br><span class="line">wsl --import Ubuntu-18.04 d:\wsl\ d:\backuplinux\ubuntu.tar</span><br><span class="line"><span class="built_in">cd</span> %userprofile%\AppData\Local\Microsoft\WindowsApps            **(this is not needed <span class="keyword">if</span> <span class="keyword">in</span> path)**</span><br><span class="line">ubuntu1804.exe config --default-user yourloginname</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://superuser.com/questions/1550622/move-wsl2-file-system-to-another-drive">windows subsystem for linux - Move WSL2 file system to another drive - Super User</a></p>
<h2 id="E"><a href="#E" class="headerlink" title="E"></a>E</h2><p>天府新区创新创业人才云服务平台-成都数字媒体产业化基地有限公司<br><a target="_blank" rel="noopener" href="https://www.tianfustartup.org.cn/secondlevel/recruit?Id=kUPturIhdDtCuzgtnW22UQ==">https://www.tianfustartup.org.cn/secondlevel/recruit?Id=kUPturIhdDtCuzgtnW22UQ==</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">John Doe</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">22</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
