<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="算法背包问题为什么01背包要逆序而完全背包不用首先，通过上一个问题，我们确认了我们目前一维的dp数组，保存的是确认过的最新一层的数据，即上一层的数据。 当我们计算当前层时，对于二维时的状态转移方程有 dp[i][j] &#x3D; max(dp[i][j], dp[i - 1][j - v[i]] + w[i]); 可以看到，dp[i - 1][j - v[i]] + w[i] 使用的上一层的原始数据（dp">
<meta property="og:type" content="article">
<meta property="og:title" content="notes-1">
<meta property="og:url" content="http://example.com/2022/08/02/notes-1/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="算法背包问题为什么01背包要逆序而完全背包不用首先，通过上一个问题，我们确认了我们目前一维的dp数组，保存的是确认过的最新一层的数据，即上一层的数据。 当我们计算当前层时，对于二维时的状态转移方程有 dp[i][j] &#x3D; max(dp[i][j], dp[i - 1][j - v[i]] + w[i]); 可以看到，dp[i - 1][j - v[i]] + w[i] 使用的上一层的原始数据（dp">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/imgs/2023-03-28-21-58-29.png">
<meta property="og:image" content="http://example.com/imgs/2023-03-28-22-06-37.png">
<meta property="og:image" content="http://example.com/imgs/2023-03-28-21-58-04.png">
<meta property="og:image" content="http://example.com/imgs/2023-03-28-22-04-03.png">
<meta property="og:image" content="http://example.com/imgs/2023-03-28-22-04-15.png">
<meta property="og:image" content="http://example.com/imgs/image.png.png">
<meta property="og:image" content="http://example.com/imgs/2022-12-03-21-45-50.png">
<meta property="og:image" content="http://example.com/imgs/2023-04-29-21-31-26.png">
<meta property="og:image" content="http://example.com/imgs/2023-04-29-21-31-57.png">
<meta property="og:image" content="http://example.com/imgs/2023-04-28-16-31-23.png">
<meta property="og:image" content="http://example.com/imgs/2023-04-28-17-39-00.png">
<meta property="og:image" content="http://example.com/imgs/2023-05-04-22-04-37.png">
<meta property="og:image" content="http://example.com/imgs/2023-05-04-22-08-19.png">
<meta property="og:image" content="http://example.com/imgs/2023-05-04-22-09-41.png">
<meta property="og:image" content="http://example.com/imgs/2023-05-04-22-14-43.png">
<meta property="og:image" content="http://example.com/imgs/2023-05-18-23-16-50.png">
<meta property="article:published_time" content="2022-08-02T02:45:26.000Z">
<meta property="article:modified_time" content="2023-05-21T14:56:12.631Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/imgs/2023-03-28-21-58-29.png">

<link rel="canonical" href="http://example.com/2022/08/02/notes-1/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>notes-1 | Hexo</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hexo</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/08/02/notes-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          notes-1
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-08-02 10:45:26" itemprop="dateCreated datePublished" datetime="2022-08-02T10:45:26+08:00">2022-08-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-05-21 22:56:12" itemprop="dateModified" datetime="2023-05-21T22:56:12+08:00">2023-05-21</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><h3 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h3><h4 id="为什么01背包要逆序而完全背包不用"><a href="#为什么01背包要逆序而完全背包不用" class="headerlink" title="为什么01背包要逆序而完全背包不用"></a>为什么01背包要逆序而完全背包不用</h4><p>首先，通过上一个问题，我们确认了我们目前一维的dp数组，保存的是确认过的最新一层的数据，即上一层的数据。</p>
<p>当我们计算当前层时，对于二维时的状态转移方程有</p>
<p>dp[i][j] = max(dp[i][j], dp[i - 1][j - v[i]] + w[i]);</p>
<p>可以看到，dp[i - 1][j - v[i]] + w[i] 使用的上一层的原始数据（dp[i - 1]），而我们使用一维的状态转移方程时有</p>
<p>dp[j] = max(dp[j], dp[j - v[i]] + w[i]);</p>
<p>当我们从小到大更新是， 因为j - v[i] 是严格小于j 的，所以我们可以举个例子 dp[3] = max(dp[3], dp[2] + 1); 因为我们是从小到大更新的，所以当更新到dp[3]的时候，dp[2]已经更新过了，已经不是上一层的dp[2]。</p>
<p>而当我们逆序更新时有，举例 dp[8] = max(dp[8], dp[6] + 2)当更新dp[8]时，dp[6]还没有被更新，还是上一层的数据，这样才能保证没有读入脏数据。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> dp[N][N];</span><br><span class="line"><span class="keyword">int</span> v[N], w[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cin &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">            <span class="keyword">if</span>(j &gt;= v[i]) dp[i][j] = <span class="built_in">max</span>(dp[i][j], dp[i - <span class="number">1</span>][j - v[i]] + w[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; dp[n][m];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> dp[N];</span><br><span class="line"><span class="keyword">int</span> v[N], w[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cin &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = m; j &gt;= v[i]; j --)</span><br><span class="line">            dp[j] = <span class="built_in">max</span>(dp[j], dp[j - v[i]] + w[i]);</span><br><span class="line">    cout &lt;&lt; dp[m];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="K排序"><a href="#K排序" class="headerlink" title="K排序"></a>K排序</h3><p><img src="/../imgs/2023-03-28-21-58-29.png"><br>每次拿K个放到最后，最少要放多少次数组有序。<br>思路： 从前往后遍历数组， 找到不按顺序的数，然后除以K就是答案，比如<code>1,2,5,4,3</code>，那么不按顺序的数就是<code>5,4</code>，因此需要2/2=1依次即可。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> next_find = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> n=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> uo_cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.<span class="built_in">size</span>(); i++&gt;)&#123;</span><br><span class="line">	<span class="keyword">if</span>(nums[i]==next_find) next_find++;</span><br><span class="line">&#125;</span><br><span class="line">uo_cnt = n-next_find;</span><br><span class="line"><span class="keyword">if</span>(uo_cnt%k==<span class="number">0</span>) ans = ans/k;</span><br><span class="line"><span class="keyword">else</span> ans = ans/k + <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<h3 id="删除字符串，得到最大的小数"><a href="#删除字符串，得到最大的小数" class="headerlink" title="删除字符串，得到最大的小数"></a>删除字符串，得到最大的小数</h3><p><img src="/../imgs/2023-03-28-22-06-37.png"></p>
<p>思路1： 从前往后找，一次找最大的数，然后再在剩下的数中找最大的数，直到找到最后。这个方法会超时， 因为复杂度是ON2。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">string ans;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tr</span><span class="params">(string s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s.<span class="built_in">size</span>()==<span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">auto</span> it = std::<span class="built_in">max_element</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">int</span> idx = it-s.<span class="built_in">begin</span>();</span><br><span class="line">    ans.<span class="built_in">push_back</span>(*it);</span><br><span class="line">    std::cout&lt;&lt;*it&lt;&lt;std::endl;</span><br><span class="line">    <span class="built_in">tr</span>(s.<span class="built_in">substr</span>(idx+<span class="number">1</span>, s.<span class="built_in">size</span>()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">string  <span class="title">s</span><span class="params">(<span class="string">&quot;0.411523&quot;</span>)</span></span>;</span><br><span class="line">    <span class="built_in">tr</span>(s.<span class="built_in">substr</span>(<span class="number">1</span>, s.<span class="built_in">size</span>()));</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;0.&quot;</span>+ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>思路2：从后往前找，最后一个数是肯定是要的，依次找比上一次数字大的数字，直到遍历完整个字符串， 这个方法复杂度是ON</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">string ans;</span><br><span class="line">ans.<span class="built_in">push_back</span>(s[s.<span class="built_in">size</span>()<span class="number">-1</span>])</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=s.<span class="built_in">size</span>()<span class="number">-2</span>; i&gt;=<span class="number">2</span>; i--)&#123;</span><br><span class="line">	<span class="keyword">if</span>(s[i]&gt;=s[s.<span class="built_in">size</span>()<span class="number">-1</span>]) s.<span class="built_in">push_back</span>(s[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="01串变成全0或者1"><a href="#01串变成全0或者1" class="headerlink" title="01串变成全0或者1"></a>01串变成全0或者1</h3><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/exam/test/67568180/detail?pid=43184608&amp;examPageSource=Company&amp;testCallback=https://www.nowcoder.com/exam/company&amp;testclass=%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91">https://www.nowcoder.com/exam/test/67568180/detail?pid=43184608&amp;examPageSource=Company&amp;testCallback=https%3A%2F%2Fwww.nowcoder.com%2Fexam%2Fcompany&amp;testclass=%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91</a></p>
<p>给定一个只包含’0’和’1’两种字符的字符串，每次操作可以选择相邻的两个字符，将它们同时变成’0’或者同时变成’1’。<br>请问最少多少次操作后，所有的字符都相同？</p>
<p>思路：选择0或者1作为分隔符，然后统计另一种字符连续出现个数，然后判断需要几次变成全1或者全0.<br>比如选择1作为分隔符，我们要做的就是找到所有0，然后把他们变成1。 如果当前字符是0， 则cnt++，如果是1，则计算前面的0需要多少次才能变成全1，然后将cnt=0.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @param str string字符串 </span></span><br><span class="line"><span class="comment">     * @return int整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(string str, <span class="keyword">char</span> dem)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;str.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(str[i]==dem)&#123;</span><br><span class="line">                <span class="keyword">if</span>(cnt%<span class="number">2</span>==<span class="number">0</span>) ans += cnt/<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">else</span> ans += cnt/<span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">                cnt = <span class="number">0</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cnt%<span class="number">2</span>==<span class="number">0</span>) ans += cnt/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">else</span> ans += cnt/<span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minOperations</span><span class="params">(string str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min</span>(<span class="built_in">f</span>(str, <span class="string">&#x27;0&#x27;</span>), <span class="built_in">f</span>(str, <span class="string">&#x27;1&#x27;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h3 id="将链表分组，然后两两交换"><a href="#将链表分组，然后两两交换" class="headerlink" title="将链表分组，然后两两交换"></a>将链表分组，然后两两交换</h3><p><img src="/../imgs/2023-03-28-21-58-04.png"><br>两个组就四个节点，用四个指针，将将他们首尾交换，然后再找下一个四个节点的子链表，直到剩下的节点不足4个，将其特殊处理。</p>
<h3 id="最大公约数的个数"><a href="#最大公约数的个数" class="headerlink" title="最大公约数的个数"></a>最大公约数的个数</h3><p><img src="/../imgs/2023-03-28-22-04-03.png"><br><img src="/../imgs/2023-03-28-22-04-15.png"></p>
<h3 id="异或等于乘积"><a href="#异或等于乘积" class="headerlink" title="异或等于乘积"></a>异或等于乘积</h3><p><img src="/../imgs/image.png.png"></p>
<h2 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">A</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;default constructer: &quot;</span>&lt;&lt;<span class="keyword">this</span>&lt;&lt;<span class="string">&quot;\n&quot;</span>; &#125; <span class="comment">// 1</span></span><br><span class="line">	<span class="built_in">A</span>(<span class="keyword">const</span> A&amp; a) &#123; std::cout &lt;&lt; <span class="string">&quot;copy constructer: &quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>; &#125;<span class="comment">// 2</span></span><br><span class="line">	<span class="built_in">A</span>(A&amp;&amp; a) &#123; std::cout &lt;&lt; <span class="string">&quot;move constructer: &quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>; &#125;<span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">	~<span class="built_in">A</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;de-constructer: &quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>; &#125; <span class="comment">// 4</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">A <span class="title">test1</span><span class="params">(A a)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	A a;</span><br><span class="line">	<span class="built_in">test1</span>(a);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>the output?</p>
<p>在函数里面的对象，函数退出的时候对象会被销毁，所以一定会构造一个新的对象，而且一个对象反正要销毁了，不如用移动构造函数偷一点资源(比如堆上的)</p>
<h3 id="make-shared"><a href="#make-shared" class="headerlink" title="make_shared"></a>make_shared</h3><p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/20895648/difference-in-make-shared-and-normal-shared-ptr-in-c">c++11 - Difference in make_shared and normal shared_ptr in C++ - Stack Overflow</a></p>
<h2 id="gdb"><a href="#gdb" class="headerlink" title="gdb"></a>gdb</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set disassemble-next-line on</span><br></pre></td></tr></table></figure>

<h2 id="内联汇编"><a href="#内联汇编" class="headerlink" title="内联汇编"></a>内联汇编</h2><p><a target="_blank" rel="noopener" href="https://gcc.gnu.org/onlinedocs/gcc/Extended-Asm.html">Extended Asm (Using the GNU Compiler Collection (GCC))</a></p>
<h2 id="代码粘贴"><a href="#代码粘贴" class="headerlink" title="代码粘贴"></a>代码粘贴</h2><p><a target="_blank" rel="noopener" href="https://www.regendus.com/best-pastebin-alternatives/">7 Best Pastebin Alternatives and Similar Sites in 2022 - REGENDUS</a></p>
<h2 id="C-1"><a href="#C-1" class="headerlink" title="C++"></a>C++</h2><h3 id="读取char-比const-char-快"><a href="#读取char-比const-char-快" class="headerlink" title="读取char[]比const char*快"></a>读取char[]比const char*快</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">char</span> a = <span class="number">1</span>;  </span><br><span class="line">    <span class="keyword">char</span> c[] = <span class="string">&quot;1234567890&quot;</span>;  </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *p =<span class="string">&quot;1234567890&quot;</span>;  </span><br><span class="line">    a = c[<span class="number">1</span>];  </span><br><span class="line">    a = p[<span class="number">1</span>];  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>对于<code>a = c[1]</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">movzx   eax, BYTE PTR [rbp-26]</span><br><span class="line">mov     BYTE PTR [rbp-1], al</span><br></pre></td></tr></table></figure>
<p>这是因为c是一个栈上的数组，初始化在栈上，编译器知道<code>rbp-26</code>就是<code>c[1]</code>的地址, 因此一行代码就可以将栈上的值读到寄存器上。 <code>[rbp-1]</code>表示a的地址，因为a是char，所以-1，如果是int， 应该-4.</p>
<p>而<code>a = p[1]</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov     rax, QWORD PTR [rbp-16]</span><br><span class="line">add     rax, 1</span><br><span class="line">movzx   eax, BYTE PTR [rax]</span><br><span class="line">mov     BYTE PTR [rbp-1], al</span><br></pre></td></tr></table></figure>
<p>然而p是一个指针，指向的”1234567890”位于rodata上，p本身是在栈上的，所以为了读取p[1]，首先将p代表的地址读到rax寄存器中(<code>mov     rax, QWORD PTR [rbp-16]</code>)，然后再加1，表示读取p[1]，读到寄存器中之后还要写到栈上。</p>
<p>但是这都是没优化的代码, 如果用了O1,O2,O3，这两句代码没什么区别，因为编译器一句汇编都不会为他们生成。</p>
<h3 id="C-Using-weak-ptr-for-circular-references-nextptr"><a href="#C-Using-weak-ptr-for-circular-references-nextptr" class="headerlink" title="C++ | Using weak_ptr for circular references - nextptr"></a><a target="_blank" rel="noopener" href="https://www.nextptr.com/tutorial/ta1382183122/using-weak_ptr-for-circular-references">C++ | Using weak_ptr for circular references - nextptr</a></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">		std::shared_ptr&lt;Person&gt; best_friend;</span><br><span class="line">		<span class="built_in">Person</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;ctor &quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">		~<span class="built_in">Person</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;dtor &quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">auto</span> pa = std::make_shared&lt;Person&gt;();</span><br><span class="line">	<span class="keyword">auto</span> pb = std::make_shared&lt;Person&gt;();</span><br><span class="line">	pa-&gt;best_friend = pb;</span><br><span class="line">	pb-&gt;best_friend = pa;</span><br><span class="line">&#125;<span class="comment">//1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<pre><code>上面的析构函数一个都不会打印。当离开1的时候，pa是一个智能指针，它会查看它自己的ref count，发现是2（pa和pb-&gt;best_friend都指向同一个对象），所以它的ref count减一，但并不销毁pa指向的对象。pb也是一样，他们各自离开1之后，pa和pb指向的std::shared_ptr&lt;Person&gt;对象的ref count都是1，因此，发生了内存泄露。 

如果我们把best_friend的类型改写成std::weak_ptr&lt;Person&gt;就不会出现上述的问题，因此weak_ptr指向一个shared对象并不会使该对象的ref count计数加一。weak_ptr只是拥有使用权，但并不拥有管理权。
</code></pre>
<h3 id="c-11-When-is-std-weak-ptr-useful-Stack-Overflow"><a href="#c-11-When-is-std-weak-ptr-useful-Stack-Overflow" class="headerlink" title="c++11 - When is std::weak_ptr useful? - Stack Overflow"></a><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/12030650/when-is-stdweak-ptr-useful">c++11 - When is std::weak_ptr useful? - Stack Overflow</a></h3><pre><code>   std::weak_ptr is a very good way to solve the dangling pointer problem. By just using raw pointers it is impossible to know if the referenced data has been deallocated or not. Instead, by letting a std::shared_ptr manage the data, and supplying std::weak_ptr to users of the data, the users can check validity of the data by calling expired() or lock().

You could not do this with std::shared_ptr alone, because all std::shared_ptr instances share the ownership of the data which is not removed before all instances of std::shared_ptr are removed. 
</code></pre>
<h3 id="c-Why-would-I-std-move-an-std-shared-ptr-Stack-Overflow"><a href="#c-Why-would-I-std-move-an-std-shared-ptr-Stack-Overflow" class="headerlink" title="c++ - Why would I std::move an std::shared_ptr? - Stack Overflow"></a><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/41871115/why-would-i-stdmove-an-stdshared-ptr">c++ - Why would I std::move an std::shared_ptr? - Stack Overflow</a></h3><pre><code>share _ ptr 引用计数是原子的。增加或减少引用计数需要原子增量或减量。这比非原子的递增/递减要慢几百倍（原子操作可能需要几百个时钟周期），更不用说如果我们递增/递减相同的计数器，我们最终得到的是准确的数字，在这个过程中浪费了大量的时间和资源。
</code></pre>
<h3 id="c-What-is-The-Rule-of-Three-Stack-Overflow"><a href="#c-What-is-The-Rule-of-Three-Stack-Overflow" class="headerlink" title="c++ - What is The Rule of Three? - Stack Overflow"></a><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/4172722/what-is-the-rule-of-three">c++ - What is The Rule of Three? - Stack Overflow</a></h3><p>Rule of Three:<br>如果需要自己显式声明析构函数、复制构造函数或复制赋值操作符，那么可能需要显式声明所有这三个操作符。</p>
<p>之所以有三规则，是因为对于类的成员变量，编译器生成的默认构造函数会自动帮我们将他们复制到新的类的成员变量中。</p>
<p>如果我们这样定义一个类：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    std::string name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">person</span>(<span class="keyword">const</span> std::string&amp; name, <span class="keyword">int</span> age) : <span class="built_in">name</span>(name), <span class="built_in">age</span>(age)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>编译器会为我们隐式生成下面的函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. copy constructor</span></span><br><span class="line"><span class="built_in">person</span>(<span class="keyword">const</span> person&amp; that) : <span class="built_in">name</span>(that.name), <span class="built_in">age</span>(that.age)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. copy assignment operator</span></span><br><span class="line">person&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> person&amp; that)</span><br><span class="line">&#123;</span><br><span class="line">    name = that.name;</span><br><span class="line">    age = that.age;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. destructor</span></span><br><span class="line">~<span class="built_in">person</span>()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此，如果我们的类要<code>管理资源</code>，这个资源需要我们自己申请和释放，这个时候很显然我们应该把上面三个函数都显式定义。不然默认的构造函数只是复制指针的值，并不会帮我们将指针指向的内容拷贝一份。同样，如果没有定义析构函数，那么会发生内存泄露。 如果我们只定义了析构函数去delete指针，而不在构造函数中拷贝指针指向的内存，两个类都去delete同一个内存区域，肯定会发生段错误的。</p>
<p>The Rule of Five</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    std::string name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">person</span>(<span class="keyword">const</span> std::string&amp; name, <span class="keyword">int</span> age);        <span class="comment">// Ctor</span></span><br><span class="line">    <span class="built_in">person</span>(<span class="keyword">const</span> person &amp;) = <span class="keyword">default</span>;                <span class="comment">// 1/5: Copy Ctor</span></span><br><span class="line">    <span class="built_in">person</span>(person &amp;&amp;) <span class="keyword">noexcept</span> = <span class="keyword">default</span>;            <span class="comment">// 4/5: Move Ctor</span></span><br><span class="line">    person&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> person &amp;) = <span class="keyword">default</span>;     <span class="comment">// 2/5: Copy Assignment</span></span><br><span class="line">    person&amp; <span class="keyword">operator</span>=(person &amp;&amp;) <span class="keyword">noexcept</span> = <span class="keyword">default</span>; <span class="comment">// 5/5: Move Assignment</span></span><br><span class="line">    ~<span class="built_in">person</span>() <span class="keyword">noexcept</span> = <span class="keyword">default</span>;                    <span class="comment">// 3/5: Dtor</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>




<h3 id="c-Why-is-auto-ptr-being-deprecated-Stack-Overflow"><a href="#c-Why-is-auto-ptr-being-deprecated-Stack-Overflow" class="headerlink" title="c++ - Why is auto_ptr being deprecated? - Stack Overflow"></a><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/3697686/why-is-auto-ptr-being-deprecated">c++ - Why is auto_ptr being deprecated? - Stack Overflow</a></h3><p>限制：</p>
<ul>
<li>auto_ptr不能指向数组。删除指向数组的指针时，我们必须使用delete[]来确保为数组中的所有对象调用析构函数，但 auto_ptr 使用delete。</li>
<li>它不能与STL 容器中的 STL 容器元素一起使用。复制 auto_ptr 时，内存的所有权将转移到新的 auto_ptr 并且原始设置为 NULL。</li>
</ul>
<p>auto_ptr的直接替代品（或最接近的东西）是unique_ptr. 就“问题”而言，它非常简单：auto_ptr在分配时转移所有权，也就是说，复制auto_ptr时，内存的所有权将转移到新的auto_ptr并且原始设置为NULL，这很不合理，复制一个对象，不应该修改被复制对象的状态，除非我们有移动语义。unique_ptr也转移所有权，但由于移动语义的编码和右值引用的魔力，它可以更自然地完成。它还“适合”标准库的其余部分（尽管，公平地说，其中一些要归功于库的其余部分进行了更改以适应移动语义，而不是总是需要复制）。 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::auto_ptr&lt;T&gt; <span class="title">ap</span><span class="params">(<span class="keyword">new</span> T&#123;...&#125;)</span></span>; </span><br><span class="line"><span class="function">std::auto_ptr&lt;T&gt; <span class="title">ap2</span><span class="params">(ap)</span></span>; <span class="comment">// 复制构造函数调用的时候，ap会变成nullptr</span></span><br><span class="line">ap-&gt;xyz; <span class="comment">// 段错误</span></span><br></pre></td></tr></table></figure>

<p>简而言之，auto_ptr和unique_ptr都表示在任何时刻，程序中只能有一份这样的智能指针，但区别在于auto_ptr没有禁用复制构造函数，这样会导致auto_ptr的所有权被悄悄的偷取，然后将原指针设置为nullptr，我们如果没有发现原auto_ptr被设置成nullptr，再次通过指针做一些事情的时候，比如调用函数，就会段错误。 但是unique_tpr会阻止这种情况的发生，除非使用move。</p>
<h3 id="手写一个shared-ptr"><a href="#手写一个shared-ptr" class="headerlink" title="手写一个shared_ptr"></a>手写一个shared_ptr</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">shared_ptr</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">shared_ptr</span><span class="params">()</span>: _refcnt(nullptr), _ptr(nullptr)&#123;</span>&#125;</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">shared_ptr</span><span class="params">(T *ptr)</span>:_ptr(ptr), _refcnt(new uint(<span class="number">1</span>))&#123;</span>&#125;</span><br><span class="line">  ~<span class="built_in">shared_ptr</span>()&#123;</span><br><span class="line">    <span class="keyword">delete</span> _refcnt;</span><br><span class="line">    <span class="keyword">delete</span> _ptr;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// copy constructor</span></span><br><span class="line">  <span class="built_in">shared_ptr</span>(shared_ptr&lt;T&gt; &amp;sp)&#123;</span><br><span class="line">    _ptr = sp._ptr;</span><br><span class="line">    _refcnt = sp._refcnt;</span><br><span class="line">    ++(*_refcnt);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//copy assignment</span></span><br><span class="line">  shared_ptr&lt;T&gt;&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> shared_ptr&lt;T&gt; &amp;sp)&#123;</span><br><span class="line">    <span class="keyword">if</span>(sp._ptr!=_ptr)&#123;</span><br><span class="line">      <span class="keyword">if</span>(--(*_refcnt)==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">delete</span> _ptr;</span><br><span class="line">        <span class="keyword">delete</span> _refcnt;</span><br><span class="line">      &#125;</span><br><span class="line">      _refcnt = sp._refcnt;</span><br><span class="line">      _ptr = sp._ptr;</span><br><span class="line">      ++(*_refcnt);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// move constructor</span></span><br><span class="line">  <span class="built_in">shared_ptr</span>(shared_ptr&lt;T&gt;&amp;&amp; sp)&#123;</span><br><span class="line">    _ptr = sp.ptr;</span><br><span class="line">    _refcnt = sp.refcnt;</span><br><span class="line">    sp.ptr=sp.refcnt = <span class="literal">nullptr</span>;</span><br><span class="line">  &#125; </span><br><span class="line"></span><br><span class="line">  <span class="comment">// move assignment</span></span><br><span class="line">  <span class="function">shared_ptr&lt;T&gt;&amp; <span class="title">shared_ptr</span><span class="params">(shared_ptr&lt;T&gt;&amp;&amp; sp)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(--(*_refcnt)==<span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">delete</span> _refcnt;</span><br><span class="line">      <span class="keyword">delete</span> _ptr;</span><br><span class="line">    &#125;</span><br><span class="line">    _ptr = sp.ptr;</span><br><span class="line">    _refcnt = sp.refcnt;</span><br><span class="line">    sp.ptr=sp.refcnt = <span class="literal">nullptr</span>;</span><br><span class="line">  &#125; </span><br><span class="line"></span><br><span class="line">  T&amp; <span class="keyword">operator</span>*() &#123;<span class="keyword">return</span> *_ptr;&#125;</span><br><span class="line">  T* <span class="keyword">operator</span>-&gt;()&#123;<span class="keyword">return</span> _ptr;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">void</span> _clean()&#123;</span><br><span class="line">    <span class="keyword">if</span>(--(*_refcnt)==<span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">delete</span> _ptr;</span><br><span class="line">      <span class="keyword">delete</span> _refcnt;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  uint *_refcnt;</span><br><span class="line">  T *_ptr;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="C-声明移动-复制操作会抑制相关操作的生成"><a href="#C-声明移动-复制操作会抑制相关操作的生成" class="headerlink" title="C++ 声明移动/复制操作会抑制相关操作的生成"></a><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/44049179/c-declare-a-move-copy-operation-will-suppress-generation-of-related-operations">C++ 声明移动/复制操作会抑制相关操作的生成</a></h3><p>关于类的构造函数：</p>
<p>如果为类声明任何其他构造函数，则不会定义默认构造函数。<br>如果声明移动操作，则复制操作将被隐式删除。<br>如果声明复制操作，则移动操作将被隐式删除。</p>
<h3 id="C-return-local-object-Stack-Overflow"><a href="#C-return-local-object-Stack-Overflow" class="headerlink" title="C++ return local object - Stack Overflow"></a><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/6350882/c-return-local-object">C++ return local object - Stack Overflow</a></h3><p>从函数返回一个局部对象，会在caller堆栈中调用复制构造函数。但是这个步骤可以被省略，叫做copy elision。<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/12953127/what-are-copy-elision-and-return-value-optimization/12953145#12953145">c++ - What are copy elision and return value optimization? - Stack Overflow</a></p>
<h3 id="Indirect-vs-Direct-Function-Call-Overhead-in-C-C"><a href="#Indirect-vs-Direct-Function-Call-Overhead-in-C-C" class="headerlink" title="Indirect vs Direct Function Call Overhead in C/C++"></a><a target="_blank" rel="noopener" href="https://gist.github.com/rianhunter/0be8dc116b120ad5fdd4">Indirect vs Direct Function Call Overhead in C/C++</a></h3><p>间接调用（通过指向函数的指针）要比直接调用慢3.4倍. 函数参数是多个函数指针的时候，寄存器就不够用了. 如果寄存器够用，那速度应该差不多。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">direct_version</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i, b = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; INT_MAX; ++i) &#123;</span><br><span class="line">      b = <span class="built_in">foo</span>(b) + <span class="built_in">bar</span>(b) + <span class="built_in">baz</span>(b);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indirect_version</span><span class="params">(<span class="keyword">int</span> (*fn)(<span class="keyword">int</span>), <span class="keyword">int</span> (*fn2)(<span class="keyword">int</span>), <span class="keyword">int</span> (*fn3)(<span class="keyword">int</span>))</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i, b = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; INT_MAX; ++i) &#123;</span><br><span class="line">    b = <span class="built_in">fn</span>(b) + <span class="built_in">fn2</span>(b) + <span class="built_in">fn3</span>(b);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (argc == <span class="number">2</span> &amp;&amp; argv[<span class="number">1</span>][<span class="number">0</span>] == <span class="string">&#x27;d&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">direct_version</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">indirect_version</span>(&amp;foo, &amp;bar, &amp;baz);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="c-How-do-I-use-a-custom-deleter-with-a-std-unique-ptr-member-Stack-Overflow"><a href="#c-How-do-I-use-a-custom-deleter-with-a-std-unique-ptr-member-Stack-Overflow" class="headerlink" title="c++ - How do I use a custom deleter with a std::unique_ptr member? - Stack Overflow"></a><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/19053351/how-do-i-use-a-custom-deleter-with-a-stdunique-ptr-member">c++ - How do I use a custom deleter with a std::unique_ptr member? - Stack Overflow</a></h3><p>当unique_ptr管理的对象不是一个对象时，需要传递一个一个自定义的deleter。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">deleted_unique_ptr&lt;FILE&gt; <span class="title">file</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    fopen(<span class="string">&quot;file.txt&quot;</span>, <span class="string">&quot;r&quot;</span>),</span></span></span><br><span class="line"><span class="params"><span class="function">    [](FILE* f) &#123; fclose(f); &#125;)</span></span>;</span><br></pre></td></tr></table></figure>




<h3 id="vector的reserve和resize-李大嘴-博客园"><a href="#vector的reserve和resize-李大嘴-博客园" class="headerlink" title="vector的reserve和resize - 李大嘴 - 博客园"></a><a target="_blank" rel="noopener" href="https://www.cnblogs.com/qlee/archive/2011/05/16/2048026.html">vector的reserve和resize - 李大嘴 - 博客园</a></h3><p>如下代码会造成程序奔溃:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">vec.<span class="built_in">reserse</span>(<span class="number">10</span>);</span><br><span class="line">vec[<span class="number">0</span>] = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>错误原因在于vector的reverse函数只改变vector的capacity但是它的size并不会改变。<br>size和capacity的区别:</p>
<ul>
<li>size是vector中当前包含的元素个数</li>
<li>capacity是vector的最大可容纳的元素</li>
</ul>
<p>上面的代码调用reserve之后，vector中时没有元素的，因此如果对vec使用下标操作符，在msvc编译器中将导致如下的错误：</p>
<p><img src="/../imgs/2022-12-03-21-45-50.png"></p>
<p>正确的方式为:</p>
<ul>
<li>使用push_back/insert向容器中添加新元素，而不是用下标</li>
<li>或者将reserve替换为resize</li>
</ul>
<h3 id="C-new与delete"><a href="#C-new与delete" class="headerlink" title="C++ new与delete"></a>C++ new与delete</h3><p>new operator 和delete operator 是运算符</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string *ps = <span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">&quot;Hands up!&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>等价于：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *mem = <span class="keyword">operator</span> <span class="built_in"><span class="keyword">new</span></span>(<span class="built_in"><span class="keyword">sizeof</span></span>(string));      <span class="comment">//申请内存</span></span><br><span class="line"><span class="function">call <span class="title">string::string</span><span class="params">(<span class="string">&quot;Hands up!&quot;</span>)</span> on *mem</span>;     <span class="comment">// 调用构造函数</span></span><br><span class="line">string *ps = <span class="keyword">static_cast</span>&lt;string*&gt;(mem);       <span class="comment">// 返回string*指针</span></span><br></pre></td></tr></table></figure>

<p>同样</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> ps</span><br></pre></td></tr></table></figure>
<p>等价于</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ps-&gt;~<span class="built_in">string</span>()</span><br><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(ps)</span></span></span><br></pre></td></tr></table></figure>

<p>编译器看到类类型的new或者delete运算符的时候，首先查看该类是否是有operator new或者operator delete成员，如果类定义了自己的operator new和operator delete函数，则使用这些函数为对象分配和释放内存，否则调用标准库版本（:: operator new和:: operator delete）。</p>
<h3 id="shared-ptr是线程安全的吗"><a href="#shared-ptr是线程安全的吗" class="headerlink" title="shared_ptr是线程安全的吗"></a>shared_ptr是线程安全的吗</h3><ul>
<li>refcnt是使用原子操作来更新的</li>
<li>多个shared_ptr指向同一个对象，在多线程中，只有一个会调用析构函数</li>
<li>不保证储存在其内的对象的线程安全，多个线程同时写的时候需要自己加锁，否则产生UB</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/9127816/stdshared-ptr-thread-safety-explained">c++ - std::shared_ptr thread safety explained - Stack Overflow</a></p>
<p><a target="_blank" rel="noopener" href="https://web.archive.org/web/20140318233637/http://gcc.gnu.org/onlinedocs/libstdc++/manual/shared_ptr.html">libstdc++ shared_ptr</a></p>
<p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/14482830/stdshared-ptr-thread-safety">c++ - std::shared_ptr thread safety - Stack Overflow</a></p>
<h3 id="如何避免shared-ptr的内存碎片问题"><a href="#如何避免shared-ptr的内存碎片问题" class="headerlink" title="如何避免shared_ptr的内存碎片问题"></a>如何避免shared_ptr的内存碎片问题</h3><p>先说结论：先 new 然后赋值的方式，会导致内存碎片化；make_shared 的方法分配内存，不会导致内存产生过多的碎片。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">T* pt = <span class="keyword">new</span> T;</span><br><span class="line"><span class="function">std::shared_ptr&lt;T&gt; <span class="title">p</span><span class="params">(pt)</span></span>;</span><br></pre></td></tr></table></figure>
<p>上面这段代码是先在堆上分配一块内存，然后在堆上再建一个智能指针控制块，这两个东西是不连续的，会造成内存碎片化</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::shared_ptr&lt;T&gt; p = std::make_shared&lt;T&gt;();</span><br></pre></td></tr></table></figure>
<p>上面这段代码是直接在堆上新建一块足够大的内存，其中包含两部分，上面是内存（用来使用），下面是控制块（包含引用计数）。然后用 T 的构造函数去初始化分配的内存（分配一块内存的步骤：先分配内存，再进分配的内存调用构造函数进行构造，构造完毕才能使用）。</p>
<h3 id="vptr和vtable"><a href="#vptr和vtable" class="headerlink" title="vptr和vtable"></a>vptr和vtable</h3><p>只有有类有虚函数或者子类中有虚函数才会产生vptr，vptr指向vtable， vtable第一个slot是关于类的信息，主要用于实现运行时类型识别RTTI技术，后面才是虚函数的地址。 RTTI的用处之一就是为了实现安全的downcast，也就是基类cast为派生类。 在C++里面，需要我们使用dynamic_cast来实现安全的向下转型， 这是发生在运行时的，如果是安全的(如果base type pointer指向一个derived class object), 这个dynamic_cast会返回指向derived class的指针，不过不安全则返回0。</p>
<p>但是注意上面说的指针，如果是引用，会抛出bad_cast exception，因为没有空引用。</p>
<p>vtable位于只读数据区，vptr则不是，可能在堆区，也可能在栈区，因此vtable的开销在编译期，而vptr的开销则在运行时。</p>
<p><a target="_blank" rel="noopener" href="https://www.quora.com/Where-are-virtual-tables-stored-in-C">Where are virtual tables stored in C++? - Quora</a></p>
<h3 id="虚函数是如何工作的呢？"><a href="#虚函数是如何工作的呢？" class="headerlink" title="虚函数是如何工作的呢？"></a>虚函数是如何工作的呢？</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Base *ptr = &amp;obj;</span><br><span class="line">ptr-&gt;<span class="built_in">z</span>();</span><br></pre></td></tr></table></figure>
<ol>
<li>虽然不知道ptr指向的类型是什么，但是可以使用ptr找到obj的vtable，而vtable的第一个slot记录的对象的真正的类型。</li>
<li>虽然不知道z的真正地址，但是可以知道它被放到vtable的哪一个slot中。因此只要访问对应的slot我们就可以找到真正的函数地址。</li>
</ol>
<p>第二点里面，我觉得应该是Base的虚表里面的虚函数，派生类要么不改写直接继承，要么改写，不管怎么样，派生类的vtable都是基于Base的vtable的，在编译时就能知道Base类的每个虚函数在vtable中的slot索引，运行时只不过是换了个vtable而已，slot索引还是不变的。所以可以看出，如果子类自己又加了一个Base类不存在的虚函数，如果ptr真的指向了Base类并调用子类自己加的虚函数，这个时候调用肯定会UB的，大概率会coredump。</p>
<p><a target="_blank" rel="noopener" href="http://notes.tanchuanqi.com/_static/attachment/%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2C++%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B_%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.pdf">深度探索C++对象模型_读书笔记.pdf</a></p>
<h3 id="手动模拟多态的行为"><a href="#手动模拟多态的行为" class="headerlink" title="手动模拟多态的行为"></a>手动模拟多态的行为</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>()&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123; cout &lt;&lt; <span class="string">&quot;Base::print()\n&quot;</span>; &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base</span>()&#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span>* baseI;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Derived</span>(<span class="keyword">int</span> i)&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123; cout &lt;&lt; <span class="string">&quot;Derived::print()\n&quot;</span>;&#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Derived</span>()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Base *b = <span class="keyword">new</span> <span class="built_in">Derived</span>(<span class="number">1000</span>);</span><br><span class="line">    b-&gt;<span class="built_in">print</span>();</span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*Fun)</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">    Fun vfunc = (Fun)*(<span class="keyword">uint64_t</span> *)*((<span class="keyword">uint64_t</span> *)b);</span><br><span class="line">    (*vfunc)();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="RTTI和typeid的区别"><a href="#RTTI和typeid的区别" class="headerlink" title="RTTI和typeid的区别"></a>RTTI和typeid的区别</h3><p>RTTI只适用于多态类型，因为RTTI的信息存在于vtable之中，没有多态，自然也没有vtable。</p>
<p>typeid既可以用于多态也可以用于非多态。<br><img src="/../imgs/2023-04-29-21-31-26.png"></p>
<p>也可以用于多态：<br><img src="/../imgs/2023-04-29-21-31-57.png"><br>这次输出</p>
<p>  Struct A * <br>  Struct B</p>
<p><a target="_blank" rel="noopener" href="http://notes.tanchuanqi.com/_static/attachment/%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2C++%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B_%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.pdf">深度探索C++对象模型_读书笔记.pdf</a></p>
<h3 id="构造函数和析构函数可以是虚函数吗？"><a href="#构造函数和析构函数可以是虚函数吗？" class="headerlink" title="构造函数和析构函数可以是虚函数吗？"></a>构造函数和析构函数可以是虚函数吗？</h3><p>虚函数的主要用途是实现多态，也就是当我们并不知道一个基类指针指向的对象是什么类型的时候。</p>
<ul>
<li><p>构造函数不可以是虚函数，因为虚函数和对象有关，但和类无关，虚函数是通过虚表来调用的，在调用的构造函数之前，对象都还不存在，那么虚表肯定也不存在，所以构造函数不能是虚函数。</p>
</li>
<li><p>对于析构函数，如果基类指针pa指向派生类b，如果我们析构函数不是virtual，那么delete pa，派生类的析构函数将不会调用，因此可能会发生内存泄露。 delete也是调用函数，如果是用派生类指向b，就算析构函数不是虚函数，那么派生类和基类的析构函数也都会被执行。</p>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/733360/why-do-we-not-have-a-virtual-constructor-in-c">Why do we not have a virtual constructor in C++? - Stack Overflow</a></p>
<p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/461203/when-to-use-virtual-destructors/15903538#15903538.this">c++ - When to use virtual destructors? - Stack Overflow</a></p>
<h3 id="map和unoreded-map"><a href="#map和unoreded-map" class="headerlink" title="map和unoreded_map"></a>map和unoreded_map</h3><p><img src="/../imgs/2023-04-28-16-31-23.png"><br>图中哈希表的建立 比较耗时间应该是指哈希函数本省比较耗时。</p>
<p><a target="_blank" rel="noopener" href="https://xzchsia.github.io/2020/04/09/cpp-map-unordered_map/">c++中map与unordered_map的区别 - Hsia的博客 | Hsia Blog</a><br><a target="_blank" rel="noopener" href="https://akaedu.github.io/book/ch26s03.html">3. 哈希表</a></p>
<h3 id="vector和list的比较"><a href="#vector和list的比较" class="headerlink" title="vector和list的比较"></a>vector和list的比较</h3><p>其实就是数据的链表的区别。list不支持随机存取，因此没有operator[].<br>值得关注的问题是下面的迭代器失效的问题。 </p>
<h3 id="迭代器失效"><a href="#迭代器失效" class="headerlink" title="迭代器失效"></a>迭代器失效</h3><h4 id="Insertion"><a href="#Insertion" class="headerlink" title="Insertion"></a>Insertion</h4><p>对于顺序容器：</p>
<ul>
<li><p>Vector: 插入点之前的所有迭代器和引用都不受影响，除非新的容器大小大于以前的容量(在这种情况下，所有迭代器和引用都无效)[23.2.4.3/1]</p>
</li>
<li><p>Deque: 所有迭代器和引用都是无效的，除非插入的成员位于 deque 的末尾(前面或后面)(在这种情况下，所有迭代器都是无效的，但对元素的引用不受影响)[23.2.1.3/1]</p>
</li>
<li><p>List: 所有迭代器和引用不受影响[23.2.2.3/1]</p>
</li>
</ul>
<p>对于关联容器，比如map和set， 插入操作不会发生迭代器失效。</p>
<p>对于容器适配器，如stack，queue， priority_queue来说，取决于他们继承自什么容器。</p>
<h4 id="Erasure"><a href="#Erasure" class="headerlink" title="Erasure"></a>Erasure</h4><p>对于顺序容器：<br>Vector: 擦除点之后的每个迭代器和引用都是无效的[23.2.4.3/3]</p>
<p>Deque: 所有迭代器和引用都是无效的，除非被擦除的成员位于 deque 的末尾(前面或后面)(在这种情况下，只有对被擦除成员的迭代器和引用是无效的)[23.2.1.3/4]</p>
<p>List: 只有对擦除元素的迭代器和引用是无效的[23.2.2.3/3]</p>
<p>关联容器：<br>只有对被擦除元素的迭代器和引用是无效的[23.1.2/8]</p>
<p>对于容器适配器，如stack，queue， priority_queue来说，取决于他们继承自什么容器。</p>
<p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/6438086/iterator-invalidation-rules-for-c-containers">Iterator invalidation rules for C++ containers - Stack Overflow</a></p>
<p><a target="_blank" rel="noopener" href="https://users.cs.fiu.edu/~weiss/Deltoid/msvc_stl_7.html">https://users.cs.fiu.edu/~weiss/Deltoid/msvc_stl_7.html</a></p>
<h3 id="vector的erase和remove的区别"><a href="#vector的erase和remove的区别" class="headerlink" title="vector的erase和remove的区别"></a>vector的erase和remove的区别</h3><p>remove调用后size不会变，只是将后面的值移动到前面来。 所以一般还要配合erase调整vector的大小。看下面例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="keyword">int</span>&gt; vec&#123;<span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;;</span><br><span class="line"><span class="comment">// std::remove move elements and return iterator for vector erase funtion</span></span><br><span class="line"><span class="keyword">auto</span> last = std::<span class="built_in">remove</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), <span class="number">6</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> a:vec)</span><br><span class="line">    cout&lt;&lt;a&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">cout&lt;&lt;endl;</span><br><span class="line"><span class="comment">// 8 10 3 4 5 7 8 6 6 7 8 </span></span><br><span class="line"></span><br><span class="line">vec.<span class="built_in">erase</span>(last, vec.<span class="built_in">end</span>());</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> a:vec)</span><br><span class="line">    cout&lt;&lt;a&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">cout&lt;&lt;endl;</span><br><span class="line"><span class="comment">// 8 10 3 4 5 7 8 </span></span><br></pre></td></tr></table></figure>
<p><img src="/../imgs/2023-04-28-17-39-00.png"></p>
<p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/799314/difference-between-erase-and-remove">c++ - Difference between erase and remove - Stack Overflow</a></p>
<h3 id="关于虚函数和多态的题"><a href="#关于虚函数和多态的题" class="headerlink" title="关于虚函数和多态的题"></a>关于虚函数和多态的题</h3><h4 id=""><a href="#" class="headerlink" title=""></a></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;B::f()&quot;</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span>:</span><span class="keyword">public</span> B</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;D::f()&quot;</span>;&#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    B b;</span><br><span class="line">    B &amp;p1=b;</span><br><span class="line">    D &amp;p2=<span class="keyword">static_cast</span>&lt;D&amp;&gt;(p1);</span><br><span class="line">    p2.<span class="built_in">f</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h4 id="-1"><a href="#-1" class="headerlink" title=""></a></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">A</span> (<span class="keyword">int</span> k):<span class="built_in">num1</span>(k) &#123;&#125;</span><br><span class="line">  ~<span class="built_in">A</span> ()&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">setNum</span> <span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;num2 = val;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">getNum</span> <span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">  <span class="keyword">int</span> num1;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="keyword">int</span> num2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">A::getNum</span> <span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">max</span> (num1, num2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span><span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">B</span> (<span class="keyword">int</span> val):<span class="built_in">A</span> (val)&#123;&#125;</span><br><span class="line">  </span><br><span class="line">  ~<span class="built_in">B</span> ()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">const</span> A <span class="title">a</span> <span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">  <span class="function">B <span class="title">b</span> <span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line"><span class="comment">//   a.setNum (6);</span></span><br><span class="line">  b.<span class="built_in">setNum</span> (<span class="number">2</span>);</span><br><span class="line">  cout &lt;&lt; b.num1 &lt;&lt; endl;</span><br><span class="line"><span class="comment">//   cout &lt;&lt; b.num2 &lt;&lt; endl; //error: ‘int A::num2’ is protected within this context</span></span><br><span class="line">  cout &lt;&lt; a.<span class="built_in">getNum</span> () &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt; b.<span class="built_in">getNum</span> () &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="-2"><a href="#-2" class="headerlink" title=""></a></h3><h3 id="-3"><a href="#-3" class="headerlink" title=""></a></h3><h3 id="-4"><a href="#-4" class="headerlink" title=""></a></h3><h3 id="-5"><a href="#-5" class="headerlink" title=""></a></h3><h3 id="-6"><a href="#-6" class="headerlink" title=""></a></h3><h3 id="-7"><a href="#-7" class="headerlink" title=""></a></h3><h2 id="体系结构"><a href="#体系结构" class="headerlink" title="体系结构"></a>体系结构</h2><h3 id="如果理解CPU的流水线"><a href="#如果理解CPU的流水线" class="headerlink" title="如果理解CPU的流水线"></a>如果理解CPU的流水线</h3><p>首先，流水线增加的不是单条指令的执行速度，而是程序整体单位时间执行的指令个数，也就是提高了吞吐量。为什么可以提高吞吐量呢，现代的处理器将一条指令的执行分为多个步骤，比如经典的取值，译码，执行，访存，写回5级流水线。 如果不用流水线，只有上一条指令的这5个步骤结束了，下一个指令才能开始执行这5个步骤，如下：<br><img src="/../imgs/2023-05-04-22-04-37.png"></p>
<p>但是如果使用流水线，这5个步骤就可以并行进行，从上面的图可以看出，没有流水线，一条指令执行的时候，其他4个部件都是空闲的。而使用流水线，可以保证大部分时间，这几个部件都是处于工作状态的。从指令的视角如下图：<br><img src="/../imgs/2023-05-04-22-08-19.png"></p>
<p>从每个处理器部件的角度来看：<br><img src="/../imgs/2023-05-04-22-09-41.png"></p>
<p>流水线存在的问题的流水线风险hazard, 也就是在执行下一条指令的时候，数据还没准备好。从下面的图可以看出，下一条指令的源寄存器依赖于上一条指令结果。</p>
<p><img src="/../imgs/2023-05-04-22-14-43.png"></p>
<h3 id="如何判断大小端？"><a href="#如何判断大小端？" class="headerlink" title="如何判断大小端？"></a>如何判断大小端？</h3><p>首先，大端小端的区别：<br><img src="/../imgs/2023-05-18-23-16-50.png"></p>
<p>大端模式（Big-Endian）：指的是数据的低位保存在内存的高地址中，而数据的高位保存在内存的低地址中.</p>
<p>小端模式（Little-Endian）：指的是数据的低位保存在内存的低地址中，而数据的高位保存在内存的高地址中。</p>
<p>上面可以看出，对于0x12345678， 我们怎么把他放进内存呢？ 如果先放0x12，那这就是大端， 如果先放0x78，那么就是小端。 可以看出，大端很符合人的阅读习惯。 而小端，由于数据低位，由于CPU的运算逻辑， 数据低位在内存低位很符合CPU的“阅读习惯”</p>
<h4 id="怎么判断电脑是大端还是小端呢？"><a href="#怎么判断电脑是大端还是小端呢？" class="headerlink" title="怎么判断电脑是大端还是小端呢？"></a>怎么判断电脑是大端还是小端呢？</h4><h5 id="对于不同CPU"><a href="#对于不同CPU" class="headerlink" title="对于不同CPU"></a>对于不同CPU</h5><p>大端模式: PowerPC、IBM、Sun；<br>小端模式 : x86、DEC；<br>ARM既可以工作在大端模式，也可以工作在小端模式。</p>
<h5 id="写代码实现"><a href="#写代码实现" class="headerlink" title="写代码实现"></a>写代码实现</h5><p>根据上面说的， 应该很简单就可以写出来了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">0x12345678</span>;</span><br><span class="line"><span class="comment">// 取地址是为了让编译器将x储存在内存中， 因为大小序表现在内存中</span></span><br><span class="line"><span class="comment">// 如果cx是12， 则是大端</span></span><br><span class="line"><span class="comment">// 如果cx是78， 则是小端</span></span><br><span class="line"><span class="keyword">char</span> cx = <span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>*&gt;(&amp;x)[<span class="number">0</span>];</span><br></pre></td></tr></table></figure>

<h4 id="如何进行大端小端转化呢"><a href="#如何进行大端小端转化呢" class="headerlink" title="如何进行大端小端转化呢"></a>如何进行大端小端转化呢</h4><p>答案是使用C网络编程中htonx, ntohx系列函数， x可以是l和s，分别代表int和short。自己写一个也很简单。 </p>
<p>字节序问题之大小端模式讲解 - 灰色飘零 - 博客园<br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/renhui/p/13600572.html">https://www.cnblogs.com/renhui/p/13600572.html</a></p>
<h2 id="嵌入式"><a href="#嵌入式" class="headerlink" title="嵌入式"></a>嵌入式</h2><h3 id="一些问题"><a href="#一些问题" class="headerlink" title="一些问题"></a>一些问题</h3><h4 id="端口复用和端口重映射的区别？"><a href="#端口复用和端口重映射的区别？" class="headerlink" title="端口复用和端口重映射的区别？"></a>端口复用和端口重映射的区别？</h4><ul>
<li><p>端口复用：STM32有很多的内置外设，这些外设的外部引脚都是与GPIO复用的。当我们把GPIO引脚作为外设的IO引脚时（通过软件配置），这个时候就产生了GPIO引脚复用。</p>
</li>
<li><p>端口重映射：外设里面的输入输出引脚一般都是默认和某个GPIO口一起使用，但是多个外设的端口可能会使用同一个GPIO口，这样就不能同时使用两个外设了，要想同时使用两个外设，这个时候就需要使用端口重映射，即把其中一个外设的输入输出重新映射到其他端口。</p>
</li>
</ul>
<h4 id="什么时候需要开启AFIO时钟？-开启引脚复用的时候需要开启AFIO时钟吗？"><a href="#什么时候需要开启AFIO时钟？-开启引脚复用的时候需要开启AFIO时钟吗？" class="headerlink" title="什么时候需要开启AFIO时钟？ 开启引脚复用的时候需要开启AFIO时钟吗？"></a>什么时候需要开启AFIO时钟？ 开启引脚复用的时候需要开启AFIO时钟吗？</h4><p>首先要搞清楚为什么需要开启时钟， 当我们要对芯片内部的硬件进行控制（读写其寄存器），要控制哪一部分，就要开启那一部分的时钟。</p>
<p>那AFIO有哪些寄存器呢？ 通过手册可以知道，AFIO主要的寄存器和EXTI外部中断和端口重映射相关，因此要使用者两个功能的时候应该开启AFIO时钟。</p>
<h4 id="如果复用功能开启了，如何通过GPIO知道外设输出了什么？"><a href="#如果复用功能开启了，如何通过GPIO知道外设输出了什么？" class="headerlink" title="如果复用功能开启了，如何通过GPIO知道外设输出了什么？"></a>如果复用功能开启了，如何通过GPIO知道外设输出了什么？</h4><p>首先，不应该去读取ODR， 因为手册里说了：如果把端口配置成复用输出功能，则引脚和输出寄存器断开，并和片上外设的输出信号连接。</p>
<p>根据手册上说的：在每个APB2时钟周期，出现在I/O脚上的数据被采样到输入数据寄存器</p>
<p>因此我们可以去读取IDR， 以知道外设输出了什么。</p>
<h4 id="AHB-APB1-APB2"><a href="#AHB-APB1-APB2" class="headerlink" title="AHB, APB1, APB2"></a>AHB, APB1, APB2</h4><p>APB1, APB2是从AHB桥接出去的。APB1操作速度限于36MHz， APB2操作于全速(最高72MHz), 在使用一个外设之前，必须设置寄存器RCC_AHBENR来打开该外设的时钟</p>
<h3 id="网站资源"><a href="#网站资源" class="headerlink" title="网站资源"></a>网站资源</h3><p><a target="_blank" rel="noopener" href="https://aijishu.com/blog/zhiguoxin">嵌入式开发 - 极术社区 - 连接开发者与智能计算生态</a></p>
<p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000042746286?utm_source=sf-similar-article">嵌入式 - 10个问题，让你真正学懂三极管 - 个人文章 - SegmentFault 思否</a></p>
<h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><h3 id="关于TCP三次握手和四次挥手"><a href="#关于TCP三次握手和四次挥手" class="headerlink" title="关于TCP三次握手和四次挥手"></a>关于TCP三次握手和四次挥手</h3><p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/news/646106">终于搞懂了 TCP 的 11 种状态 ，太不容易了… - 腾讯云开发者社区-腾讯云</a></p>
<h4 id="TCP的11个状态："><a href="#TCP的11个状态：" class="headerlink" title="TCP的11个状态："></a>TCP的11个状态：</h4><ul>
<li><p>CLOSED：初始状态，表示TCP连接是”关闭着的”或”未打开的”</p>
</li>
<li><p>LISTEN：表示服务器端的某个SOCKET处于监听状态，可以接受客户端的连接</p>
</li>
<li><p>SYN_RCVD：表示服务器接收到了来自客户端请求连接的SYN报文。这个状态是在服务端的，但是它是一个中间状态，很短暂，平常我们用netstat或ss的时候，不太容易看到这种状态，但是遇到SYN flood之类的SYN攻击时，会出现大量的这种状态，即收不到三次握手最后一个客户端发来的ACK，所以一直是这个状态，不会转换到ESTABLISHED</p>
</li>
<li><p>SYN_SENT：这个状态与SYN_RCVD状态相呼应，，它是TCP连接客户端的状态，当客户端SOCKET执行connect()进行连接时，它首先发送SYN报文，然后随机进入到SYN_SENT状态，并等待服务端的SYN和ACK，该状态表示客户端的SYN已发送<br>ESTABLISHED：表示TCP连接已经成功建立，开始传输数据</p>
</li>
</ul>
<ul>
<li><p>FIN_WAIT_1：这个状态在实际工作中很少能看到，当客户端想要主动关闭连接时，它会向服务端发送FIN报文，此时TCP状态就进入到FIN_WAIT_1的状态，而当服务端回复ACK，确认关闭后，则客户端进入到FIN_WAIT_2的状态，也就是只有在没有收到服务端ACK的情况下，FIN_WAIT_1状态才能看到，然后长时间收不到ACK，通常会在默认超时时间60s(由内核参数tcp_fin_timeout控制)后，直接进入CLOSED状态</p>
</li>
<li><p>FIN_WAIT_2：这个状态相比较常见，也是需要注意的一个状态，FIN_WAIT_1在接收到服务端ACK之后就进入到FIN_WAIT_2的状态，然后等待服务端发送FIN，所以在收到对端FIN之前，TCP都会处于FIN_WAIT_2的状态，也就是，在主动断开的一端发现大量的FIN_WAIT_2状态时，需要注意，可能时网络不稳定或程序中忘记调用连接关闭，FIN_WAIT_2也有超时时间，也是由内核参数tcp_fin_timeout控制，当FIN_WAIT_2状态超时后，连接直接销毁</p>
</li>
<li><p>CLOSE_WAIT：表示正在等待关闭，该状态只在被动端出现，即当主动断开的一端调用close()后发送FIN报文给被动端，被动段必然会回应一个ACK(这是由TCP协议层决定的)，这个时候，TCP连接状态就进入到CLOSE_WAIT</p>
</li>
<li><p>LAST_ACK：当被动关闭的一方在发送FIN报文后，等待对方的ACK报文的时候，就处于LAST_ACK的状态，当收到对方的ACK之后，就进入到CLOSED状态了</p>
</li>
<li><p>TIME_WAIT：该状态是最常见的状态，主动方在收到对方FIN后，就由FIN_WAIT_2状态进入到TIME_WAIT状态</p>
</li>
<li><p>CLOSING：这个状态是一个比较特殊的状态，也比较少见，正常情况下不会出现，但是当双方同时都作为主动的一方，调用 close() 关闭连接的时候，两边都进入FIN_WAIT_1 的状态，此时期望收到的是ACK包，进入 FIN_WAIT_2 的状态，但是却先收到了对方的FIN包，这个时候，就会进入到 CLOSING 的状态，然后给对方一个ACK，接收到 ACK 后直接进入到 CLOSED 状态。</p>
</li>
</ul>
<h4 id="关于-TCP-第-3-部分-TCP-3-次握手（续）。"><a href="#关于-TCP-第-3-部分-TCP-3-次握手（续）。" class="headerlink" title="关于 TCP - 第 3 部分 - TCP 3 次握手（续）。"></a>关于 TCP - 第 3 部分 - TCP 3 次握手（续）。</h4><p><a target="_blank" rel="noopener" href="https://www.linkedin.com/pulse/all-tcp-part-3-3-way-handshaking-explained-mohamed-kamal-1">https://www.linkedin.com/pulse/all-tcp-part-3-3-way-handshaking-explained-mohamed-kamal-1</a></p>
<h4 id="为什么需要-TIME-WAIT-状态？"><a href="#为什么需要-TIME-WAIT-状态？" class="headerlink" title="为什么需要 TIME_WAIT 状态？"></a>为什么需要 TIME_WAIT 状态？</h4><p>主动发起关闭连接的一方，才会有 TIME-WAIT 状态。<br>原因：</p>
<ul>
<li>防止具有相同「四元组」的「旧」数据包被收到；</li>
<li>保证「被动关闭连接」的一方能被正确的关闭，即保证最后的 ACK 能让被动关闭方接收，从而帮助其正常关闭；</li>
</ul>
<h4 id="为什么CLOSE-WAIT需要2MSL"><a href="#为什么CLOSE-WAIT需要2MSL" class="headerlink" title="为什么CLOSE_WAIT需要2MSL"></a>为什么CLOSE_WAIT需要2MSL</h4><p>MSL 是 Maximum Segment Lifetime，报文最大生存时间，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。</p>
<p>2MSL的时间是从客户端接收到 FIN 后发送 ACK 开始计时的。如果在 TIME-WAIT 时间内，因为客户端的 ACK 没有传输到服务端，客户端又接收到了服务端重发的 FIN 报文，那么 2MSL 时间将重新计时。</p>
<p>为了便于描述，我们设想有一个处于断开过程中的TCP连接，这个连接的两端分别是A和B，其中A是主动关闭连接的一端，因为刚刚向对端发送了针对对端发送过来的FIN报文的ACK，此时正处于TIME_WAIT状态；而B是被动关闭的一端，此时正处于LAST_ACK状态，在收到最后一个ACK之前它会一直重传FIN报文直至超时。随着时间的流逝，A发送给B的ACK报文将会有两种结局：</p>
<ul>
<li><p>ACK报文在网络中丢失：如前所述，这种情况我们不需要考虑，因为除非多次重传失败，否则AB两端的状态不会发生变化直至某一个ACK不再丢失。</p>
</li>
<li><p>ACK报文被B接收到。我们假设A发送了ACK报文后过了一段时间t之后B才收到该ACK，则有 0 &lt; t &lt;= MSL。因为A并不知道它发送出去的ACK要多久对方才能收到，所以A至少要维持MSL时长的TIME_WAIT状态才能保证它的ACK从网络中消失。同时处于LAST_ACK状态的B因为收到了ACK，所以它直接就进入了CLOSED状态，而不会向网络发送任何报文。所以晃眼一看，A只需要等待1个MSL就够了，但仔细想一下其实1个MSL是不行的，因为在B收到ACK前的一刹那，B可能因为没收到ACK而重传了一个FIN报文，这个FIN报文要从网络中消失最多还需要一个MSL时长，所以A还需要多等一个MSL。</p>
</li>
</ul>
<p>综上所述，TIME_WAIT至少需要持续2MSL时长，这2个MSL中的第一个MSL是为了等自己发出去的最后一个ACK从网络中消失，而第二MSL是为了等在对端收到ACK之前的一刹那可能重传的FIN报文从网络中消失。可以看到 2MSL时长 这其实是相当于至少允许报文丢失一次。比如，若 ACK 在一个 MSL 内丢失，这样被动方重发的 FIN 会在第 2 个 MSL 内到达，TIME_WAIT 状态的连接可以应对。</p>
<p>为什么不是 4 或者 8 MSL 的时长呢？你可以想象一个丢包率达到百分之一的糟糕网络，连续两次丢包的概率只有万分之一，这个概率实在是太小了，忽略它比解决它更具性价比。</p>
<h3 id="在epoll中为什么用ET-NONBLOCKING"><a href="#在epoll中为什么用ET-NONBLOCKING" class="headerlink" title="在epoll中为什么用ET+NONBLOCKING"></a>在epoll中为什么用ET+NONBLOCKING</h3><ol>
<li>边缘触发只在第一次数据到达的时候通知wait，如果这次没读完，后面也不会通知wait(LT只要缓冲区中有数据就会通知wait)。 对于ET+BLOCKING，如果一个socket一次来了很多数据，一次没读完，这个时候就会从recv或者read返回，如果后面还有数据来还好，如果没数据再来，程序一直阻塞在wait调用，剩下的数据就会一直停留在socket的缓冲区中等待读取。那能不能一次把数据读完呢，这个时候就会出现新的问题，阻塞读可能会花费很长的时间，这样就没机会处理epoll中的其他事件了。使用非阻塞读取的话，<a target="_blank" rel="noopener" href="https://copyconstruct.medium.com/nonblocking-i-o-99948ad7c957">读操作会立即返回(即使数据没有完全被读出来)</a>。这样就可以去处理epoll的其他事件了。</li>
<li>假设一个消息要读三次才能读完，在阻塞IO里要注意，epoll只会通知有数据可以读，但是不会通知可以读多少，所以只能读取一次，然后等待下一次epoll_wait通知下一次读取事件。可能我们会想，为什么不用循环读呢，原因是因为我们不知道到底有多少数据要读，不知道要读多少次，while循环的话，本来只需要读三次就能读完，那么第四次循环就会阻塞。而非阻塞采用这种方案就不会出现这种情况，因为没数据读的时候会直接返回-1，并设置errno为EAGAIN或者EWOULDBLOCK。</li>
<li>还有就是对于select来说，man select里面bug节说一：<br>Under Linux, select() may report a socket file descriptor as “ready for reading”, while nevertheless a subsequent read blocks.  This could for example happen when       data has arrived but upon examination has wrong checksum and is discarded.  There may be other circumstances in which a file descriptor is spuriously reported  as       ready.  Thus it may be safer to use O_NONBLOCK on sockets that should not block.</li>
</ol>
<h3 id="使用Linux-epoll模型的LT水平触发模式，当socket可写时，会不停的触发socket可写的事件，如何处理？"><a href="#使用Linux-epoll模型的LT水平触发模式，当socket可写时，会不停的触发socket可写的事件，如何处理？" class="headerlink" title="使用Linux epoll模型的LT水平触发模式，当socket可写时，会不停的触发socket可写的事件，如何处理？"></a>使用Linux epoll模型的LT水平触发模式，当socket可写时，会不停的触发socket可写的事件，如何处理？</h3><p>网络流传的腾讯面试题<br>这道题目对LT和ET考察比较深入，验证了前文说的LT模式write问题。</p>
<p>普通做法：</p>
<p>当需要向socket写数据时，将该socket加入到epoll等待可写事件。接收到socket可写事件后，调用write()或send()发送数据，当数据全部写完后， 将socket描述符移出epoll列表，这种做法需要反复添加和删除。</p>
<p>改进做法:</p>
<p>向socket写数据时直接调用send()发送，当send()返回错误码EAGAIN，才将socket加入到epoll，等待可写事件后再发送数据，全部数据发送完毕，再移出epoll模型，改进的做法相当于认为socket在大部分时候是可写的(小数据)，不能写了再让epoll帮忙监控(数据太大了触发EAGAIN)。</p>
<pre><code>当客户通过Socket提供的send函数发送大的数据包时，就可能返回一个EGGAIN的错误。该错误产生的原因是由于send 函数中的size变量大小超过了tcp_sendspace的值。
</code></pre>
<h2 id="LINUX"><a href="#LINUX" class="headerlink" title="LINUX"></a>LINUX</h2><h3 id="驱动相关"><a href="#驱动相关" class="headerlink" title="驱动相关"></a>驱动相关</h3><h4 id="设备树是什么"><a href="#设备树是什么" class="headerlink" title="设备树是什么"></a>设备树是什么</h4><p>设备树（device tree）机制是Linux内核从linux-3.x版本开始引进的一种机制，目的是解决内核源码的arch/arm目录下代码混乱的问题：随着ARM生态的快速发展，在内核源码的arch/arm目录下，存放着几十种arm芯片和几百个开发板相关的源文件，很多开发板和处理器的中断、寄存器等相关硬件资源都在这个目录下以.c或.h的文件格式定义。而对于内核来说，与这些硬件耦合，会导致内核代码混乱不堪，每个开发板上运行的内核镜像都必须单独编译配置，无法通用。什么时候Linux内核能像Windows镜像那样，无论你的电脑什么配置，一个Windows安装包，都可以直接下载安装运行呢？</p>
<p>设备树(Device Tree)，将这个词分开就是“设备”和“树”，描述设备树的文件叫做 DTS(DeviceTree Source)，这个 DTS 文件采用树形结构描述板级设备，也就是开发板上的设备信息，比如CPU 数量、 内存基地址、IIC 接口上接了哪些设备、SPI 接口上接了哪些设备等等。</p>
<p>它基本上就是画一棵电路板上 CPU、总线、设备组成的树，Bootloader 会将这棵树传<br>递给内核，然后内核可以识别这棵树，并根据它展开出 Linux 内核中的 platform_device、<br>i2c_client、spi_device 等设备，而这些设备用到的内存、IRQ 等资源，也被传递给了内核，内核会将这些资源绑定给展开的相应的设备。</p>
<p>总结： 以前对于arm来说， 每个硬件都是在.c .h文件中用代码手写的，比如配置寄存器之类的代码，随着arm芯片和开发板不断增加，内核肯定越来越大，而且很混乱。 有了设备树，只有设备树上的设备才是需要的，这些设备的硬件上的细节由DTB提供给内核， 而不需要像之前写在代码里。 DTS经过DTC编译得到DTB， DTB由BootLoader传递给内核。</p>
<p>为什么windows不需要DT呢， 似乎说windows的设备都是通过pcie连接的，可以枚举出来。或者x86 架构的个人计算机通常不使用设备树，而是依靠各种自动配置协议来识别硬件。</p>
<p>不懂Linux Device Tree，被新人嘲笑之后，含泪写完 - 与非网<br><a target="_blank" rel="noopener" href="https://www.eefocus.com/article/474573.html">https://www.eefocus.com/article/474573.html</a></p>
<p>Microsoft Word - ARM Device Tree设备树.docx<br><a target="_blank" rel="noopener" href="http://www.valleytalk.org/wp-content/uploads/2013/05/ARM-Device-Tree%E8%AE%BE%E5%A4%87%E6%A0%91.pdf">http://www.valleytalk.org/wp-content/uploads/2013/05/ARM-Device-Tree%E8%AE%BE%E5%A4%87%E6%A0%91.pdf</a></p>
<h4 id="LINUX设备驱动模型"><a href="#LINUX设备驱动模型" class="headerlink" title="LINUX设备驱动模型"></a>LINUX设备驱动模型</h4><p>一文带你搞懂 Linux 设备树 - 知乎<br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/476561682">https://zhuanlan.zhihu.com/p/476561682</a></p>
<h3 id="LINUX-1"><a href="#LINUX-1" class="headerlink" title="LINUX"></a>LINUX</h3><ol>
<li>sed的/和字符串变量里面的/冲突了怎么办？把sed分隔符随便换一个就行，比如~  <a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/27787536/how-to-pass-a-variable-containing-slashes-to-sed">bash - How to pass a variable containing slashes to sed - Stack Overflow</a></li>
<li></li>
<li></li>
</ol>
<h2 id="循环引用的解释"><a href="#循环引用的解释" class="headerlink" title="循环引用的解释"></a>循环引用的解释</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">		std::shared_ptr&lt;Person&gt; best_friend;</span><br><span class="line">		<span class="built_in">Person</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;ctor &quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">		~<span class="built_in">Person</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;dtor &quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">auto</span> pa = std::make_shared&lt;Person&gt;();</span><br><span class="line">	<span class="keyword">auto</span> pb = std::make_shared&lt;Person&gt;();</span><br><span class="line">	pa-&gt;best_friend = pb;</span><br><span class="line">	pb-&gt;best_friend = pa;</span><br><span class="line">&#125;<span class="comment">//1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<pre><code>上面的析构函数一个都不会打印。当离开1的时候，pa是一个智能指针，它会查看它自己的ref count，发现是2（pa和pb-&gt;best_friend都指向同一个对象），所以它的ref count减一，但并不销毁pa指向的对象。pb也是一样，他们各自离开1之后，pa和pb指向的std::shared_ptr&lt;Person&gt;对象的ref count都是1，因此，发生了内存泄露。 

如果我们把best_friend的类型改写成std::weak_ptr&lt;Person&gt;就不会出现上述的问题，因此weak_ptr指向一个shared对象并不会使该对象的ref count计数加一。weak_ptr只是拥有使用权，但并不拥有管理权。
</code></pre>
<p>Even if both pa and pb are deconstructed out of scope, the memory will not be released. Why? After pa leaves the scope, the only pointer object of pa has actually died, but the object pointed to by pa has not died, because at this time one of pb can only point to this object. After pb leaves the scope, the smart pointer pb is actually finished, but the object pointed to by pb is not dead, because there is still a pointer to it in the object pointed to by pa. Finally, because the two objects hold pointers to each other, their reference counts are both 1, which makes the memory unable to be released. </p>
<p>After understanding the implementation principle of smart pointers and the principle of memory leaks caused by circular references, use</p>
<p>weak_ptr<br>This kind of weak pointer that does not increase the reference count can solve this problem well.</p>
<h2 id="智力题"><a href="#智力题" class="headerlink" title="智力题"></a>智力题</h2><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/2d54e2affb91">https://www.jianshu.com/p/2d54e2affb91</a></p>
<h2 id="misc"><a href="#misc" class="headerlink" title="misc"></a>misc</h2><h3 id="auto-login-remote-server-via-vscode"><a href="#auto-login-remote-server-via-vscode" class="headerlink" title="auto login remote server via vscode"></a>auto login remote server via vscode</h3><p>run following command in powershell(hostname might be a ip adress):</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$USER_AT_HOST</span>=<span class="string">&quot;your-user-name-on-host@hostname&quot;</span></span><br><span class="line"><span class="variable">$PUBKEYPATH</span>=<span class="string">&quot;<span class="variable">$HOME</span>\.ssh\id_ed25519.pub&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$pubKey</span>=(Get-Content <span class="string">&quot;<span class="variable">$PUBKEYPATH</span>&quot;</span> | Out-String); ssh <span class="string">&quot;<span class="variable">$USER_AT_HOST</span>&quot;</span> <span class="string">&quot;mkdir -p ~/.ssh &amp;&amp; chmod 700 ~/.ssh &amp;&amp; echo &#x27;<span class="variable">$&#123;pubKey&#125;</span>&#x27; &gt;&gt; ~/.ssh/authorized_keys &amp;&amp; chmod 600 ~/.ssh/authorized_keys&quot;</span></span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://code.visualstudio.com/docs/remote/troubleshooting">Visual Studio Code Remote Development Troubleshooting Tips and Tricks</a></p>
<h3 id="github镜像站"><a href="#github镜像站" class="headerlink" title="github镜像站"></a>github镜像站</h3><p><a target="_blank" rel="noopener" href="https://github.rc1844.workers.dev/">https://github.rc1844.workers.dev/</a></p>
<p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000041466088">2022目前三种有效加速国内Github - 个人文章 - SegmentFault 思否</a></p>
<h3 id="ANSI，unicode和utf-8的关系"><a href="#ANSI，unicode和utf-8的关系" class="headerlink" title="ANSI，unicode和utf-8的关系"></a>ANSI，unicode和utf-8的关系</h3><p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000003493738">编码基础概念:ANSI和unicode - SegmentFault 思否</a></p>
<h3 id="如何将C盘上的wsl2转移到其他盘"><a href="#如何将C盘上的wsl2转移到其他盘" class="headerlink" title="如何将C盘上的wsl2转移到其他盘"></a>如何将C盘上的wsl2转移到其他盘</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">wsl --list --verbose</span><br><span class="line">mkdir d:\backuplinux</span><br><span class="line">wsl --<span class="built_in">export</span> Ubuntu-18.04 d:\backuplinux\ubuntu.tar</span><br><span class="line">wsl --unregister Ubuntu-18.04</span><br><span class="line">mkdir d:\wsl</span><br><span class="line">wsl --import Ubuntu-18.04 d:\wsl\ d:\backuplinux\ubuntu.tar</span><br><span class="line"><span class="built_in">cd</span> %userprofile%\AppData\Local\Microsoft\WindowsApps            **(this is not needed <span class="keyword">if</span> <span class="keyword">in</span> path)**</span><br><span class="line">ubuntu1804.exe config --default-user yourloginname</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://superuser.com/questions/1550622/move-wsl2-file-system-to-another-drive">windows subsystem for linux - Move WSL2 file system to another drive - Super User</a></p>
<h2 id="E"><a href="#E" class="headerlink" title="E"></a>E</h2><p>天府新区创新创业人才云服务平台-成都数字媒体产业化基地有限公司<br><a target="_blank" rel="noopener" href="https://www.tianfustartup.org.cn/secondlevel/recruit?Id=kUPturIhdDtCuzgtnW22UQ==">https://www.tianfustartup.org.cn/secondlevel/recruit?Id=kUPturIhdDtCuzgtnW22UQ==</a></p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/07/27/C-%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E9%97%B4%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE/" rel="prev" title="C++多线程-线程间共享数据">
      <i class="fa fa-chevron-left"></i> C++多线程-线程间共享数据
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/09/06/about-pimpl-you-should-know/" rel="next" title="about pimpl, you should know...">
      about pimpl, you should know... <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%97%E6%B3%95"><span class="nav-number">1.</span> <span class="nav-text">算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98"><span class="nav-number">1.1.</span> <span class="nav-text">背包问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%8801%E8%83%8C%E5%8C%85%E8%A6%81%E9%80%86%E5%BA%8F%E8%80%8C%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E4%B8%8D%E7%94%A8"><span class="nav-number">1.1.1.</span> <span class="nav-text">为什么01背包要逆序而完全背包不用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#K%E6%8E%92%E5%BA%8F"><span class="nav-number">1.2.</span> <span class="nav-text">K排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%8C%E5%BE%97%E5%88%B0%E6%9C%80%E5%A4%A7%E7%9A%84%E5%B0%8F%E6%95%B0"><span class="nav-number">1.3.</span> <span class="nav-text">删除字符串，得到最大的小数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#01%E4%B8%B2%E5%8F%98%E6%88%90%E5%85%A80%E6%88%96%E8%80%851"><span class="nav-number">1.4.</span> <span class="nav-text">01串变成全0或者1</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%86%E9%93%BE%E8%A1%A8%E5%88%86%E7%BB%84%EF%BC%8C%E7%84%B6%E5%90%8E%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2"><span class="nav-number">1.5.</span> <span class="nav-text">将链表分组，然后两两交换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0%E7%9A%84%E4%B8%AA%E6%95%B0"><span class="nav-number">1.6.</span> <span class="nav-text">最大公约数的个数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%82%E6%88%96%E7%AD%89%E4%BA%8E%E4%B9%98%E7%A7%AF"><span class="nav-number">1.7.</span> <span class="nav-text">异或等于乘积</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C"><span class="nav-number">2.</span> <span class="nav-text">C++</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#make-shared"><span class="nav-number">2.1.</span> <span class="nav-text">make_shared</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#gdb"><span class="nav-number">3.</span> <span class="nav-text">gdb</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E8%81%94%E6%B1%87%E7%BC%96"><span class="nav-number">4.</span> <span class="nav-text">内联汇编</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E7%B2%98%E8%B4%B4"><span class="nav-number">5.</span> <span class="nav-text">代码粘贴</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-1"><span class="nav-number">6.</span> <span class="nav-text">C++</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%BB%E5%8F%96char-%E6%AF%94const-char-%E5%BF%AB"><span class="nav-number">6.1.</span> <span class="nav-text">读取char[]比const char*快</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#C-Using-weak-ptr-for-circular-references-nextptr"><span class="nav-number">6.2.</span> <span class="nav-text">C++ | Using weak_ptr for circular references - nextptr</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#c-11-When-is-std-weak-ptr-useful-Stack-Overflow"><span class="nav-number">6.3.</span> <span class="nav-text">c++11 - When is std::weak_ptr useful? - Stack Overflow</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#c-Why-would-I-std-move-an-std-shared-ptr-Stack-Overflow"><span class="nav-number">6.4.</span> <span class="nav-text">c++ - Why would I std::move an std::shared_ptr? - Stack Overflow</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#c-What-is-The-Rule-of-Three-Stack-Overflow"><span class="nav-number">6.5.</span> <span class="nav-text">c++ - What is The Rule of Three? - Stack Overflow</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#c-Why-is-auto-ptr-being-deprecated-Stack-Overflow"><span class="nav-number">6.6.</span> <span class="nav-text">c++ - Why is auto_ptr being deprecated? - Stack Overflow</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AAshared-ptr"><span class="nav-number">6.7.</span> <span class="nav-text">手写一个shared_ptr</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#C-%E5%A3%B0%E6%98%8E%E7%A7%BB%E5%8A%A8-%E5%A4%8D%E5%88%B6%E6%93%8D%E4%BD%9C%E4%BC%9A%E6%8A%91%E5%88%B6%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C%E7%9A%84%E7%94%9F%E6%88%90"><span class="nav-number">6.8.</span> <span class="nav-text">C++ 声明移动&#x2F;复制操作会抑制相关操作的生成</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#C-return-local-object-Stack-Overflow"><span class="nav-number">6.9.</span> <span class="nav-text">C++ return local object - Stack Overflow</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Indirect-vs-Direct-Function-Call-Overhead-in-C-C"><span class="nav-number">6.10.</span> <span class="nav-text">Indirect vs Direct Function Call Overhead in C&#x2F;C++</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#c-How-do-I-use-a-custom-deleter-with-a-std-unique-ptr-member-Stack-Overflow"><span class="nav-number">6.11.</span> <span class="nav-text">c++ - How do I use a custom deleter with a std::unique_ptr member? - Stack Overflow</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#vector%E7%9A%84reserve%E5%92%8Cresize-%E6%9D%8E%E5%A4%A7%E5%98%B4-%E5%8D%9A%E5%AE%A2%E5%9B%AD"><span class="nav-number">6.12.</span> <span class="nav-text">vector的reserve和resize - 李大嘴 - 博客园</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#C-new%E4%B8%8Edelete"><span class="nav-number">6.13.</span> <span class="nav-text">C++ new与delete</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#shared-ptr%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%90%97"><span class="nav-number">6.14.</span> <span class="nav-text">shared_ptr是线程安全的吗</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8Dshared-ptr%E7%9A%84%E5%86%85%E5%AD%98%E7%A2%8E%E7%89%87%E9%97%AE%E9%A2%98"><span class="nav-number">6.15.</span> <span class="nav-text">如何避免shared_ptr的内存碎片问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#vptr%E5%92%8Cvtable"><span class="nav-number">6.16.</span> <span class="nav-text">vptr和vtable</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84%E5%91%A2%EF%BC%9F"><span class="nav-number">6.17.</span> <span class="nav-text">虚函数是如何工作的呢？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%8B%E5%8A%A8%E6%A8%A1%E6%8B%9F%E5%A4%9A%E6%80%81%E7%9A%84%E8%A1%8C%E4%B8%BA"><span class="nav-number">6.18.</span> <span class="nav-text">手动模拟多态的行为</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RTTI%E5%92%8Ctypeid%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">6.19.</span> <span class="nav-text">RTTI和typeid的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E5%8F%AF%E4%BB%A5%E6%98%AF%E8%99%9A%E5%87%BD%E6%95%B0%E5%90%97%EF%BC%9F"><span class="nav-number">6.20.</span> <span class="nav-text">构造函数和析构函数可以是虚函数吗？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#map%E5%92%8Cunoreded-map"><span class="nav-number">6.21.</span> <span class="nav-text">map和unoreded_map</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#vector%E5%92%8Clist%E7%9A%84%E6%AF%94%E8%BE%83"><span class="nav-number">6.22.</span> <span class="nav-text">vector和list的比较</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%A4%B1%E6%95%88"><span class="nav-number">6.23.</span> <span class="nav-text">迭代器失效</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Insertion"><span class="nav-number">6.23.1.</span> <span class="nav-text">Insertion</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Erasure"><span class="nav-number">6.23.2.</span> <span class="nav-text">Erasure</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#vector%E7%9A%84erase%E5%92%8Cremove%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">6.24.</span> <span class="nav-text">vector的erase和remove的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B3%E4%BA%8E%E8%99%9A%E5%87%BD%E6%95%B0%E5%92%8C%E5%A4%9A%E6%80%81%E7%9A%84%E9%A2%98"><span class="nav-number">6.25.</span> <span class="nav-text">关于虚函数和多态的题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">6.25.1.</span> <span class="nav-text"></span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#-1"><span class="nav-number">6.25.2.</span> <span class="nav-text"></span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#-2"><span class="nav-number">6.26.</span> <span class="nav-text"></span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#-3"><span class="nav-number">6.27.</span> <span class="nav-text"></span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#-4"><span class="nav-number">6.28.</span> <span class="nav-text"></span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#-5"><span class="nav-number">6.29.</span> <span class="nav-text"></span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#-6"><span class="nav-number">6.30.</span> <span class="nav-text"></span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#-7"><span class="nav-number">6.31.</span> <span class="nav-text"></span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="nav-number">7.</span> <span class="nav-text">体系结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E6%9E%9C%E7%90%86%E8%A7%A3CPU%E7%9A%84%E6%B5%81%E6%B0%B4%E7%BA%BF"><span class="nav-number">7.1.</span> <span class="nav-text">如果理解CPU的流水线</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E5%A4%A7%E5%B0%8F%E7%AB%AF%EF%BC%9F"><span class="nav-number">7.2.</span> <span class="nav-text">如何判断大小端？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%80%8E%E4%B9%88%E5%88%A4%E6%96%AD%E7%94%B5%E8%84%91%E6%98%AF%E5%A4%A7%E7%AB%AF%E8%BF%98%E6%98%AF%E5%B0%8F%E7%AB%AF%E5%91%A2%EF%BC%9F"><span class="nav-number">7.2.1.</span> <span class="nav-text">怎么判断电脑是大端还是小端呢？</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AF%B9%E4%BA%8E%E4%B8%8D%E5%90%8CCPU"><span class="nav-number">7.2.1.1.</span> <span class="nav-text">对于不同CPU</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%86%99%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="nav-number">7.2.1.2.</span> <span class="nav-text">写代码实现</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E5%A4%A7%E7%AB%AF%E5%B0%8F%E7%AB%AF%E8%BD%AC%E5%8C%96%E5%91%A2"><span class="nav-number">7.2.2.</span> <span class="nav-text">如何进行大端小端转化呢</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B5%8C%E5%85%A5%E5%BC%8F"><span class="nav-number">8.</span> <span class="nav-text">嵌入式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98"><span class="nav-number">8.1.</span> <span class="nav-text">一些问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AB%AF%E5%8F%A3%E5%A4%8D%E7%94%A8%E5%92%8C%E7%AB%AF%E5%8F%A3%E9%87%8D%E6%98%A0%E5%B0%84%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">8.1.1.</span> <span class="nav-text">端口复用和端口重映射的区别？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E9%9C%80%E8%A6%81%E5%BC%80%E5%90%AFAFIO%E6%97%B6%E9%92%9F%EF%BC%9F-%E5%BC%80%E5%90%AF%E5%BC%95%E8%84%9A%E5%A4%8D%E7%94%A8%E7%9A%84%E6%97%B6%E5%80%99%E9%9C%80%E8%A6%81%E5%BC%80%E5%90%AFAFIO%E6%97%B6%E9%92%9F%E5%90%97%EF%BC%9F"><span class="nav-number">8.1.2.</span> <span class="nav-text">什么时候需要开启AFIO时钟？ 开启引脚复用的时候需要开启AFIO时钟吗？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E6%9E%9C%E5%A4%8D%E7%94%A8%E5%8A%9F%E8%83%BD%E5%BC%80%E5%90%AF%E4%BA%86%EF%BC%8C%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87GPIO%E7%9F%A5%E9%81%93%E5%A4%96%E8%AE%BE%E8%BE%93%E5%87%BA%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">8.1.3.</span> <span class="nav-text">如果复用功能开启了，如何通过GPIO知道外设输出了什么？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#AHB-APB1-APB2"><span class="nav-number">8.1.4.</span> <span class="nav-text">AHB, APB1, APB2</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BD%91%E7%AB%99%E8%B5%84%E6%BA%90"><span class="nav-number">8.2.</span> <span class="nav-text">网站资源</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C"><span class="nav-number">9.</span> <span class="nav-text">网络</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B3%E4%BA%8ETCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="nav-number">9.1.</span> <span class="nav-text">关于TCP三次握手和四次挥手</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP%E7%9A%8411%E4%B8%AA%E7%8A%B6%E6%80%81%EF%BC%9A"><span class="nav-number">9.1.1.</span> <span class="nav-text">TCP的11个状态：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B3%E4%BA%8E-TCP-%E7%AC%AC-3-%E9%83%A8%E5%88%86-TCP-3-%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%88%E7%BB%AD%EF%BC%89%E3%80%82"><span class="nav-number">9.1.2.</span> <span class="nav-text">关于 TCP - 第 3 部分 - TCP 3 次握手（续）。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81-TIME-WAIT-%E7%8A%B6%E6%80%81%EF%BC%9F"><span class="nav-number">9.1.3.</span> <span class="nav-text">为什么需要 TIME_WAIT 状态？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88CLOSE-WAIT%E9%9C%80%E8%A6%812MSL"><span class="nav-number">9.1.4.</span> <span class="nav-text">为什么CLOSE_WAIT需要2MSL</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%A8epoll%E4%B8%AD%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8ET-NONBLOCKING"><span class="nav-number">9.2.</span> <span class="nav-text">在epoll中为什么用ET+NONBLOCKING</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8Linux-epoll%E6%A8%A1%E5%9E%8B%E7%9A%84LT%E6%B0%B4%E5%B9%B3%E8%A7%A6%E5%8F%91%E6%A8%A1%E5%BC%8F%EF%BC%8C%E5%BD%93socket%E5%8F%AF%E5%86%99%E6%97%B6%EF%BC%8C%E4%BC%9A%E4%B8%8D%E5%81%9C%E7%9A%84%E8%A7%A6%E5%8F%91socket%E5%8F%AF%E5%86%99%E7%9A%84%E4%BA%8B%E4%BB%B6%EF%BC%8C%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%EF%BC%9F"><span class="nav-number">9.3.</span> <span class="nav-text">使用Linux epoll模型的LT水平触发模式，当socket可写时，会不停的触发socket可写的事件，如何处理？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LINUX"><span class="nav-number">10.</span> <span class="nav-text">LINUX</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A9%B1%E5%8A%A8%E7%9B%B8%E5%85%B3"><span class="nav-number">10.1.</span> <span class="nav-text">驱动相关</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%BE%E5%A4%87%E6%A0%91%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">10.1.1.</span> <span class="nav-text">设备树是什么</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#LINUX%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B"><span class="nav-number">10.1.2.</span> <span class="nav-text">LINUX设备驱动模型</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LINUX-1"><span class="nav-number">10.2.</span> <span class="nav-text">LINUX</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8%E7%9A%84%E8%A7%A3%E9%87%8A"><span class="nav-number">11.</span> <span class="nav-text">循环引用的解释</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%99%BA%E5%8A%9B%E9%A2%98"><span class="nav-number">12.</span> <span class="nav-text">智力题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#misc"><span class="nav-number">13.</span> <span class="nav-text">misc</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#auto-login-remote-server-via-vscode"><span class="nav-number">13.1.</span> <span class="nav-text">auto login remote server via vscode</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#github%E9%95%9C%E5%83%8F%E7%AB%99"><span class="nav-number">13.2.</span> <span class="nav-text">github镜像站</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ANSI%EF%BC%8Cunicode%E5%92%8Cutf-8%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-number">13.3.</span> <span class="nav-text">ANSI，unicode和utf-8的关系</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%B0%86C%E7%9B%98%E4%B8%8A%E7%9A%84wsl2%E8%BD%AC%E7%A7%BB%E5%88%B0%E5%85%B6%E4%BB%96%E7%9B%98"><span class="nav-number">13.4.</span> <span class="nav-text">如何将C盘上的wsl2转移到其他盘</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#E"><span class="nav-number">14.</span> <span class="nav-text">E</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">John Doe</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">22</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
